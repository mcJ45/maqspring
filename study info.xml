
<CoreJava>

    <jvm>
         
           read article on daily basis         
		 
    </jvm>
	
    <program>
	
					 <armstrong>
					 
					  if number is abc===then--a3+b3+c3===abc()
						while(temp>0)
						{
							r=temp%10;
							sum=sum+(r*r*r);
							temp=temp/10;
						}
						
					</armstrong>
					
					<palindrome>
					
					ulta krne pr sidha
					
					   1.while(origNum>0)
						{
							r=origNum%10;
							sum=(sum*10)+r;
							origNum=origNum/10;
						}
						
						2.String t=t+r;
						
					</palindrome>
					
					<prime>

 					number is divisible by only itsef and 1
					
								for(int i=1;i less=num;i++)
								{
									  if(num%i==0)
									  {
										c++;
									  }
								}
					</prime>
					
					<fibo>
					
					    //0 1 1 2 3 5 .......
						
						System.out.println("fibonaci series");
						
						int c=10;
						
						int n1=0;int n2=1;
						int n3;	
						System.out.println(n1+" "+n2);
						
						for(int i=2;i lt c;i++)
						{
							 n3=n1+n2;
							 System.out.println(" "+n3);
							 n1=n2;
							 n2=n3;
						   
						   
						}
					
					
					</fibo>
						
					<factorial>
					
						   int res=1;
							for(int i=1;i less=num;i++)
							{
								res=res*i;
							}
							
					</factorial>
  								 
    </program>
				  
   <note>
     
	 <one>
	     
				 private constructor(singleton calss):  >> if a calss declared private constructor then instnace of calss can only be created
											   within class, other calss can not create instance of private contructor class.
										
													  >> this calss can not be subclass(to sub class , class must have public constructor)	
													  
				 singleton class     :  declared private constructor and  Add getter(factory) method to return 	instance of class			   
									   
				 final class         :  if class declared final this calss can not be extend 
				 
				 final method        :  if method decalred final this method can not be overridden in other calss	

				 >> NoSuchMethod:main if not declared properly like public static void main(string[] args)	
				 >>  public static void final sysnchronized main() is a valid main method		 
			 
				 >> new : No CLassDefFoundError
				 >> newInstance() :(no arg constructor is compulsary) ClassnotFoundException		
	 
	 </one>
	 
   </note>
  
  <Basic>
           <jdkDetail>
		  
		        JDK/JRE/JVM/JIT 
		   
		   </jdkDetail>
		  
		  <garbageCollectro> 
				  <one>
				        
						responsible for removing unwanted/unreferenced object and 
					    The Garbage collector of JVM collects only those objects that are created by new keyword.
						
                 </one>
				 
				 <two> 
				      
					  finalize() method
				      The finalize() method is invoked each time before the object is garbage collected.
					  This method can be used to perform cleanup processing. This method is defined in Object class as:
                      protected void finalize(){}

                      The Garbage collector of JVM collects only those objects that are created by new keyword. 
					  So if you have created any object without new, you can use finalize method to perform cleanup processing 
					  (destroying remaining objects).
				 
				 </two>
				 
				 <three> 
				     
					 gc() method
                     The gc() method is used to invoke the garbage collector to perform cleanup processing. 
					 The gc() is found in System and Runtime classes.
					 public static void gc(){}
				      
				 </three>
				 
				 <note>
				       
					   -->     Many people think garbage collection collects and discards dead objects.
                            In reality, Java garbage collection is doing the opposite! Live objects are tracked and everything 
							else designated garbage.

                       -->     When an object is no longer used, the garbage collector reclaims the underlying memory and reuses it for 
							future object allocation. This means there is no explicit deletion and no memory is given back to 
							the operating system. To determine which objects are no longer in use, the JVM intermittently 
							runs what is very aptly called a ep algorithm.
				 </note>

		   </garbageCollectro>
		   
		  <namingConventionFOR_CLASS>
		         <one> One Java file must contain only one public class or zero </one>
				 <two> The file name should be as Public Class   </two>
				 <three> IF one java file  contain multiple default Class and not any public calss then "file name can be anything you 
				    can compile with any class name"
				 </three>
		  </namingConventionFOR_CLASS>
         
		 <postpreINCREMENT>
                   <one> POST...FIRST USE VALUE THEN INCREMENT </one>
				   <two> PREE...FIRST INCREMENT VALUE THEN USE </two>
			
			</postpreINCREMENT> 
			
			<GLOBALVARIABLE>
			
				    Data Type	Default value
					Int         	0
					boolean	    false
					byte	     0
					short	    0
					long	    0
					float	    0.0
					double	     0.0
					All Derived Types	null

			</GLOBALVARIABLE>
			
			<localVar>
			  
			    must be initialized before use
				only final modifier can be used otherwise will generate "Illegal start of execution" 
				
			 </localVar>
			
			<DATAtype>
			
			    byte      8bit   0
				short     2byte  0
				int       4 byte  0
				long      8 byte  0L
				
				float     4 byte  0.0f.(upto 5 to 6 decimal)
			    double    8byte   0.0d;(upto 14 to 15 decimal pont)
				
				boolean   1byt    false 
			    
				char      2byte    'u0000'(  java uses 2byte for char because java suports 18 international language
                          				     and all language character can not be fit into 1 byte i.e. it uses 2byte to represent 
										     all char from 18 internation language
										  )
			</DATAtype>
			
			<Operators>
			
			     ....
				 instanceOf
				 operator precedence
			
			</Operators>
			
			<control_statements>
			     
				 if/switch/for/for_each/while/do_while
			
			</control_statements>
			
			<array>  
			
			        java.util.Arrays
						<one> dataType[] arrayVar = new dataType[arraySize];</one>
						<two> dataType[] arrayVar = {value0, value1, ..., valuek};</two>
			        method:
					public static int binarySearch(Object[] a, Object key)
					public static boolean equals(long[] a, long[] a2)
					public static void fill(int[] a, int val)
					public static void sort(Object[] a)
					
					<note>
					
					    int x[]=new int[-3];
					    if declared array size with negative size then " java.lang.NegativeArraySizeException"
						
						OutOfMemoryError --->  If array size declared with highest number(size of int+1)
						
				    </note>		
			
			</array>
			
			<String>
			
			      >>The java.lang.String class implements Serializable, Comparable and CharSequence interfaces.
				  
				  >>why java strings are immutable.
				  
				  >>we can make any class as immutable by declaring class as final and its members as final;
			
			     immmutable objects...
			
			    SN	  Methods with Description
				1	 char charAt(int index) 
				     Returns the character at the specified index.
				2	int compareTo(Object o) 
				      Compares this String to another Object.
				3	int compareTo(String anotherString)
				       Compares two strings lexicographically.
				4	int compareToIgnoreCase(String str) 
				      Compares two strings lexicographically, ignoring case differences.
				5	String concat(String str)
				      Concatenates the specified string to the end of this string.
				6	boolean contentEquals(StringBuffer sb) 
				       Returns true if and only if this String represents the same sequence of characters as the specified StringBuffer.
				7	static String copyValueOf(char[] data) 
				      Returns a String that represents the character sequence in the array specified.
				8	static String copyValueOf(char[] data, int offset, int count)
				       Returns a String that represents the character sequence in the array specified.
				9	boolean endsWith(String suffix) 
				       Tests if this string ends with the specified suffix.
				10	boolean equals(Object anObject)
						Compares this string to the specified object.
				11	boolean equalsIgnoreCase(String anotherString)
						Compares this String to another String, ignoring case considerations.
				12	byte getBytes() 
						Encodes this String into a sequence of bytes using the platforms default charset, storing the result into a new byte array.
				13	byte[] getBytes(String charsetName
						Encodes this String into a sequence of bytes using the named charset, storing the result into a new byte array.
				14	void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
						Copies characters from this string into the destination character array.
				15	int hashCode()
						Returns a hash code for this string.
				16	int indexOf(int ch) 
						Returns the index within this string of the first occurrence of the specified character.
				17	int indexOf(int ch, int fromIndex) 
						Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index.
				18	int indexOf(String str)
						Returns the index within this string of the first occurrence of the specified substring.
				19	int indexOf(String str, int fromIndex)
						Returns the index within this string of the first occurrence of the specified substring, starting at the specified index.
				20	String intern()
						Returns a canonical representation for the string object.
				21	int lastIndexOf(int ch) 
						Returns the index within this string of the last occurrence of the specified character.
				22	int lastIndexOf(int ch, int fromIndex) 
						Returns the index within this string of the last occurrence of the specified character, searching backward starting at the specified index.
				23	int lastIndexOf(String str)
						Returns the index within this string of the rightmost occurrence of the specified substring.
				24	int lastIndexOf(String str, int fromIndex) 
						Returns the index within this string of the last occurrence of the specified substring, searching backward starting at the specified index.
				25	int length() 
						Returns the length of this string.
				26	boolean matches(String regex)
						Tells whether or not this string matches the given regular expression.
				27	boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) 
						Tests if two string regions are equal.
				28	boolean regionMatches(int toffset, String other, int ooffset, int len)
						Tests if two string regions are equal.
				29	String replace(char oldChar, char newChar)
						Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar.
				30	String replaceAll(String regex, String replacement)
						Replaces each substring of this string that matches the given regular expression with the given replacement.
				31	String replaceFirst(String regex, String replacement) 
						Replaces the first substring of this string that matches the given regular expression with the given replacement.
				32	String[] split(String regex) 
						Splits this string around matches of the given regular expression.
				33	String[] split(String regex, int limit) 
						Splits this string around matches of the given regular expression.
				34	boolean startsWith(String prefix)
						Tests if this string starts with the specified prefix.
				35	boolean startsWith(String prefix, int toffset)
						Tests if this string starts with the specified prefix beginning a specified index.
				36	CharSequence subSequence(int beginIndex, int endIndex)
						Returns a new character sequence that is a subsequence of this sequence.
				37	String substring(int beginIndex)
						Returns a new string that is a substring of this string.
				38	String substring(int beginIndex, int endIndex)
						Returns a new string that is a substring of this string.
				39	char[] toCharArray() 
						Converts this string to a new character array.
				40	String toLowerCase()
						Converts all of the characters in this String to lower case using the rules of the default locale.
				41	String toLowerCase(Locale locale)
						Converts all of the characters in this String to lower case using the rules of the given Locale.
				42	String toString()
						This object (which is already a string!) is itself returned.
				43	String toUpperCase() 
						Converts all of the characters in this String to upper case using the rules of the default locale.
				44	String toUpperCase(Locale locale) 
						Converts all of the characters in this String to upper case using the rules of the given Locale.
				45	String trim() 
						Returns a copy of the string, with leading and trailing whitespace omitted.
				46	static String valueOf(primitive data type x) 
						Returns the string representation of the passed data type argument.
							
		        	<stringTokenizer>
					
					         >>The java.util.StringTokenizer class allows you to break a string into tokens. It is simple way to break string.
							 
							    Constructor	                Description
								StringTokenizer(String str)	creates StringTokenizer with specified string.
								StringTokenizer(String str, String delim)	creates StringTokenizer with specified string and delimeter.
								StringTokenizer(String str, String delim, boolean returnValue)	creates StringTokenizer with specified string, delimeter and returnValue. If return value is true, delimiter characters are considered to be tokens. If it is false, delimiter characters serve to separate tokens.
								Methods of StringTokenizer class

								The 6 useful methods of StringTokenizer class are as follows:

								Public method	        Description
								boolean hasMoreTokens()	checks if there is more tokens available.
								String nextToken()	returns the next token from the StringTokenizer object.
								String nextToken(String delim)	returns the next token based on the delimeter.
								boolean hasMoreElements()	same as hasMoreTokens() method.
								Object nextElement()	same as nextToken() but its return type is Object.
								int countTokens()	returns the total number of tokens.
								
								>> StringTokenizer class is deprecated now. It is recommended to use split() method of String class or regex (Regular Expression).
					
					
					</stringTokenizer>
			
			</String>
 
            <access_modifiers>
			
			    <one>
				
				   class level  only public or no
                   public can be acces from anywhere
				   no default only from same package.
				   
				</one>
				
				<two2> 
				      
					   members level/variable = method
				       public and no modifier – the same way as used in class level.
                       private – members CAN ONLY access.
                       protected – CAN be accessed from ‘same package’ and a subclass existing in any package can access.
				
				</two2>
				
				<three>
     			
  				   if a class is private means it can not be subcalssed/instanaciated from outer class
				   if protected only within same package it can be accessed.
				   
				</three>
				
			</access_modifiers>
			
			<strictfp>
			
						Java strictfp keyword ensures that you will get the same result on every platform if you perform operations in the floating-point
						variable. 
						The precision may differ from platform to platform that is why java programming language have provided the strictfp keyword, 
						so that you get same result on every platform. So, now you have better control over the floating-point arithmetic.

							>>Legal code for strictfp keyword

							>>The strictfp keyword can be applied on methods, classes and interfaces.

							>>strictfp class A{}//strictfp applied on class  
							
							>>strictfp interface M{}//strictfp applied on interface  
							
							>>class A{  
							     strictfp void m(){}//strictfp applied on method  
							}  
							
							>>The strictfp keyword cannot be applied on abstract methods, variables or constructors.
			
			</strictfp>
			
			<inheritance>
			       >>inheriting/extnding/reusing/parental_child propert from one claas to another class.
				   >>IS-A relationship --this object is a type of anoter object
				   >>class can not extend more than one class
				   >>private members of super class not accesible
				   >>constructor /initialize block not inherited into sub class
				   >>@Override---reuse of superclass property/ runtime polymorphism
				   >>final methd can not be override
				   >>static method can not be override but it can be re-declared
				   >>constructor can not be override
				   >>modifiers level in subclass can be increased but not less.
				   <polymorphism>
				   
				       runtime---override
					   compiletime---overloading--/changing data type/changing number of param
				   </polymorphism>
				   
				   
				   Covariant Return Type:: when return type of overrided method can be changed-degraded
			
			</inheritance>
			
			<abstraction>
			          >> if class contain any abstract method then class must be declared as abstract
					  >>if class extend any abstract class then it is compulsary to implements/override method of abstract class
					  >> if class does not want to implements/override method from abstract class then it must be declare as abstract.
			           >> abstract class can have abstract and non abstract method.
					   >>varible can be final and non final and static and non static variable.
					   >>abstract class can provide implementation of interface
					   >>abstract class can only extend one java class and implents multile interface
					   >>members in abstract class can be public /private/protected.
			</abstraction>
			
			<encapsulation>
					1. Encapsulated Code is more flexible and easy to change with new requirements.
					2. Encapsulation in Java makes unit testing easy.
					3. Encapsulation in Java allows you to control who can access what.
					4. Encapsulation also helps to write immutable class in Java which are a good choice in multi-threading environment.
					5. Encapsulation reduce coupling of modules and increase cohesion inside a module because all piece of one thing are encapsulated in 
					   one place.
					6. Encapsulation allows you to change one part of code without affecting other part of code.
								
			</encapsulation>
			
			<interface>
			       >>multiple method decared but no implementatin.
				   >>bydefault members are public static abstract final
				   >>can extend another interface
				   
				   <tagging_interface>
				       An interface with no methods in it is referred to as a tagging interface. There are two basic design purposes of tagging interfaces:
				   </tagging_interface>
				   
				   java 8 have static and default method in interface with body.
			</interface>
			
			<static>
			
			    static block executed before main
			</static>
			
			<final>
			
			   variable---can not be changed and must assigned in construstor.
			   
			   method---can not be overriden in subcalss
			  
			   class----can not be extended ..must have all method declared as final
			   
			</final>
			
			<binding>
			      early-static-decided by compiler
			      late-dynamic-decided by jvm.
			</binding>
			
			<cloning>
			
						The object cloning is a way to create exact copy of an object. For this purpose, clone() method of Object class is used to clone an
						object.

						The java.lang.Cloneable interface must be implemented by the class whose object clone we want to create. If we don't implement
						Cloneable interface, clone() method generates CloneNotSupportedException.

						The clone() method is defined in the Object class. Syntax of the clone() method is as follows:

						protected Object clone() throws CloneNotSupportedException

						Student18 s1=new Student18(101,"amit");  
						  
						Student18 s2=(Student18)s1.clone();  
			
			
			
			</cloning>
			
			<initialize_block>
			    <static>
				    >>Static Initialization blocks run once when the class is first loaded.
					>>Initialization blocks execute in the order they appear.
					
					>static method can only access static variable and can only call static method directly by classname
					>>but we can call it after object creation of new class.
				
				</static>
				
				<non_static_instance>
				       >>Instance Initialization blocks run every time a class instance is created.
                        >>Instance Initialization blocks run after the constructor’s call to super().
						
						The instance initializer block is created when instance of the class is created.
							The instance initializer block is invoked after the parent class constructor is 
							invoked (i.e. after super() constructor call).
						The instance initializer block comes in the order in which they appear.
				</non_static_instance>
			</initialize_block>
			
			<regExp>
			
			   >>Java Regex API provides 1 interface and 3 classes in java.util.regex package.
			   
			   It provides following classes and interface for regular expressions. The Matcher and Pattern classes are widely used in java regular expression.

					MatchResult interface
					Matcher class
					Pattern class
					PatternSyntaxException class
					
					
					Matcher class

						It implements MatchResult interface. It is a regex engine i.e. used to perform match operations on a character sequence.

						No.	Method	Description
						1	boolean matches()	test whether the regular expression matches the pattern.
						2	boolean find()	finds the next expression that matches the pattern.
						3	boolean find(int start)	finds the next expression that matches the pattern from the given start number.
						4	String group()	returns the matched subsequence.
						5	int start()	returns the starting index of the matched subsequence.
						6	int end()	returns the ending index of the matched subsequence.
						7	int groupCount()	returns the total number of the matched subsequence.
						
						
					Pattern class

								It is the compiled version of a regular expression. It is used to define a pattern for the regex engine.

								No.	Method	Description
								1	static Pattern compile(String regex)	                    compiles the given regex and return the instance of pattern.
								2	Matcher matcher(CharSequence input)	                        creates a matcher that matches the given input with pattern.
								3	static boolean matches(String regex, CharSequence input)	It works as the combination of compile and matcher   methods. It compiles the regular expression and matches the given input with the pattern.
								
								4	String[] split(CharSequence input)                      	splits the given input string around matches of given pattern.
								5	String pattern()	                                        returns the regex pattern.	

                      
					  
					  3.1. Common matching symbols

							Regular Expression	            Description
							.                               Matches any character
							^regex                          Finds regex that must match at the beginning of the line.
							regex$                          Finds regex that must match at the end of the line.
							[abc]                           Set definition, can match the letter a or b or c.
							[abc][vz]                       Set definition, can match a or b or c followed by either v or z.
							[^abc]                          When a caret appears as the first character inside square brackets, it negates the pattern.
                                        							This pattern matches any character except a or b or c.
							
							[a-d1-7]                        Ranges: matches a letter between a and d and figures from 1 to 7, but not d1.
							X|Z                             Finds X or Z.
							XZ                              Finds X directly followed by Z.
		                    $                               Checks if a line end follows.
							
							
							3.2. Meta characters

							    The following meta characters have a pre-defined meaning and make certain common patterns easier to use, e.g., \d instead of [0..9].                 Regular Expression	Description
									\d                      Any digit, short for [0-9]
									\D                      A non-digit, short for [^0-9]
									\s                      A whitespace character, short for [ \t\n\x0b\r\f]
									\S                      A non-whitespace character, short for
									\w                      A word character, short for [a-zA-Z_0-9]
									\W                      A non-word character [^\w]
									\S+                     Several non-whitespace characters
									\b                      Matches a word boundary where a word character is [a-zA-Z0-9_]
									
							3.3. Quantifier

									A quantifier defines how often an element can occur. The symbols ?, *, + and {} define the quantity of the regular
									expressions

									Regular Expression	          Description	                                         Examples
									>>*                         Occurs zero or more times, is short for {0,}        X* finds no or several letter X, <sbr />                                                                                .* finds any character sequence
									
									>>+                         Occurs one or more times, is short for {1,}         X+- Finds one or several letter X
									
									>>?                         Occurs no or one times, ? is short for {0,1}.       X? finds no or exactly one letter X
									
									>>{X}                       Occurs X number of times, {} describes the order of the preceding liberal ..\d{3}   		
									searches                                                                                                
									                                                                                 for three digits, .{10} for any character 
																													 sequence of length 10.
									
									>>{X,Y}                    Occurs between X and Y times,                         \d{1,4} means \d must occur at least
									once and at a maximum of four.
									
									>>*?                      ? after a quantifier makes it a reluctant quantifier. It tries to find the smallest match. 
									This makes the regular expression stop at the first match.
																		
																			
			</regExp>
			
			<exception>
			
			           https://www.javatpoint.com/images/throwable.png
			        Exception hierarchay:
					  
					  Throwable
					      Exception                                     Error
						  
						  IOExcpetion									StackOverFlowError
						  SQLException									VirtualMachineError
						  ClassNotFounfExcepton							OutOfMemoryErroy
						  RunTimeException
						      -->ArithMeticException
							  -->NullPointerException
							  -->NumberFormatException
							  -->IndexOutOfBoundsException
							        -->ArrayIndexOutOfBoundsException
									-->StringIndexOutOfBoundsException
				 
				 
				 <checked>
				      These are the type of exceptions for which the compiler checks to ensure that your code is prepared for handling such exceptions. 
				        >> ClassNotFoundException Class not found.
						>> CloneNotSupportedException Attempt to clone an object that does not implement theCloneable interface.
						>> IllegalAccessException Access to a class is denied.
						>> InstantiationException Attempt to create an object of an abstract class or interface.
						>> InterruptedException One thread has been interrupted by another thread.
						>> NoSuchFieldException A requested field does not exist.
						>> NoSuchMethodException A requested method does not exist
				 </checked>
				 
				 <unchecked>
				 
				       ==>  Unchecked Exceptions: The compiler does not check for such type of exceptions. Unchecked Exceptions comprise of run time exceptions (of type RuntimeException or its subclasses) and errors (of type Error or its subclasses). Runtime Exceptions occur due to program bugs
				       ==> program logic


						List of unchecked exception
						----------------------------
						ArithmeticException                       Arithmetic error, such as divide-by-zero.
						ArrayIndexOutOfBoundsException            Array index is out-of-bounds.
						ArrayStoreException                       Assignment to an array element of an incompatible type.
						ClassCastException                        Invalid cast.
						IllegalArgumentException                  Illegal argument used to invoke a method.
						IllegalMonitorStateException              Illegal monitor operation, such as waiting on an unlocked thread.
						IllegalStateException                     Environment or application is in incorrect state.
						IllegalThreadStateException               Requested operation not compatible with current thread state.
						IndexOutOfBoundsException                 Some type of index is out-of-bounds.
						NegativeArraySizeException                Array created with a negative size.
						NullPointerException                      Invalid use of a null reference.
						NumberFormatException                     Invalid conversion of a string to a numeric format.
						SecurityException                         Attempt to violate security.
						StringIndexOutOfBounds                    Attempt to index outside the bounds of a string.
						UnsupportedOperationException             An unsupported operation was encountered.					   
				 </unchecked>
			       
				   Following is the list of important methods available in the Throwable class.
				   SN	Methods with Description
					1	public String getMessage()
					             Returns a detailed message about the exception that has occurred. This message is initialized in the Throwable constructor.
					2	public Throwable getCause()
					             Returns the cause of the exception as represented by a Throwable object.
					3	public String toString()
					             Returns the name of the class concatenated with the result of getMessage()
					4	public void printStackTrace()
					            Prints the result of toString() along with the stack trace to System.err, the error output stream.
					5	public StackTraceElement [] getStackTrace()
					           Returns an array containing each element on the stack trace. The element at index 0 represents the top of the call stack, and the last element in the array represents the method at the bottom of the call stack.
					6	public Throwable fillInStackTrace()
					           Fills the stack trace of this Throwable object with the current stack trace, adding to any previous information in the stack trace.

			 <try/>
             <catch/>
             <finally/>must be executed block/must follow try-finally or try-catch-finally
			<nested_try/>	
            <throw>
			   
			   used to call/throw custom exception
			   throw new ArithmeticException("age to play more");
            </throw>	
            <throws>
			    custom exception / used in method signature
				  Rule: If you are calling a method that declares an exception, you must either caught or declare the exception.

					There are two cases:

					Case1:You caught the exception i.e. handle the exception using try/catch.
					Case2:You declare the exception i.e. specifying throws with the method.
            </throws>	
             <Exception_propagation/>			
			  <Note>
			  
					 <one>
           					 There are few things to remember when overriding a method with exception handling. If super class method does not declare any exception, 
			    	 	     then sub class overridden method cannot declare checked exception but it can declare unchecked exceptions.
					 </one>
					 <two>
					         If Super class method throws an exception, then Subclass overridden method can throw the same exception or no exception,
					         but must not throw parent exception of the exception thrown by Super class method.
					 </two>
					 
			 </Note>
			 
			 <userDefinedException>
			            By extending Exception
			 </userDefinedException>
			 <multipleException>
			    try--catch-catch-----...finally
			 </multipleException>
			
			
			</exception>
			
			<innerClass>
			
			      >>decalred inside class
				  >>can access outer class private/public members.
			      
				  
				  <WHY_nested_class>
				  
					        It is a way of logically grouping classes that are only used in one place.
							It increases encapsulation.
							Nested classes can lead to more readable and maintainable code.
							
				  </WHY_nested_class>
				  
				  Types of nested class
				  ----------
				      1.non-static-nested(inner class)
							a)Member inner class
							b)Annomynous inner class
							c)Local inner class
			
			          2. static nested class
					  
					           As with class methods and variables, a static nested class is associated with its outer class. And like static class methods,
							   a static nested class cannot refer directly to instance variables or methods defined in its enclosing class —
							   it can use them only through an object reference.
							   
							   OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
							   
							   
				        1. A.Member inner class
                               inside class
								---
								       Inner in = new Inner();
								
								outside class
								-----
										Outer obj = new Outer();
										Outer.Inner in = obj.new Inner();
								The outer class can call even the private methods of the inner class
								
					   1. B..Anonymous 
                                        the class declared inside the body of a method without naming it is known as anonymous inner classes.	
 
								with interface
										      interface Employee{
														void work();
													}

													class Manager{
													  public static void main(String args[]){
														 Employee emp = new Employee(){
															void work()
															{
															   System.out.println("Manage the team");}
															};
														  emp.work();
													   }
													}


                         1. c)Local inner class
						       >>inside method
							   >>must call from method

                      <nestedInterface>
					        interface inside class
					        class inside interface
					  </nestedInterface>
 
			</innerClass>
           
		   <multithreading>
		   
		              <note>
					  
					        >>     Thread will be usefull when in your code/system there is something important and common resource that will be
 							   required by multiple user ,or the same code is redundant not dependent on others
							  then suppose multiple/thousand of user is hitting for same resource then there must be chances of 
							  deadlock/system hang/system crash.
							 
							>>     so to avoid deadlock/system hang/system crash java has given provision "thread mechanism"
							 so by using thread we can actually devide task into multiple number of peices/thread. so that if multiple user wants 
							 to access same resource at same time
							 then we will convert number user into multple thred and ony will allow only one thread to be executed at one time.
							 
							 >> Thread priority running will be decided by  os but we can change it in coding also.
							 >> Code can also be blocked to execute completely by one thread then only others thread can be executed.
							 
							 
					  </note>
					  
						Multithreading is a process of executing multiple threads simultaneously. A program can be divided into a number of small processes.
						Each small process can be addressed as a single thread (a lightweight process). Multithreaded programs contain two or more threads 
						that can run concurrently. 
		                This means that a single program can perform two or more tasks simultaneously. For example, one thread is writing content 
						on a file at the same time another thread is performing spelling check.
						
						Thread is basically a lightweight subprocess, a smallest unit of processing. Multiprocessing and multithreading,
						both are used to achieve multitasking.
						But we use multithreading than mulitprocessing because threads share a common memory area. They don’t allocate separate 
						memory area so save memory, and context-switching between the threads takes less time than processes.
						
						Multithreading is mostly used in games, animation etc.
						

						Multitasking is a process of executing multiple tasks simultaneously. We use multitasking to utilize the CPU. Multitasking can be achieved by two ways:

								A. Process-based Multitasking(Multiprocessing)
								B. Thread-based Multitasking(Multithreading)
								
						1)Process-based Multitasking (Multiprocessing)

								Each process have its own address in memory i.e. each process allocates separate memory area.
								Process is heavyweight.
								Cost of communication between the process is high.
								Switching from one process to another require some time for saving and loading registers, memory maps, updating lists etc.
								
						2)Thread-based Multitasking (Multithreading)
								Threads share the same address space.
								Thread is lightweight.
								Cost of communication between the thread is low.
								Note:At least one process is required for each thread.	
                       
					   <thread-life-cycle>
					   
								1. New

								2. Runnable(Ready)

								3. Running

								4. Non-Runnable (Blocked, Sleeping, Waiting)

								5. Terminated(Dead)
													   
					    </thread-life-cycle>
						
						<thread_cons_method>
						
							 Commonly used Constructors of Thread class:

									Thread()
									Thread(String name)
									Thread(Runnable r)
									Thread(Runnable r,String name)
									
							Commonly used methods of Thread class:

									public void run(): is used to perform action for a thread.
									public void start(): starts the execution of the thread.JVM calls the run() method on the thread.
									public void sleep(long miliseconds): Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds.
									public void join(): waits for a thread to die.
									public void join(long miliseconds): waits for a thread to die for the specified miliseconds.
									public int getPriority(): returns the priority of the thread.
									public int setPriority(int priority): changes the priority of the thread.
									public String getName(): returns the name of the thread.
									public void setName(String name): changes the name of the thread.
									public Thread currentThread(): returns the reference of currently executing thread.
									public int getId(): returns the id of the thread.
									public Thread.State getState(): returns the state of the thread.
									public boolean isAlive(): tests if the thread is alive.
									public void yield(): causes the currently executing thread object to temporarily pause and allow other threads to execute.
									public void suspend(): is used to suspend the thread(depricated).
									public void resume(): is used to resume the suspended thread(depricated).
									public void stop(): is used to stop the thread(depricated).
									public boolean isDaemon(): tests if the thread is a daemon thread.
									public void setDaemon(boolean b): marks the thread as daemon or user thread.
									public void interrupt(): interrupts the thread.
									public boolean isInterrupted(): tests if the thread has been interrupted.
									public static boolean interrupted(): tests if the current thread has been interrupted.
						
						</thread_cons_method>
						
						>>A Thread cannot be started twice. If you try to do so, IllegalThreadStateException will be thrown
						
						>>sleep() method
						       ------effectively “pauses” the current thread for a given period of time. and will start from runnable state.
						       -----if running thread get sleep then thread schedullar will pick another thread. 
						
						
						>>join() method
						          -->Join method join the next thread at the end of the current thread.
								  -->means join me after my execution.
								  -->After current thread stops execution then next thread executes.
								  >>it is basically telling thread schedular that "start/join your others thread scheduling process after my/this thread execution"  . 
								     if thread t1/t2/t3  and t1.start() t2.start() t3.start() and t1.join() means t1 will be executed completelly then only t2 and t3 will
								      start execution.;
								  
								  >>In other words, it causes the currently running threads to stop executing until the thread it joins with completes its task.
						
								
								
						<thread-priority>
						
									public static int MIN_PRIORITY  1
									public static int NORM_PRIORITY  5
									public static int MAX_PRIORITY   10
						           
								   
								    In Java runtime system, preemptive scheduling algorithm is applied. If at the execution time a thread with a
									higher priority and all other threads are runnable then the runtime system chooses the new higher priority thread for execution. 
									On the other hand, if two threads of the same priority are waiting to be executed by the CPU then the round-robin algorithm is 
									applied in which the scheduler chooses one of them to run according to their round of time-slice.
						            
									<preemptive-scheduling-algorithm>
									
												Preemptive scheduling ? If the new thread has a higher priority then current running thread leaves the 
												runnable state and higher priority thread enter to the runnable state.
                                    
									</preemptive-scheduling-algorithm>
									
									<round-robin>
									
												Time-Sliced (Round-Robin) Scheduling ? A running thread is allowed to be execute for the fixed time, 
												after completion the time, current thread indicates to the another thread to enter it in the runnable state.
									
									</round-robin>
									
									>>depends on the OS. JVM can not guaranteed about the scheduling of threads.

						</thread-priority>
						
						<daemon-thread>
						
					         	Daemon threads are like a service providers for other threads or objects running in the same process as the daemon thread. 
								Daemon threads are used for background supporting tasks and are only needed while normal threads are executing.
								
								Its life depends on user threads.
								It is a low priority thread.
								User thread is generally meant to run our program code. JVM doesn’t terminate unless all the user thread terminate.
						         
								 If you want to make a user thread as Daemon, it must not be started otherwise it will throw IllegalThreadStateException.
						         
								   >>   public void setDaemon(boolean status)
								   >>   public boolean isDaemon()
								 
						</daemon-thread>
						
						<threadpool>
						
						        Java Thread pool represents a group of worker threads that are waiting for the job and reuse many times.

								In case of thread pool, a group of fixed size threads are created. A thread from the thread pool is pulled out and assigned a 
								job by the
								service provider. After completion of the job, thread is contained in the thread pool again.
						
						        >> Better performance It saves time because there is no need to create new thread.
								
								>> ExecutorService executor = Executors.newFixedThreadPool(5);
								        Runnable worker = new WorkerThread("" + i);  
										executor.execute(worker);//calling execute method of ExecutorService  
										executor.shutdown();  
								
						
						
						</threadpool>
						
						<threadGroup>
						
										Java provides a convenient way to group multiple threads in a single object. In such way, we can suspend, resume or 
										interrupt group
										of threads by a single method call.
										
										>>ThreadGroup(String name)
										>>ThreadGroup(ThreadGroup parent, String name)
										
										1)	int activeCount()	          returns no. of threads running in current group.
										2)	int activeGroupCount()	      returns a no. of active group in this thread group.
										3)	void destroy()	              destroys this thread group and all its sub groups.
										4)	String getName()	          returns the name of this group.
										5)	ThreadGroup getParent()	      returns the parent of this group.
										6)	void interrupt()	          interrupts all threads of this group.
										7)	void list()                   prints information of this group to standard console.
										
										>>ThreadGroup tg1 = new ThreadGroup("Group A");   
											Thread t1 = new Thread(tg1,new MyRunnable(),"one");     
											Thread t2 = new Thread(tg1,new MyRunnable(),"two");     
											Thread t3 = new Thread(tg1,new MyRunnable(),"three");
											
									   >> Now we can interrupt all threads by a single line of code only.
                                              Thread.currentThread().getThreadGroup().interrupt();  
						</threadGroup>  
						
						<shut_down_hook>
						
									The shutdown hook can be used to perform cleanup resource or save the state when JVM shuts down normally or abruptly. 
									Performing clean resource means closing log file, sending some alerts or something else. So if you want to execute some
									code before JVM shuts down, use shutdown hook.
									
									user presses ctrl+c on the command prompt
										System.exit(int) method is invoked
										user logoff
										user shutdown etc.
										
								    public void addShutdownHook(Thread hook){} 

									>>
											Runtime r=Runtime.getRuntime();  
											r.addShutdownHook(new MyThread()); 

											class MyThread extends Thread{  
												public void run(){  
													System.out.println("shut down hook task completed..");  
												}  
											} 

									>> Shutdown Hooks may not be executed in some cases!
                                             First thing to keep in mind is that it is not guaranteed that shutdown hooks will always run. 
											 If the JVM crashes due to some internal error, then it might crash down without having a chance 
											 to execute a single instruction. Also, if the O/S gives a SIGKILL 		
											 
											 
									>> Once started, Shutdown Hooks can be forcibly stopped before completion.
									
									        it is possible to be terminated before it completes, in cases such as operating system shutdowns. 
											In this type of cases, the O/S waits for a process to terminate for a specified amount of time once 
											the SIGTERM is given. If the process does not terminate within this time limit, then the O/S terminates 
											the process forcibly by issuing a SIGTERM (or the counterparts in Windows). So it is possible that 
											this happens when the shutdown hook is half-way through its execution.
											
											
                                            it is advised to make sure that the Shutdown Hooks are written cautiously, ensuring that they finish quickly, 
											and do not cause situations such as deadlocks. Also, the JavaDoc [1] specifically mentions that one should not
											perform long calculations or wait for User I/O operations in a shutdown hook.

									
									>> We can have more than one Shutdown Hooks, but their execution order is not guaranteed.
									
                                    >> We cannot register / unregister Shutdown Hooks with in Shutdown Hooks
                                       Once the shutdown sequence is initiated by the JVM, it is not allowed to add more or remove any existing shutdown hooks.
									   If this is attempted, the JVM throws IllegalStateException.

											
									>>The shutdown sequence can be stopped by invoking the halt(int) method of Runtime class.	
									
						</shut_down_hook>
						
						<runtime>
						
									Java Runtime class is used to interact with java runtime environment. Java Runtime class provides methods to execute a process, invoke GC,
									get total and free memory etc. There is only one instance of java.lang.Runtime class is available for one java application.

										The Runtime.getRuntime() method returns the singleton instance of Runtime class.
										
										1)	public static Runtime getRuntime()	returns the instance of Runtime class.
										2)	public void exit(int status)	terminates the current virtual machine.
										3)	public void addShutdownHook(Thread hook)	registers new hook thread.
										4)	public Process exec(String command)throws IOException	executes given command in a separate process.
										5)	public int availableProcessors()	returns no. of available processors.
										6)	public long freeMemory()	returns amount of free memory in JVM.
										7)	public long totalMemory()	returns amount of total memory in JVM.
										
										Runtime.getRuntime().exec("notepad");//will open a new notepad  
							
						</runtime>
						
						<deadlock>
						
						
						
						</deadlock>
						
						<Synchronization>
						
						     Synchronization is the capability of control the access of multiple threads to any shared resource. 
							 Synchronization is better in case we want only one thread can access the shared resource at a time.
							 
							 To prevent thread interference.
                             To prevent consistency problem.
							 
							 
							 Types of Synchronization:
												There are two types of synchronization

												Process Synchronization
												Thread Synchronization
												
												Here, we will discuss only thread synchronization. 
												Thread Synchronization:
												There are two types of thread synchronization mutual exclusive and inter-thread communication.

												Mutual Exclusive
												   Synchronized method.
												   Synchronized block.
												   static synchronization.
												Cooperation (Inter-thread communication)-WAIT/NOTIFY/NOTIFYALL
												
												<MutualExclusive>
														
														--occurance of one thing should not affect other things
														
														Mutual Exclusive helps keep threads from interfering with one another while sharing data. 
														This can be done by three ways in java:

															by synchronized method
															by synchronized block
															by static synchronization
														
												
												</MutualExclusive>
												
												
												So when a thread is executing a synchronized static method, it also blocks access to all other synchronized
												static methods.
												The synchronized non-static methods are still executable by other threads. It’s because synchronized static
												methods and
												synchronized non-static methods work on different locks: class lock and instance lock.
												
												In other words, a synchronized static method and a non-static synchronized method will not block each other.
												They can run at the same time.
												
												
												
												4. Explicit(state everything noo room for confusion) Locking vs. Intrinsic(natural) Locking
														So far I have explained to you the work of two synchronization mechanism in Java:
														Explicit locking using Lock and Condition objects.
														Intrinsic locking using the synchronized keyword.
														Now the question is: when to use which? When to use Lock and when to use synchronized?
														Here are some guidelines that help you make your decision:
														Consider using the synchronized keyword if you want to block concurrent access to instance methods
														(non-static synchronized methods) or static methods (static synchronized methods).
														Consider using explicit Lock and Condition objects if you want to have greater control over the 
														synchronization process:
														Use more than one Condition objects associate with a Lock.
														Specify a timeout while a thread is waiting. This means the thread can wake up itself after a 
														specified timeout expires.
														Remember that using synchronized keyword is easier and less error-prone then using explicit lock.
														Using explicit lock gives you more control but you have to put more effort.
														
											>> static synchronization will lock all class level static members/except non-static.
											>> if a class contains static and non static sysnchronized method then both can run concurrently 
											      so its developer's responsiblility to design code accodingly and do not use same members for in both method.
												  
											>> Static synchronized methods synchronize on the class object. If one thread is executing a static synchronized
											method, 
											all other threads trying to execute any static synchronized methods will be blocked.

												Non-static synchronized methods synchronize on this ie the instance of the class. If one thread is executing a
												synchronized method, all other threads trying to execute any synchronized methods will be blocked.
						
						</Synchronization>
						
						<inter_thread_comm>
						
						        wait()---release lock
								notify()
								notifyAll()
								sleep()---dont release lock
								
								  -->wait() tells calling thread to give up monitor and go to sleep until some other thread enters the same monitor and call notify. 
								  Causes current thread to release the lock and wait until either another thread invokes the notify() method or the notifyAll() method
								  for this object, or a specified amount of time has elapsed.
								  >>.called from synchronized block
								  
								  
								  >> notify() must be called from synchronized and this will only inform to others thread but after fully completion of current thread...
								  this will not stop/pause execution of current thread like wait() does.
								  so here programmer must have logical binding /call responsibility of wait()/notify().
								  >>after notify control will get back to next to wait()
								  
								  >>interrupt() running thread can be stop//if interrupt() method called on sleeping or waiting thread then exception will throw... 
								  InterruptedException
								  
								  >>yield() method pauses the currently executing thread temporarily for giving a chance to the remaining waiting threads of 
								  the same priority to execute. If there is no waiting thread or all the waiting threads have a lower priority then the same 
								  thread will continue its execution. The yielded thread when it will get the chance for execution is decided by the thread scheduler 
								  whose behavior is vendor dependent. Yield method doesn’t guarantee that current thread will pause or stop but it guarantee 
								  that CPU will be relinquish by current Thread as a result of call to Thread.yield() method in java.
						
						</inter_thread_comm>
						
						
						
		   </multithreading>
		  
            <IO>
			    Stream:
				       A stream is a sequence of data.In Java a stream is composed of bytes. It's called a stream because it is like a stream of water that continues to flow.
			 
			     Outputstream:
				       >>write(int);
					   >>write([]);
					   >>flush();
					   >>close();
					   
					   ---->FileOutPutStream
					   ---->ByteArrayOutputStream
					   ---->FilterOutputStream
					                     --->DataOutputStream
										 --->BufferedOutputStream
										 --->PrintStream
					   --->PipedOutputStream
					   --->ObjectOutputStream
					   
					   
					   
					   
				 InputStream:
                        >>	read()---read and returns -1 at end of file;
                        >>	available()--number of byte that can be read from stream;
                        >> close()						
			 
			</IO>
            
			<serilization>
			     writing state of an object into a byte stream
				 
				 java.io.Serializable interface
				 If there is any static data member in a class, it will not be serialized because static is the part of class not object.
				 
				 If a class has a reference of another class, all the references must be Serializable otherwise serialization process will not be performed. 
				 In such case, NotSerializableException is thrown at runtime.
				 
				 <Transient>
                        living for short period ot time
                    If you don't want to serialize any data member of a class, you can mark it as transient.
			   
			   </Transient>
			
			</serilization>
			
			<networking>
			    
				<socket_programming/>
				<datagram/>
				
				<URL>
				
				      URL is an acronym for Uniform Resource Locator.
					  
					    public String getProtocol()	      it returns the protocol of the URL.
						public String getHost()	           it returns the host name of the URL.
						public String getPort()	           it returns the Port Number of the URL.
						public String getFile()	            it returns the file name of the URL.
						public URLConnection openConnection()	it returns the instance of URLConnection i.e. associated with this URL.
					  
					  ---URLConnection 
					  ---HttpURLConnection
					  ---InetAddress --InetAddress ip=InetAddress.getByName("www.javatpoint.com");  
					  
				</URL>
			
			
			
			</networking>
		     
			 <reflection>
			 
			         Java Reflection is a process of examining or modifying the run time behavior of a class at run time.

                     The java.lang.Class class provides many methods that can be used to get metadata, examine and change the run time behavior of a class.

                     The java.lang and java.lang.reflect packages provide classes for java reflection.
					 
					 it is also used to call private method of class  by using ---getdeclaredMethod()/setAccesible/invoke
			 
			 
			 </reflection>
			 
			 <Date>
			 
			     java 8 java.time
				 
				     DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");  
                     LocalDateTime now = LocalDateTime.now();  
                      System.out.println(dtf.format(now)); 
			 </Date>
			 
			 <conversion>
			 
			 </conversion>
			 
		  <Collection>
		        
				    <one>
								 >>>java.util 
								 
								 --->Iterable---interface
										--->Collection  interface
												 --->List    interface
														   --->ArrayList     class
														   --->LinkedList    class  implements DeQue---for manupulation
														   --->Vector        class
																 --->Stack         class
												 --->Queue   interface
												 
															---->PriorityQueue  class
															---->Deque    interface
																	  --->ArrayDeque class
												 --->Set     interface
												   
															 --->HashSet           class------no duplicate
																  --->LinkedHashSet     class---no duplicate---allow null--for manupulation
															 --->SortedSet         interface
																	  ---navigableSet  interface
																		 ---TreeSet   class
																		 
								-------
								Map  interface
								  Map.Entry Interface
									   ----Object getKey()
									  ----Object getValue()
								-->>AbstractMap class		  
								   ---->HashMap  class   ---unique values//one null key and multiple null values /no order/hashtable
										--->LinkedHashMap  class  --- same as hash map---maintain insertion order
								--SortedMap---interface
								   -->SortedMap  interface
									   --->navigableMap
											 --TreeMap class     ----same as hash map---no null key and multiple null values--maintain aascendig order
									
									
							  ==---
							  HashTable  class  extend Dictionary class implements MAp
								   -----no null key and value
								   -----synchronized
								   
							  ===
								EnumSet			of/allOf/range/noneof
								EnumMap   EnumMap Days, String map = new EnumMap Days, String(Days.class);  
										   map.put(Days.Monday, "1");  
										   map.put(Days.Tuesday, "2");  
										   map.put(Days.Wednesday, "3");  
										   map.put(Days.Thursday, "4");  
										   // print the map  
										   for(Map.Entry m:map.entrySet()){    
											   System.out.println(m.getKey()+" "+m.getValue());    
											  }   				
															 
						  
							   ==Collections  class-- utill
		            </one>
					
				 <comparable>
			  
						  interface
						  java.lang package
						  objects2.compareTo(Objecs 1)
			  
				 </comparable>
		  		  
			  <comparator>
			  
					   interface
								 >> java.util package and contains 2 methods compare(Object obj1,Object obj2) and equals(Object element).
								   public int compare(Object o1,Object o2){  
									Student s1=(Student)o1;  
									Student s2=(Student)o2;  
									  
									return s1.name.compareTo(s2.name);  
									}  
								 >>Collections.sort(al,new NameComparator());  
					  
			  
			  
			  </comparator>
		   
          </Collection>		
		  
		  <JDBC>
		  
		  
		  ACID-
		  atomocity--all or none
		  consistency--one state to anothe state
		  isolation-----isolation from one transaction to another transaction
		  Durability---once commited will remain commited even after error/powerloss.
		  
		  
		  
		  
		  
		  </JDBC>
		  
		  <internationlization>
		  
				  >>Fields of Locale class

						There are fields of Locale class:

						public static final Locale ENGLISH
						public static final Locale FRENCH
						
						
				  >>Constructors of Locale class

						There are three constructors of Locale class.They are as follows:

						Locale(String language)
						Locale(String language, String country)
						Locale(String language, String country, String variant)
						
						
				  Commonly used methods of Locale class
				  -------------->

				  >>There are given commonly used methods of Locale class.

					public static Locale getDefault() it returns the instance of current Locale
					public static Locale[] getAvailableLocales() it returns an array of available locales.
					public String getDisplayCountry() it returns the country name of this locale object.
					public String getDisplayLanguage() it returns the language name of this locale object.
					public String getDisplayVariant() it returns the variant code for this locale object.
					public String getISO3Country() it returns the three letter abbreviation for the current locale's country.
					public String getISO3Language() it returns the three letter abbreviation for the current locale's language.
					
					
					
				  >>ResourceBundle class in Java

						The ResourceBundle class is used to internationalize the messages. In other words, we can say that it provides a mechanism to globalize the messages.

						The hardcoded message is not considered good in terms of programming, because it differs from one country to another. So we use the ResourceBundle class to globalize the massages. The ResourceBundle class loads these informations from the properties file that contains the messages.

						Conventionally, the name of the properties file should be filename_languagecode_country code for example MyMessage_en_US.properties.
						
				  >> Commonly used methods of ResourceBundle class

						There are many methods in the ResourceBundle class. Let's see the commonly used methods of the ResourceBundle class.

						public static ResourceBundle getBundle(String basename) returns the instance of the ResourceBundle class for the default locale.
						public static ResourceBundle getBundle(String basename, Locale locale) returns the instance of the ResourceBundle class for the specified locale.
						public String getString(String key) returns the value for the corresponding key from this resource bundle.
						
		           Example of ResourceBundle class

					Let's see the simple example of ResourceBundle class. In this example, we are creating three files:

					MessageBundle_en_US.properties file contains the localize message for US country.
					MessageBundle_in_ID.properties file contains the localize message for Indonaisa country.
					
					
					ResourceBundle bundle = ResourceBundle.getBundle("MessageBundle", Locale.US);  
					  System.out.println("Message in "+Locale.US +":"+bundle.getString("greeting"));  
					  
					  //changing the default locale to indonasian   
					  Locale.setDefault(new Locale("in", "ID"));  
					  bundle = ResourceBundle.getBundle("MessageBundle");  
					  System.out.println("Message in "+Locale.getDefault()+":"+bundle.getString("greeting"));
					  
					  <date>
					  
					      We can internationalize the date by using the getDateInstance() method of the DateFormat class. It receives the locale object as a parameter and returns the instance of the DateFormat class.
						  
						  Commonly used methods of DateFormat class for internationalizing date

								There are many methods of the DateFormat class. Let's see the two methods of the DateFormat class for internationalizing the dates.

								public static DateFormat getDateInstance(int style, Locale locale) returns the instance of the DateFormat class for the specified style and locale. The style can be DEFAULT, SHORT, LONG etc.
								public String format(Date date) returns the formatted and localized date as a string.
					  
					  
									  static void printDate(Locale locale){  
										DateFormat formatter=DateFormat.getDateInstance(DateFormat.DEFAULT,locale);  
										Date currentDate=new Date();  
										String date=formatter.format(currentDate);  
										System.out.println(date+" "+locale);  
										}  
										  
										public static void main(String[] args) {  
											printDate(Locale.UK);  
											printDate(Locale.US);  
											printDate(Locale.FRANCE);  
										}  
											  
					  </date>
					  
					  <time>
					  
					      The getTimeInstance() method of the DateFormat class returns the instance of the DateFormat class for the specified style and locale.
					  
					  </time>
					  
					  <number>
					         
							  public static NumberFormat getNumberInstance(Locale locale)  
                              public static NumberFormat getInstance(Locale locale)//same as above 

					 </number>
					 
					 <currency>
					 
					        The NumberFormat class provides methods to format the currency according to the locale. 
							The getCurrencyInstance() method of the NumberFormat class returns the instance of the NumberFormat class.

							The syntax of the getCurrencyInstance() method is given below:

							public static NumberFormat getCurrencyInstance(Locale locale).
							
					 </currency>
					 
		   </internationlization>

		  <RMI>
		  
		  </RMI>
 
 </Basic>
  
  <java_latest_features>
       
	   <java_8>
	       
		   <default_static_method_in_intterface>
		   
		         Before Java 8, interfaces could have only abstract methods. The implementation of these methods has to be provided in a separate class.
				 So, if a new method is to be added in an interface then its implementation code has to be provided in the class implementing the same interface. 
				 To overcome this issue, Java 8 has introduced the concept of default methods which allow the interfaces to have methods with implementation without 
				 affecting the classes that implement the interface.
				 
				 Default methods are also known as defender methods or virtual extension methods.
		   
		            java 8 have static and default method in interface with body.
		   
						   default void log(String str)
						   {
						            System.out.println("I2 logging::"+str);
						   }
										 
										 
						static boolean isNull(String str) 
						{
							  System.out.println("Interface Null Check");

							  return str == null ? true : "".equals(str) ? true : false;
						}
						   
		   </default_static_method_in_intterface>
	       
		   <Functional_Interface>
		   
                 An Interface that contains exactly one abstract method is known as functional interface. It can have any number of default, static methods but can 
				 contain only one abstract method. It can also declare methods of object class.

                 Functional Interface is also known as Single Abstract Method Interfaces or SAM Interfaces. It is a new feature in Java, which helps
				 to achieve functional  programming approach.
				 
				 Lambda expression provides implementation of functional interface. An interface which has only one abstract method is called functional interface. 
				 Java provides an anotation @FunctionalInterface, which is used to declare an interface as functional interface.
				 
				 @FunctionalInterface  
						interface sayable{  
							void say(String msg);  
						}  
						public class FunctionalInterfaceExample implements sayable{  
							public void say(String msg){  
								System.out.println(msg);  
							}  
							public static void main(String[] args) {  
								FunctionalInterfaceExample fie = new FunctionalInterfaceExample();  
								fie.say("Hello there");  
							}  
						}  
				  
				  
				  >>Invalid Functional Interface
                         A functional interface can extends another interface only when it does not have any abstract method.
				 
				     
            
			</Functional_Interface>
			
			<Default_STATIC_Methods>
			
			   >> Java provides a facility to create default methods inside the interface. Methods which are defined inside the interface and tagged with default 
			      are known as default methods. These methods are non-abstract methods.
				
               >> AFTER ADDING default/static/ method and using functional interface(only one abstract method) concept no need of abstract class 				
			    
				interface Sayable
				{  
					// Default method   
					default void say(){  
						System.out.println("Hello, this is default method");  
					}  
					// Abstract method  
					void sayMore(String msg);  
				}
                  
			    interface Sayable
					{    
						// default method    
						default void say(){    
							System.out.println("Hello, this is default method");    
						}    
						// Abstract method    
						void sayMore(String msg);    
						// static method    
						static void sayLouder(String msg){    
							System.out.println(msg);    
						}    
					}    				  
			
			
			</Default_STATIC_Methods>
			
			<forEACH>
			  
			  
					 Java provides a new method forEach() to iterate the elements. It is defined in Iterable and Stream interface. It is a default method defined in the Iterable interface. Collection classes which extends 
					 Iterable interface can use forEach loop to iterate elements.
					 This method takes a single parameter which is a functional interface. So, you can pass lambda expression as an argument.
					 
					 default void forEach(Consumer super T action)  
					 
					 List String gamesList = new ArrayList String();  
						gamesList.add("Football");  
						gamesList.add("Cricket");  
						gamesList.add("Chess");  
						gamesList.add("Hocky");  
						System.out.println("------------Iterating by passing lambda expression--------------");  
						gamesList.forEach(games -> System.out.println(games));  
					  
					   List String gamesList = new ArrayList String();  
							gamesList.add("Football");  
							gamesList.add("Cricket");  
							gamesList.add("Chess");  
							gamesList.add("Hocky");  
							System.out.println("------------Iterating by passing method reference---------------");  
							gamesList.stream().forEach((values) -> 
										   {
												System.out.println("list values..>"+values);
										   });  

				
			
			</forEACH>
			
			<forEachOrdered>
			  
			      Along with forEach() method, Java provides one more method forEachOrdered(). It is used to iterate elements in the order specified by the stream.
				  
				  List String gamesList = new ArrayList String ();  
					gamesList.add("Football");  
					gamesList.add("Cricket");  
					gamesList.add("Chess");  
					gamesList.add("Hocky");  
					System.out.println("------------Iterating by passing lambda expression---------------");  
					gamesList.stream().forEachOrdered(games -> System.out.println(games));  
					System.out.println("------------Iterating by passing method reference---------------");  
					gamesList.stream().forEachOrdered(System.out::println); 
						
			
			
			</forEachOrdered>

		   
		   
		   <lambda>
		   
		              Lambda expression is a new and important feature of Java which was included in Java SE 8. It provides a clear and concise way to represent one method
					  interface using an expression. It is very useful in collection library. It helps to iterate, filter and extract data from collection.

                      The Lambda expression is used to provide the implementation of an interface which has functional interface. It saves a lot of code. In case of lambda 
					  expression, we don't need to define the method again for providing the implementation. Here, we just write the implementation code.

                      Java lambda expression is treated as a function, so compiler does not create .class file.
					  
					  (argument-list) -> {body}  
					  
					  
					  @FunctionalInterface  //It is optional  
						interface Drawable{  
							public void draw();  
						}  
						  
						public class LambdaExpressionExample2 {  
							public static void main(String[] args) {  
								int width=10;  
								  
								//with lambda  
								Drawable d2=()->{  
									System.out.println("Drawing "+width);  
								};  
								d2.draw();  
							}  
						}  

						
						
					 // Lambda expression without return keyword.  
						Addable ad1=(a,b)->(a+b);  
						System.out.println(ad1.add(10,20));  
						  
						// Lambda expression with return keyword.    
						Addable ad2=(int a,int b)->{  
											return (a+b);   
											};  
                     
					 // using lambda to filter data  
							Stream<!Product> filtered_data = list.stream().filter(p -> p.price > 20000); 					 
						
		   
		   </lambda>
		   
		   <stream>
		   
		        >> Java provides a new additional package in Java 8 called java.util.stream. This package consists of classes, interfaces and enum to allows functional-style operations on the elements. You can use stream by importing java.util.stream package.

					Stream provides following features:

					Stream does not store elements. It simply conveys elements from a source such as a data structure, an array, or an I/O channel, through a pipeline of computational operations.
					Stream is functional in nature. Operations performed on a stream does not modify it's source. For example, filtering a Stream obtained from a collection produces a new Stream without the filtered elements, rather than removing elements from the source collection.
					Stream is lazy and evaluates code only when required.
					The elements of a stream are only visited once during the life of a stream. Like an Iterator, a new stream must be generated to revisit the same elements of the source.
		          
				>> You can use stream to filter, collect, print, and convert from one data structure to other etc. In the following examples, we have apply various operations with the help of stream.
				  
								   List<!Product> productsList = new ArrayList<!Product>();  
						 //Adding Products  
						 productsList.add(new Product(1,"HP Laptop",25000f));  
						 productsList.add(new Product(2,"Dell Laptop",30000f));  
						 productsList.add(new Product(3,"Lenevo Laptop",28000f));  
						 productsList.add(new Product(4,"Sony Laptop",28000f));  
						 productsList.add(new Product(5,"Apple Laptop",90000f));  
						 List<!Float> productPriceList2 =productsList.stream()  
													  .filter(p -> p.price > 30000)// filtering data  
													  .map(p->p.price)        // fetching price  
													  .collect(Collectors.toList()); // collecting as list  
						 System.out.println(productPriceList2);  
					
               >>
			      Java Stream Iterating Example
					   You can use stream to iterate any number of times. Stream provides predefined methods to deal with the logic you implement. 
					   In the following example, we are iterating, filtering and passed a limit to fix the iteration.

					   import java.util.stream.*;  
					   public class JavaStreamExample {  
					   public static void main(String[] args){  
							Stream.iterate(1, element->element+1)  
							.filter(element->element%5==0)  
							.limit(5)  
							.forEach(System.out::println);  
						   }  
					   }  
					
				>>  // This is more compact approach for filtering data  
                           productsList.stream()  
                             .filter(product -> product.price == 30000)  
                             .forEach(product -> System.out.println(product.name)); 	
				  
		   </stream>
		   
	   
	   </java_8>
	   
	   <java_9>
	      
		  <try_with_resource>
		            
					FileOutputStream fileStream=new FileOutputStream("javatpoint.txt");  
						try(fileStream)
						{  
							    String greeting = "Welcome to javaTpoint.";      
								byte b[] = greeting.getBytes();       
								fileStream.write(b);      
								System.out.println("File written");   
								
						}catch(Exception e) {  
							System.out.println(e);  
						}         
		  
		  
		  </try_with_resource>
	   
	   
	   
	       
	   </java_9>
  
  
  </java_latest_features>
  
</CoreJava> 

<java_security>

</java_security>

<maven>
   
   <note>
           1. add maven to eclipse or use latest eclipse or sts for maven project.
		   2. add settings.xml for local repository
		   3. to add library directly from local to local repository use following
		        mvn install:install-file -Dfile=/Users/athanka/git/MyProject/repo/log4j-rolling-appender.jar -DgroupId=uk.org.simonsite -DartifactId=log4j-rolling-appender -Dversion=20150607-2059 -Dpackaging=jar
		   4. edit pom.xml for different library , add jar artifactid/groupid/version  etc....

             e.g	<dependency>
			 
						<groupId>org.hibernate</groupId>
						<artifactId>hibernate-core</artifactId>
						<version>5.2.1.Final</version>
						
					</dependency>	  

					<dependency>
								<groupId>log4j</groupId>
								<artifactId>log4j</artifactId>
								<version>1.2.12</version>
					</dependency>	

					 <dependency>
					 
							   <groupId>org.glassfish.jersey.core</groupId>
							   <artifactId>jersey-client</artifactId>
							   <version>2.26</version>

					 </dependency>

					
          >> Maven – POM File
		         >> POM (Project Object Model) is an XML file that contains information about the project and configuration details used by Maven 
				    to build the project i.e. sourcecode location, project dependencies etc. This file must be named as pom.xml and placed
					under root folder of project.
		  
         >> Maven – Settings File
                 >> Maven settings.xml file contains configurations that are not specific to a project, but are global in nature.
				    It also contains information that is not meant to be distributed (e.g. passwords).	
					
					
					
					Location of Maven Settings File
							>> Maven can have two settings files working at a time:

							   1. The Maven installation directory: $M2_HOME/conf/settings.xml [global settings]
							   2. The user’s home directory: ${user.home}/.m2/settings.xml [user settings]
							   
							Both files are optional. If both files are present, the values in the user home settings file overrides the values 
							from global settings file.
							
							
							Maven Default setting.xml
							A default maven setting.xml look like this:

							<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
								  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
								  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
													  http://maven.apache.org/xsd/settings-1.0.0.xsd">
								  <localRepository/>
								  <interactiveMode/>
								  <usePluginRegistry/>
								  <offline/>
								  <pluginGroups/>
								  <servers/>
								  <mirrors/>
								  <proxies/>
								  <profiles/>
								  <activeProfiles/>
							</settings>
							
							
					 >> A brief description of the elements is given in below table:

						ELEMENT NAME	                   DESCRIPTION
						1. localRepository             	    Maven stores copies of plug-ins and dependencies locally in the
  						                                    C:\Users\ your_user_name>\.m2\repository folder. This element can be used to change 
															the path of the local repository.
															
						2. interactiveMode	                As the name suggests, when this value is set to true, the default value, Maven interacts
															with the user for input.
															
						3. usePluginRegistry	            It decide that if Maven should use the ${user.home}/.m2/plugin-registry.xml file to manage
															plugin versions. Its default value is false.
															
						4. offline	                        When set to true, this configuration instructs Maven to operate in an offline mode. 
															The default is false.
															
						5. pluginGroups	                    It contains a list of pluginGroup elements, each contains a groupId. The list is searched
															when a plugin is used and the groupId is not provided in the command line. This list
															automatically contains org.apache.maven.plugins and org.codehaus.mojo.
															
						6. servers	                        Maven can interact with a variety of servers, such as Apache Subversion (SVN) servers,
															build servers, and remote repository servers. This element allows you to specify security 
															credentials, such as the username and password, which you need to connect to those servers.
															
						7. mirrors	                        As the name suggests, mirrors allow you to specify alternate locations for your repositories.
						
						8. proxies	                        proxies contains the HTTP proxy information needed to connect to the Internet.
						
						9. profiles	                        profiles allow you to group certain configuration elements, such as repositories 
															and pluginRepositories.
															
						10. activeProfile	                The activeProfile allows you to specify a default profile to be active for Maven to use.		

         >> [Solved] Maven Shade Plugin – A required class was missing org/apache/commons/io/IOUtils
                 >> You may get this error when you have incompatible version of maven and it’s maven shade plugin. Fixing version number
				    mismatch will solve the issue.	

                       <phase>phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>					
		
		
		>> External Dependency
                Some times, you will have to refer jar files which are not in maven repository (neiter local, central or remote repository). 
				You can use these jars by placing them in project’s lib folder and configure the external dependency like this:

				<dependency>
				  <groupId>extDependency</groupId>
				  <artifactId>extDependency</artifactId>
				  <scope>system</scope>
				  <version>1.0</version>
				  <systemPath>${basedir}\war\WEB-INF\lib\extDependency.jar</systemPath>
				</dependency>


						The groupId and artifactId are both set to the name of the dependency.
						The scope element value is set to system.
						The systemPath element refer to the location of the JAR file.
						
						
		>> Maven Dependency Exclusion
                    >> Apart from version mismatch issue caused with transitive dependency, there can be version mismatch between project artifacts 
					   and artifacts from the platform of deployment, such as Tomcat or another server.

                    >> To resolve such version mismatch issues, maven provides exclusion> tag, in order to break the transitive dependency.

                    >> For example, when you have JUnit 4.12 in classpath and including DBUnit dependency, then you will need to remove 
					   JUnit 3.8.2 dependency. It can be done with exclusion tag.

						<dependency>
							<groupId>junit</groupId>
							<artifactId>junit</artifactId>
							<version>${junit.version}</version>
							<scope>test</scope>
						</dependency>

						<dependency>
							<groupId>org.dbunit</groupId>
							<artifactId>dbunit</artifactId>
							<version>${dbunit.version}</version>
							<scope>test</scope>
							<exclusions>
								<!--Exclude transitive dependency to JUnit-3.8.2 -->
								<exclusion>
									<artifactId>junit</artifactId>
									<groupId>junit</groupId>
								 </exclusion>
							</exclusions>
						</dependency>	
        
		
		>> Artifact Version Ranges
                  While including a dependency, you are free to specify a range of versions for any artifact. To give version range, 
				  you can use below symbols:

					Parenthesis signs ( and ) hint an including range
					Brackets signs [ and ] hint an excluding range
					Commas separate subsets
					
					>> Version range examples
							Let’s few examples to underdtand better about specifying version range.

							RANGE	MEANING
							1.2	Version equals to 1.2 or is starting with 1.2
							(,1.2]	Any version less than 1.2. Version 1.2 included. x less= 1.2
							(,1.2)	Any version less than 1.2. Version 1.2 excluded. x LES 1.2
							[1.2]	Only version 1.2 only.x == 1.0
							[1.2,)	Any version greater than 1.2. Version 1.2 included. x gr= 1.2
							[1.2,)	Any version greater than 1.2. Version 1.2 included. x gr= 1.2
							(1.2,)	Any version greater than 1.2. Version 1.2 excluded. x gr 1.2
							(1.2,2.2)	Version between 1.2 and 2.2. Both excluded. 1.0 less x less 2.0
							[1.2,2.2]	Version between 1.2 and 2.2. Both included. 1.2 less= x less= 2.2
							(,1.2],[2.2,)	Version either less that 1.2 or greater than 2.2. Both included. x less= 1.2 or x gr= 2.2

			
   </note>
   
   <MAVEN_SCOPE>
   
   
		>>Maven Compile Scope
				This is maven default scope. Dependencies with compile scope are needed to build, test, and run the project.

				Scope compile is to be required in most of the cases to resolve the import statements into your java classes sourcecode.

				<dependencies>
					<dependency>
						<groupId>log4j</groupId>
						<artifactId>log4j</artifactId>
						<version>1.2.14</version>
						<!-- You can ommit this because it is default -->
						<scope>compile</scope>
					</dependency>
				</dependencies>
   
        >> Maven Provided Scope
                Maven scope provided is used during build and test the project. They are also required to run, but should not exported,
				because the dependency will be provided by the runtime, for instance, by servlet container or application server.

					<dependency>
						<groupId>javax.servlet</groupId>
						<artifactId>servlet-api</artifactId>
						<version>3.0.1</version>
						<scope>provided</scope>
					</dependency>
					
					
		>> Maven Runtime Scope
                Dependencies with maven scope runtime are not needed to build, but are part of the classpath to test and run the project.

							<dependency>
								<groupId>com.thoughtworks.xstream</groupId>
								<artifactId>xstream</artifactId>
								<version>1.4.4</version>
								<scope>runtime</scope>
							 </dependency>			
							 
							 
		>> Maven Test Scope
                   Dependencies with maven scope test are not needed to build and run the project. They are needed to compile and run the unit tests.	
                        
						<dependency>
							<groupId>junit</groupId>
							<artifactId>junit</artifactId>
							<version>4.12</version>
							<scope>test</scope>
						</dependency>

		>> Maven System Scope
                    Dependencies with system are similar to ones with scope provided. The only difference is system dependencies are not retrieved 
					from remote repository. They are present under project’s subdirectory and are referred from there.
					See external dependency for more detail.

						<dependency>
						  <groupId>extDependency</groupId>
						  <artifactId>extDependency</artifactId>
						  <scope>system</scope>
						  <version>1.0</version>
						  <systemPath>${basedir}\war\WEB-INF\lib\extDependency.jar</systemPath>
						</dependency>	

        >> Maven Import Scope
                    import scope is only supported on a dependency of type pom in the dependencyManagement section. It indicates the dependency 
					to be replaced with the effective list of dependencies in the specified POM’s dependencyManagement section.

					<dependencyManagement>
						<dependencies>
							<dependency>
								<groupId>other.pom.group.id</groupId>
								<artifactId>other-pom-artifact-id</artifactId>
								<version>SNAPSHOT</version>
								<scope>import</scope>
								<type>pom</type>
							</dependency>  
						</dependencies>
					</dependencyManagement>
						
   </MAVEN_SCOPE>
   
   <MAVEN_REPOSITORY>
   
        >>Local repository
                   >> Maven local repository reside in the developer’s machine. Whenever you run maven goals which require these dependencies, 
				      maven will download the dependencies from remote servers and store them into developer’s machine.

                   >> By default, Maven create the local repository inside user home directory i.e. C:/Users/superdev/.m2 directory. 
				      You can change the location of the local repository in setting.xml file using localRepository tag.

						<settings>
							<localRepository>
								C:\M2
							</localRepository>
						</settings>
						
                   >>  Having stored the dependencies into local machine has two main benefits. First, multiple projects can access same artifact 
				       so it reduces the storage need. Second, as dependency is downloaded only once, it reduces the network usage as well.
        
		
		
		>> Central repository
                   >> Maven central repository is located at http://repo.maven.apache.org/maven2/. Whenever you run build job, 
				      maven first try to find dependency from local repository. If it is not there, then, by default, maven will trigger 
				     the download from this central repository location.
				   
				   >> To override this default location, you can can make changes to your settings.xml file to use one or more mirrors.
                      You do not need to make any special configuration to allow access the central repository, except network proxy settings 
					  if you are behind any firewall.
					  
					  
		>> Remote repository
                     >> Apart from central repository, you may have needed artifacts deployed on other remote locations. For example, 
					   in your corporate office there may be projects or modules specific to organization only. In this cases, organization
					   can create remote repository and deploy these private artifacts. This remote repository will be accessible only inside organization.

                     >> These maven remote repository work exactly same way as maven’s central repository. Whenever an artifact is needed 
					    from these repositories, it is first downloaded to developer’s local repository and then it is used.

                     >> You can configure a remote repository in the POM file or super POM file in remote repository itself.

							<repositories>
							   <repository>
								   <id>org.source.repo</id>
								   <url>http://maven.orgName.com/maven2/</url>
							   </repository>
							</repositories>			  
   
   </MAVEN_REPOSITORY>
   
   <MAVEN_LOCAL_REPO_SYSTEM_PATH>
   
         Maven Change Local Repo Path in Windows

         Maven is build and dependency management tool as we all know. It downloads required project dependencies to your local system and include them to your 
		 project compilation or run-time as defined. By default maven’s local repository exist on following path :

					C:/Documents and Settings windows username>/.m2/repository
					You can change this location to some other location of your choice. This can be done using below steps.

					1) For existing maven installation
							For existing installation, follow below steps:

							Navigate to path : C:/Documents and Settings/ current username>/.m2
							Open file settings.xml in edit mode in some text editor.
							Open the tag  localRepository>
							Update the desired path in value of this tag.
							Congratulations, You are done.
					2) For new maven installation
							For new installation, follow below steps:

							From the Windows “Start” button on the menu, select the “Run” menu item. Into the dialog box, enter the command “cmd” and press the “Ok” button. This will open a command window with a shell prompt.
							Type cd “C:/Documents and Settings/ windows username>”/
							Type mkdir .m2
							Type cd .m2
							Type notepad settings.xml. This will open a new document in Notepad and show you a warning “Cannot find the settings.xml file. Do you want to create a new file?”. Select “Yes”.
							Enter the following code into the document:  settings> localRepository>D:/mavenrepository /localRepository> /settings> (Give here path of your choice)
							Save the file and close out of notepad.
							Congrates, You are done.
					   
   </MAVEN_LOCAL_REPO_SYSTEM_PATH>
   
   <MAVEN_NETWORK_PROXY_CONFIG>
   
           >> Maven Network Proxy Configuration

                 >> By default, maven uses default network connection running on your local system. But, sometimes you are
				    running your application in your workplace or company. These networks shields their intranet through proxy servers, 
				    so all internet queries made from your system goes through this proxy server.

                 >> Maven by default does not respect them, and to use maven in these restricted areas, you may need to configure
  				    network proxy settings for maven.

          >> Maven Configure Network Proxy
              To setup proxy settings, follow below steps:

					1. Navigate to path : C:/Documents and Settings/ current username>/.m2/
					2. Open file settings.xml in edit mode in some text editor.
					3. Open and update  proxy> tag.
					4. This tag will look like this:

					<proxy>
							<id>optional</id>
							<active>true</active>
							<protocol>http</protocol>
							<username>proxyuser</username>
							<password>proxypass</password>
							<host>proxy.host.net</host>
							<port>80</port>
							<nonproxyhosts>local.net|some.host.com</nonproxyhosts>
					</proxy>
					
          >> Update above fields with your network specific credentials. They must be present in your browser’s connection settings. Use them here.

          >> After above steps, you should be able to use maven behind proxy servers also.
		  
		  
 </MAVEN_NETWORK_PROXY_CONFIG>
 
</maven>

<JUNIT>

     <NOTE>
          
		  >> JUnit is a unit testing framework for the Java programming language. JUnit has been important in the development 
		     of test-driven development, and is one of a family of unit testing frameworks. Its main use is to write repeatable
			 tests for your application code units.
          
		  >> JUnit Maven Dependency
		  
					<dependency>
						<groupId>junit</groupId>
						<artifactId>junit</artifactId>
						<version>4.12</version>
					</dependency> 
					
					
		  >> JUnit Annotations
              JUnit offers following annotations to write tests.

				ANNOTATION	              DESCRIPTION
				@Before	                      The annotated method will be run before each test method in the test class.
				
				@After	                      The annotated method will be run after each test method in the test class.
				
				@BeforeClass	              The annotated method will be run before all test methods in the test class. This method must be static.
				
				@AfterClass	                  The annotated method will be run after all test methods in the test class. This method must be static.
				
				@Test	                      It is used to mark a method as junit test
				
				@Test(timeout=1000)           annotation specifies that method will be failed if it takes longer than 1000 milliseconds (1 second).
				
				@Ignore	                      It is used to disable or ignore a test class or method from test suite.
				
				@FixMethodOrder	              This class allows the user to choose the order of execution of the methods within a test class.
				
				@Rule	                      Annotates fields that reference rules or methods that return a rule.
				
				@ClassRule	                  Annotates static fields that reference rules or methods that return them.
				
				
	    >> Assert class
				The org.junit.Assert class provides methods to assert the program logic.

				Methods of Assert class
				       The common methods of Assert class are as follows:

							void assertEquals(boolean expected,boolean actual): checks that two primitives/objects are equal. It is overloaded.
							void assertTrue(boolean condition): checks that a condition is true.
							void assertFalse(boolean condition): checks that a condition is false.
							void assertNull(Object obj): checks that object is null.
							void assertNotNull(Object obj): checks that object is not null.			
		


        >> Required jar files
                You need to load junit4.jar and hamcrest-core.jar files. 


			 
		>> Writing Tests in JUnit
                In JUnit, test methods are marked with @Test annotation. To run the method, JUnit first constructs a fresh instance 
				of the class then invokes the annotated method. Any exceptions thrown by the test will be reported by JUnit as a failure. 
				If no exceptions are thrown, the test is assumed to have succeeded.


					public class Example {
						@BeforeClass
						public static void setup() {
						}
					 
						@Before
						public void setupThis() {
						}
					 
						@Test
						public void method() {
							org.junit.Assert.assertTrue(new ArrayList().isEmpty());
						}
					 
						@After
						public void tearThis() {
						}
					 
						@AfterClass
						public static void tear() {
						}
					}	


        >>Test Suites
                       Using JUnit test suites, you can run tests spread into multiple test classes. In JUnit, both @RunWith and @Suite 
					   annotations are used to run the suite tests.
							 
							@RunWith(Suite.class)
							 
							@Suite.SuiteClasses({
							   TestJunit1.class,
							   TestJunit2.class
							})
							 
							public class JunitTestSuite {  
							} 
        
		>> Assertions
                        Assertions help in validating the expected output with actual output of a testcase. All the assertions are 
						in the org.junit.Assert class. All assert methods are static, it enable better readable code.


						@Test
						public void method() {
							assertTrue(new ArrayList().isEmpty());
						}
						
						
        >> Assumptions:
                        Assumption indicate the conditions in which a test is meaningful. A failed assumption does not mean the code is broken, 
						but that the test provides no useful information. Assume basically means “don’t run this test if these conditions don’t apply”. 
						The default JUnit runner skips tests with failing assumptions.


							public class Example {
								public class AppTest {
									@Test
									void testOnDev()
									{
										System.setProperty("ENV", "DEV");
										assumeTrue("DEV".equals(System.getProperty("ENV")));
									}
									  
									@Test
									void testOnProd()
									{
										System.setProperty("ENV", "PROD");
										assumeFalse("DEV".equals(System.getProperty("ENV"))); 
									}
								}
							}					

				
     </NOTE>



</JUNIT>

<svn>
    Tortise
	download and install and make repository location. version used 1.7.8;

</svn>

<mail>

     <note>
	       
		   1.download java mail jar "javax,mail-api.1.4.7.jar" and "javax.mal.jar"  add into lib path or add into maven.
		   
		   2. steps
		        <steps>
				    
				    	1. collect information like servername/domain/to/from/cc/message
						2. add to properties like servername/domain/port
						       java.util.Properties props = System.getProperties();
							   props.put("mail.smtp.host", serverName + "." + domainName);
						3. get session from mail server
						        Session session = Session.getDefaultInstance(props, null);
							    session.setDebug(false);
					    4. create MimeMessage	
                                 javax.mail.internet.MimeMessage msg = new javax.mail.internet.MimeMessage(session);
					    5. set all mail details like to/from.cc/bcc/mesage/attachments to MimeMesage			 
							     msg.setFrom(new InternetAddress(fromAddress, fromName));
								 msg.setRecipients(javax.mail.Message.RecipientType.TO, toAddress);
								 msg.setRecipients(javax.mail.Message.RecipientType.CC, ccAddresses);
								 if(bccAddresses != null)
									msg.setRecipients(javax.mail.Message.RecipientType.BCC, bccAddresses);
									
								 msg.setSubject(subject,"utf-8");
								 
								 // Set the email msg text.
								 MimeBodyPart messagePart = new MimeBodyPart();
								 messagePart.setText(bodyText);	

								// Set the email attachment file
								FileDataSource fileDataSource = new FileDataSource(attachmentName);
								MimeBodyPart attachmentPart = new MimeBodyPart();
								attachmentPart.setDataHandler(new DataHandler(fileDataSource));
								attachmentPart.setFileName(fileDataSource.getName());

                               
								// Create Multipart E-Mail. for adding body and attachments
								Multipart multipart = new MimeMultipart();
								multipart.addBodyPart(messagePart);
								multipart.addBodyPart(attachmentPart);
                               
							   
							   //set multipart to MIme
							      msg.setContent(multipart);
				        6. now send mime to server using transport.send() method
                                 Transport.send(msg, "kodejava", "********");						
								
				
				
				</steps>
		   
		   3. code for mail 
		            
		            
		            <one>
					
						String errMsg = "font face=\"verdana\" >There is a problem with Batch process. Please find the error details as below. br ul li Server Name: TEMPSERVER li li Batch Process Name: TEMPPROCESS li li Class Name: TEMPCLASS li li Function Name: TEMPFUNCTION li ul br brTEMPERROR br br Thanks br ECOM Team. font";

					    String fromName = "Windows Servers Error";

						String fromAddress = "G09D-FAI.ECOM@in.fujitsu.com";
						String toName = "G09D-FAI.ECOM";
						String toAddress = "G09D-FAI.ECOM@in.fujitsu.com";
						errMsg = errMsg.replaceAll("TEMPSERVER", serverName);
						errMsg = errMsg.replaceAll("TEMPPROCESS", processName);
						errMsg = errMsg.replaceAll("TEMPCLASS", ClassName);
						errMsg = errMsg.replaceAll("TEMPFUNCTION", FunctionName);
						errMsg = errMsg.replaceAll("TEMPERROR", message);
						
				     </one>	  
                 			
			
			       
				   <two>
						   
							java.util.Properties props = System.getProperties();
							props.put("mail.smtp.host", serverName + "." + domainName);
							Session session = Session.getDefaultInstance(props, null);
							session.setDebug(false);
							
							javax.mail.internet.MimeMessage msg = new javax.mail.internet.MimeMessage(session);
							msg.setFrom(new InternetAddress(fromAddress, fromName));
							
							msg.setRecipients(javax.mail.Message.RecipientType.TO, toAddress);
							msg.setRecipients(javax.mail.Message.RecipientType.CC, ccAddresses);
							if(bccAddresses != null)
								msg.setRecipients(javax.mail.Message.RecipientType.BCC, bccAddresses);
								
							msg.setSubject(subject,"utf-8");
							// Set the email msg text.
							MimeBodyPart messagePart = new MimeBodyPart();
							messagePart.setText(bodyText);

							// Set the email attachment file
							FileDataSource fileDataSource = new FileDataSource(attachmentName);

							MimeBodyPart attachmentPart = new MimeBodyPart();
							attachmentPart.setDataHandler(new DataHandler(fileDataSource));
							attachmentPart.setFileName(fileDataSource.getName());

							// Create Multipart E-Mail.
							Multipart multipart = new MimeMultipart();
							multipart.addBodyPart(messagePart);
							multipart.addBodyPart(attachmentPart);

							msg.setContent(multipart);

							// Send the msg. Don't forget to set the username and password
							// to authenticate to the mail server.
							Transport.send(msg, "kodejava", "********");
				   
				   </two>
	 
	 </note>

</mail>

<Logger>

      <note>
	   
	         used for maintaining log details across application.
	   
	  </note>
     
	 <steps>
	 
	       1. download loggers latest like 2.3...
		   2. add into library or use maven
		   4. create log.properties and add properties for logger like console/log file etc.
		        e.g. >>  log4j.rootLogger=DEBUG,CONSOLE,LOGFILE
						 log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
						 log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
						 log4j.appender.CONSOLE.layout.ConversionPattern=%-4r [%t] %-5p %c %x \u2013 %m%n
						 log4j.appender.LOGFILE=org.apache.log4j.RollingFileAppender
						 log4j.appender.LOGFILE.File=myw.txt
						 log4j.appender.LOGFILE.MaxFileSize=1kb
						 log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout
						 log4j.appender.LOGFILE.layout.ConversionPattern=[%t] %-5p %c %d{dd/MM/yyyy HH:mm:ss} \u2013 %m%n
						 
		   5. load logger and with class
                  e.g. >> static Logger l=Logger.getLogger(Test.class.getName());
           6. configure logger by loading log.properties
                PropertyConfigurator.configure("src/t/log.properties");
           7. call logger method to write into log files configured in log.properties
                          l.info("this is test info for logger ");   
	  
	 
	 </steps>

</Logger>

<doc_report>
    
	<poi>

       for wokbook	
	    >>HSSFWorkbook - This class has methods to read and write Microsoft Excel files in .xls format. It is compatible with MS-Office versions 97–2003.
		     HSSFWorkbook()

        >>  XSSFWorkbook - This class has methods to read and write Microsoft Excel and OpenOffice xml files in .xls or .xlsx format. It is compatible with MS-Office versions 2007 or later.
		      cons----->XSSFWorkbook()
			  method:::
			        createSheet()
					createSheet(java.lang.String sheetname)
					createFont()
					createCellStyle()
					createFont()
			  
	  
	  for spreadsheet
	  >>HSSF (Horrible Spreadsheet Format) - It is used to read and write xls format of MS-Excel files.

       >>XSSF (XML Spreadsheet Format) 
	            XSSFSheet()
	
	    >>XSSFRow
		    createCell(int columnIndex)
			
	    >>XSSFCell
		
		>>setCellStyle(CellStyle style)
		
		<note>
		   
		   so here idea is to 
		   1. first create workbook using HSSFWorkbook() /XSSFWorkbook()
		          HSSFWorkbook wb = new HSSFWorkbook();
		   2. now create spreadsheet for workbook.	
                  HSSFSheet s = wb.createSheet();	
           3. now create row for shreadsheet.
                  HSSFRow  r = s.createRow(0);	
           4. now create cell for row
                   HSSFCell c =r.createCell((short)0);  
		   5. now fill cell with value and font and style
                    c.setCellValue("Option #");
                   HSSFCellStyle cs = wb.createCellStyle();
                  
				   HSSFFont f = wb.createFont();
                   f.setFontHeightInPoints((short) 9);
					
				   //make it blue
					f.setColor( (short)0xa );
				   // make it bold
					f.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);
				   //arial is the default font
					f.setFontName("Arial Unicode MS");

                    cs.setFont(f);
                    cs.setAlignment((short)HSSFCellStyle.ALIGN_LEFT);
                   
					add cellstyple to row
					  c.setCellStyle(cs);				   
		
		</note>
	
	</poi>

   <jasper>
   
   
   
   </jasper>
   
</doc_report>

<xsl_xml>
     
	 <note_xsl_trans>
	   
	   >>> download xalan.jar or add dependency in maven
	   
	   1. create xml file.
	   2. create xsl file.
       3. Create Tranformerfactory
             TransformerFactory tFactory = TransformerFactoryImpl.newInstance();	
       4. load xml and xsl with source		
              Source xmlSource = new StreamSource(new ByteArrayInputStream(getFileContent(masterXMLFileLocation).getBytes()));
              Source xslSource = new StreamSource(new ByteArrayInputStream(getFileContent(masterXSLFileLocation).getBytes()));
	   
	    5. now create transformer from factory instance with xsl.
		       Transformer transformer = tFactory.newTransformer(xslSource);
			   
		6. now transform xml to new transformer i.e. xls.s	  and store transformed reuslt into stream. 
           transformer.transform(xmlSource, new StreamResult(stream));
        
        7. convert stream to string or write into file.
		     resultStr = stream.toString();
             stream.close();
			 
	 </note_xsl_trans>
       
	   
	   <JDOM>
	      
		  
		  <read_query>
	      
		     Following are the steps used while parsing a document using JDOM Parser.

			1. Import XML-related packages.
			2. Create a SAXBuilder
			3. Create a Document from a file or stream
			4. Extract the root element
			5. Examine attributes
			6. Examine sub-elements
			
			 File inputFile = new File("C:\\Users\\ansarima\\Desktop\\XMLXSL\\breakfast.xml");
	         SAXBuilder saxBuilder = new SAXBuilder();
	         Document document = saxBuilder.build(inputFile);
			 Element classElement = document.getRootElement();

	         List Element studentList = classElement.getChildren();
			  
			   for (int temp = 0; temp studentList.size(); temp++)
	         
			    Element student = studentList.get(temp);
	             System.out.println("\nCurrent Element :" + student.getName());
				 System.out.println("Name : "+ student.getChild("name").getText());
				 
				   >>if sub element
				     List Element class = student.getChildren("classname");
          
		  </read_query> 
		  
		  <create>
		  
		       1. create RootElement
			            Element carsElement = new Element("cars");
			   2. assign it ot Document 
                        Document doc = new Document(carsElement);
		       3. create sub element and add attritbute if required
                          //supercars element
							 Element supercarElement = new Element("supercars");
							 supercarElement.setAttribute(new Attribute("company","Ferrari"));			   
			          //supercars element
						 Element carElement1 = new Element("carname");
						 carElement1.setAttribute(new Attribute("type","formula one"));
						 carElement1.setText("Ferrari 101");
						 
						 
				       supercarElement.addContent(carElement1);
	                   supercarElement.addContent(carElement2);	
					   
		        4.  finally add it to root
				
				   doc.getRootElement().addContent(supercarElement);
				   
				5. now write doc to output type e.g. file/console   
				   
						 XMLOutputter xmlOutput = new XMLOutputter();

						 // display xml
						 xmlOutput.setFormat(Format.getPrettyFormat());
						 xmlOutput.output(doc, System.out);
						 
						 >>use filewriter at System.in if you want to write into file.

		  </create>
		   
		   
		   <modify>
		   
		   
		     attribute.setValue("Lamborigini");
			 carElement.setText("Lamborigini 001");

		   
		   </modify>
	   
	   </JDOM>

</xsl_xml>

<design_pattern>
 
 
 1.creational
 
      >>Creational design patterns are concerned with the way of creating objects. These design patterns are used when a decision must be made at the time of instantiation 
	  of a class (i.e. creating an object of a class).
	  
	  Hard-Coded code is not the good programming approach. Here, we are creating the instance by using the new keyword. Sometimes, the nature of the object must be
	  changed according to the nature of the program. In such cases, we must get the help of creational design patterns to provide more general and flexible approach.
	  
	  1.Factory Method Pattern
	       here abstract class and interface is used.
		   
		   subclass decides which abstract class should be instaniated.
		     in below example subclass create instance depending upon request  
					   public Plan getPlan(String planType){  
						if(planType == null){  
						 return null;  
						}  
					  if(planType.equalsIgnoreCase("DOMESTICPLAN")) {  
							 return new DomesticPlan();  
						   }   
		   
	     
	  2.Abstract Factory Pattern
	  
	  
      3.Singleton Pattern
	  
	      >> Singleton Pattern says that just"define a class that has only one instance and provides a global point of access to it".
		   
		   >>There are two forms of singleton design pattern

				>>Early Instantiation: creation of instance at load time.
				>>Lazy Instantiation: creation of instance when required.
				
		  >>TO create the singleton class, we need to have static member of class, private constructor and static factory method.

				Static member: It gets memory only once because of static, itcontains the instance of the Singleton class.
				Private constructor: It will prevent to instantiate the Singleton class from outside the class.
				Static factory method: This provides the global point of access to the Singleton object and returns the instance to the caller.		
				
				
		  >>EARLY AT TIME OF CLASS LOADING		
		  
		  In such case, we create the instance of the class at the time of declaring the static data member, so instance of the class is created at the time of classloading.
							 class A{  
					 private static A obj=new A();//Early, instance will be created at load time  
					 private A(){}  
					   
					 public static A getA(){  
					  return obj;  
					 }  
					  
					 public void doSomething(){  
					 //write your code  
					 }  
					}  

            >>LAZY 

                   In such case, we create the instance of the class in synchronized method or synchronized block, so instance of the class is created when required.	


						class A{  
						 private static A obj;  
						 private A(){}  
						   
						 public static A getA(){  
						   if (obj == null){  
							  synchronized(Singleton.class){  
								if (obj == null){  
									obj = new Singleton();//instance will be created at request time  
								}  
							}              
							}  
						  return obj;  
						 }  
						  
						 public void doSomething(){  
						 //write your code  
						 }  
						}	


                >>If singleton class is loaded by two classloaders, two instance of singleton class will be created, one for each classloader.

                 >>If singleton class is Serializable, you can serialize the singleton instance. Once it is serialized, you can deserialize it but it will not return 
				 the singleton object.

                  To resolve this issue, you need to override the readResolve() method that enforces the singleton. It is called just after the object is deserialized. 
				  It returns the singleton object.
				  
                      public class A implements Serializable 
					  {  
								//your code of singleton  
								protected Object readResolve() {  
									return getA();  
								}  
  
                       }  


				
      4.Prototype Pattern
      5.Builder Pattern
      6.Object Pool Pattern
	  
	  
 
 2.structural
 
 3. behavioral


</design_pattern>

<JSP_SERVLET>

  <servlet>
     
	 <container>
	 
				 The Servlet Container performs many operations that are given below:

					Life Cycle Management
					Multithreaded support
					Object Pooling
					Security etc.
	 
	 </container>
	 
	 <servlet_API>
	 
	      Interfaces in javax.servlet package

				There are many interfaces in javax.servlet package. They are as follows:

				Servlet
				ServletRequest
				ServletResponse
				RequestDispatcher
				ServletConfig
				ServletContext
				SingleThreadModel
				Filter
				FilterConfig
				FilterChain
				ServletRequestListener
				ServletRequestAttributeListener
				ServletContextListener
				ServletContextAttributeListener

				 
				Classes in javax.servlet package

				There are many classes in javax.servlet package. They are as follows:

				GenericServlet
				ServletInputStream
				ServletOutputStream
				ServletRequestWrapper
				ServletResponseWrapper
				ServletRequestEvent
				ServletContextEvent
				ServletRequestAttributeEvent
				ServletContextAttributeEvent
				ServletException
				UnavailableException
				Interfaces in javax.servlet.http package

				There are many interfaces in javax.servlet.http package. They are as follows:

				HttpServletRequest
				HttpServletResponse
				HttpSession
				HttpSessionListener
				HttpSessionAttributeListener
				HttpSessionBindingListener
				HttpSessionActivationListener
				HttpSessionContext (deprecated now)
				Classes in javax.servlet.http package

				There are many classes in javax.servlet.http package. They are as follows:

				HttpServlet
				Cookie
				HttpServletRequestWrapper
				HttpServletResponseWrapper
				HttpSessionEvent
				HttpSessionBindingEvent
				HttpUtils (deprecated now)
					 
	 
	 
	 
	 </servlet_API>
	 
	  <API_HIERARCHY>
	  
	      1.>>Servlet   ---interface
		             >>  public void init(ServletConfig config)	initializes the servlet. It is the life cycle method of servlet and invoked by the web container only once.
					 
					 >>  public void service(ServletRequest request,ServletResponse response)	provides response for the incoming request. It is invoked at each request by the web container.
					 
					 >>  public void destroy()	is invoked only once and indicates that servlet is being destroyed.
					 
					 >>  public ServletConfig getServletConfig()	returns the object of ServletConfig.
					 
					 >>  public String getServletInfo()
		     
			 1.1>>Generic Servlet implements Servlet, ServletConfig and Serializable	

					>>public void init(ServletConfig config) is used to initialize the servlet.
					
					>>public abstract void service(ServletRequest request, ServletResponse response) provides service for the incoming request. It is invoked at each time when user requests for a servlet.
					
					>>public void destroy() is invoked only once throughout the life cycle and indicates that servlet is being destroyed.
					
					>>public ServletConfig getServletConfig() returns the object of ServletConfig.
					
					>>public String getServletInfo() returns information about servlet such as writer, copyright, version etc.
					
					>>public void init() it is a convenient method for the servlet programmers, now there is no need to call super.init(config)
					
					>>public ServletContext getServletContext() returns the object of ServletContext.
					
					>>public String getInitParameter(String name) returns the parameter value for the given parameter name.
					
					>>public Enumeration getInitParameterNames() returns all the parameters defined in the web.xml file.
					
					>>public String getServletName() returns the name of the servlet object.		


                     1.1.1 >>HttpServlet extends the GenericServlet class and implements Serializable 
					             
								   >>public void service(ServletRequest req,ServletResponse res) dispatches the request to the protected service method by converting the request and response object into http type.
								 
								   >>	protected void service(HttpServletRequest req, HttpServletResponse res) receives the request from the service method, and dispatches the request to the doXXX() method depending on the incoming http request type.
								
                                   >>protected void doGet(HttpServletRequest req, HttpServletResponse res) handles the GET request. It is invoked by the web container.
									>>protected void doPost(HttpServletRequest req, HttpServletResponse res) handles the POST request. It is invoked by the web container.
									>>protected void doHead(HttpServletRequest req, HttpServletResponse res) handles the HEAD request. It is invoked by the web container.
									>>protected void doOptions(HttpServletRequest req, HttpServletResponse res) handles the OPTIONS request. It is invoked by the web container.
									>>protected void doPut(HttpServletRequest req, HttpServletResponse res) handles the PUT request. It is invoked by the web container.
									>>protected void doTrace(HttpServletRequest req, HttpServletResponse res) handles the TRACE request. It is invoked by the web container.
									>>protected void doDelete(HttpServletRequest req, HttpServletResponse res) handles the DELETE request. It is invoked by the web container.
									>>protected long getLastModified(HttpServletRequest req) returns the time when HttpServletRequest was last modified since midnight January 1, 1970 GMT
														 
	  
	  
	  </API_HIERARCHY>
  
      <lifeCycle>
	  
			  Servlet class is loaded.
		      Servlet instance is created.
		      init method is invoked.
		      service method is invoked.
		      destroy method is invoked.
	  
	          How web container handles the servlet request?

				The web container is responsible to handle the request. Let's see how it handles the request.

				maps the request with the servlet in the web.xml file.
				creates request and response objects for this request
				calls the service method on the thread
				The public service method internally calls the protected service method
				The protected service method calls the doGet method depending on the type of request.
				The doGet method generates the response and it is passed to the client.
				After sending the response, the web container deletes the request and response objects. The thread is contained in the thread pool or 
				deleted depends on the server implementation.
					  
	  </lifeCycle>
   
      <servletRequest>
	  
	    An object of ServletRequest is used to provide the client request information to a servlet such as content type, content length, parameter names and values, 
		header informations, attributes etc.
		
		public String getParameter(String name)	is used to obtain the value of a parameter by name.
		public String[] getParameterValues(String name)	returns an array of String containing all values of given parameter name. It is mainly used to obtain values of a
		Multi select list box.
		java.util.Enumeration getParameterNames()	returns an enumeration of all of the request parameter names.
		public int getContentLength()	Returns the size of the request entity data, or -1 if not known.
		public String getCharacterEncoding()	Returns the character set encoding for the input of this request.
		public String getContentType()	Returns the Internet Media Type of the request entity data, or null if not known.
		public ServletInputStream getInputStream() throws IOException	Returns an input stream for reading binary data in the request body.
		public abstract String getServerName()	Returns the host name of the server that received the request.
		public int getServerPort()	Returns the port number on which this request was received.
  
      </servletRequest>
       
	  <servlet_collaboration> 
	  
			  <RequestDispatcher>
			  
				  The RequestDispatcher interface provides the facility of dispatching the request to another resource it may be html, servlet or jsp. This interface 
				  can also be used to include the content of another resource also. It is one of the way of servlet collaboration.
				  
				  public void forward(ServletRequest request,ServletResponse response)throws ServletException,java.io.IOException:Forwards a request from a servlet 
				  to another resource (servlet, JSP file, or HTML file) on the server.
				
				  public void include(ServletRequest request,ServletResponse response)throws ServletException,java.io.IOException:Includes the content 
				  of a resource (servlet, JSP page, or HTML file) in the response.
				  
				  RequestDispatcher rd=request.getRequestDispatcher("servlet2");  
				  
				  rd.forward(request, response);
			  
			  
			  </RequestDispatcher>	
              
			 <SendRedirect>
			      The sendRedirect() method of HttpServletResponse interface can be used to redirect response to another resource, it may be servlet, jsp or html file.
			 
			      response.sendRedirect("http://www.google.com");
			 
			 
			 </SendRedirect>			  
			  
	   </servlet_collaboration> 
	   
	   <ServletConfig>
	   
	              An object of ServletConfig is created by the web container for each servlet. This object can be used to get configuration information from web.xml file.
				  
				    public String getInitParameter(String name):Returns the parameter value for the specified parameter name.
					public Enumeration getInitParameterNames():Returns an enumeration of all the initialization parameter names.
					public String getServletName():Returns the name of the servlet.
					public ServletContext getServletContext():Returns an object of ServletContext.
					
					
					ServletConfig config=getServletConfig();  
					String driver=config.getInitParameter("driver");  
					
					out.print("Driver is: "+driver);  
					
					    <init-param>  
							<param-name> driver </param-name>  
							<param-value> sun.jdbc.odbc.JdbcOdbcDriver </param-value>  
						</init-param>  
					
	   
	   
	   </ServletConfig>
	   
	   <ServletContext>
	   
	   An object of ServletContext is created by the web container at time of deploying the project. This object can be used to get configuration information from web.xml file. There is only one ServletContext object per web application.

       If any information is shared to many servlet, it is better to provide it from the web.xml file using the context-param> element.
	   
			   <context-param>  
			   
				  <param-name> parametername </param-name>  
				  <param-value> parametervalue </param-value>  
				 
			  </context-param>  
			  
			  //creating ServletContext object  
				ServletContext context=getServletContext();  
				  
				//Getting the value of the initialization parameter and printing it  
				String driverName=context.getInitParameter("dname");  
	   
	   </ServletContext>
	   
 

       <Attribute>
	   
	       An attribute in servlet is an object that can be set, get or removed from one of the following scopes:
		   
		    request scope
			session scope
			application scope
			
			public void setAttribute(String name,Object object):sets the given object in the application scope.
            public Object getAttribute(String name):Returns the attribute for the specified name.
            public Enumeration getInitParameterNames():Returns the names of the context's initialization parameters as an Enumeration of String objects.
            public void removeAttribute(String name):Removes the attribute with the given name from the servlet context.
	   
	   </Attribute>
	   
	   <session_technique>
	   
	       1. Cookies
		        A cookie is a small piece of information that is persisted between the multiple client requests.
                A cookie has a name, a single value, and optional attributes such as a comment, path and domain qualifiers, a maximum age, and a version number.
				
				There are 2 types of cookies in servlets.

                    >> Non-persistent cookie
					      It is valid for single session only. It is removed each time when user closes the browser.
                    >> Persistent cookie
					      It is valid for multiple session . It is not removed each time when user closes the browser. It is removed only if user logout or signout.
		            >>Disadvantage of Cookies
                                  It will not work if cookie is disabled from the browser.
                                  Only textual information can be set in Cookie object.
								  
		            >>javax.servlet.http.Cookie 
					    Cookie()	constructs a cookie.
                        Cookie(String name, String value)	constructs a cookie with a specified name and value.
						
						public void setMaxAge(int expiry)	Sets the maximum age of the cookie in seconds.
						public String getName()	Returns the name of the cookie. The name cannot be changed after creation.
						public String getValue()	Returns the value of the cookie.
						public void setName(String name)	changes the name of the cookie.
						public void setValue(String value)	changes the value of the cookie.
						
						public void addCookie(Cookie ck):method of HttpServletResponse interface is used to add cookie in response object.
                        public Cookie[] getCookies():method of HttpServletRequest interface is used to return all the cookies from the browser.

						
		   
		   2. Hidden Form Field
		   
						In case of Hidden Form Field a hidden (invisible) textfield is used for maintaining the state of an user.
                        In such case, we store the information in the hidden field and get it from another servlet. This approach is better if we have to submit form in all the pages and we don't want to depend on the browser.

                        Let's see the code to store value in hidden field.

                        <input type="hidden" name="uname" value="Vimal Jaiswal">  
		                </input>
		   
		   3. URL Rewriting
		   
		              In URL rewriting, we append a token or identifier to the URL of the next Servlet or the next resource. We can send parameter name/value pairs using the following format:

                      url?name1=value1&name2=value2&??
           4. HttpSession
		            in such case, container creates a session id for each user.The container uses this id to identify the particular user.An object of HttpSession can be used to perform two tasks:

					>> bind objects
					>> view and manipulate information about a session, such as the session identifier, creation time, and last accessed time.
					
					The HttpServletRequest interface provides two methods to get the object of HttpSession:

                                public HttpSession getSession(): Returns the current session associated with this request, or if the request does not have a session, creates one.
					
                                public HttpSession getSession(boolean create):  Returns the current HttpSession associated with this request or, if there is no current session and create is true, returns a new session.
					
                    Commonly used methods of HttpSession interface

								public String getId():Returns a string containing the unique identifier value.
								
								public long getCreationTime():Returns the time when this session was created, measured in milliseconds since midnight January 1, 1970 GMT.
								
								public long getLastAccessedTime():Returns the last time the client sent a request associated with this session, as the number of milliseconds since midnight January 1, 1970 GMT.
								
								public void invalidate():Invalidates this session then unbinds any objects bound to it.
									   
	   </session_technique>
	   
	   <listener>
	   
	   </listener>
	   
	   <Filter>
	   
	        A filter is an object that is invoked at the preprocessing and postprocessing of a request.
			It is mainly used to perform filtering tasks such as conversion, logging, compression, encryption and decryption, input validation etc.
			The servlet filter is pluggable, i.e. its entry is defined in the web.xml file, if we remove the entry of filter from the web.xml file, filter will be removed automatically and we don't need to change the servlet.
			
			1) Filter interface
				public void init(FilterConfig config)	init() method is invoked only once. It is used to initialize the filter.
				public void doFilter(HttpServletRequest request,HttpServletResponse response, FilterChain chain)	doFilter() method is invoked every time when user request to any resource, to which the filter is mapped.It is used to perform filtering tasks.
				public void destroy()	This is invoked only once when filter is taken out of the service.
           2) FilterChain interface
				The object of FilterChain is responsible to invoke the next filter or resource in the chain.This object is passed in the doFilter method of Filter interface.The FilterChain interface contains only one method:

				public void doFilter(HttpServletRequest request, HttpServletResponse response): it passes the control to the next filter or resource.
	            
				chain.doFilter(req, resp);//sends request to next resource  
             
			 
			 FilterConfig

				>>An object of FilterConfig is created by the web container. This object can be used to get the configuration information from the web.xml file.

				>>Methods of FilterConfig interface
				There are following 4 methods in the FilterConfig interface.

				public void init(FilterConfig config): init() method is invoked only once it is used to initialize the filter.
				public String getInitParameter(String parameterName): Returns the parameter value for the specified parameter name.
				public java.util.Enumeration getInitParameterNames(): Returns an enumeration containing all the parameter names.
				public ServletContext getServletContext(): Returns the ServletContext object.
					   
	   </Filter>
	   
	   <mislanious>
	   
			   >>  ServletInputStream class provides stream to read binary data such as image etc. from the request object. It is an abstract class.
			   The getInputStream() method of ServletRequest interface returns the instance of ServletInputStream class. So can be get as:

		       ServletInputStream sin=request.getInputStream();  
		       Method of ServletInputStream class

				There are only one method defined in the ServletInputStream class.
				int readLine(byte[] b, int off, int len) it reads the input stream.
				
		      >>ServletOutputStream class

				ServletOutputStream class
				Methods of ServletOutputStream class
				Example of ServletOutputStream class
				ServletOutputStream class provides a stream to write binary data into the response. It is an abstract class.

				The getOutputStream() method of ServletResponse interface returns the instance of ServletOutputStream class. It may be get as:

				ServletOutputStream out=response.getOutputStream();  
				void print(boolean b){}
				
				
			>>Servlet with Annotation (feature of servlet3):
				 @WebServlet annotation is used to map the servlet with the specified name.
				 
		    >>SingleThreadModel 
			     The servlet programmer should implement SingleThreadModel interface to ensure that servlet can handle only one request at a time. It is a marker interface, means have no methods.		 
	   
	   
	   
	   </mislanious>
       
   </servlet>  
	  
   <JSP>
       
	   <life_cycle>
	   
			Life cycle of a JSP Page
			The JSP pages follows these phases:

			Translation of JSP Page
			Compilation of JSP Page
			Classloading (class file is loaded by the classloader)
			Instantiation (Object of the Generated Servlet is created).
			Initialization ( jspInit() method is invoked by the container).
			Reqeust processing ( _jspService() method is invoked by the container).
			Destroy ( jspDestroy() method is invoked by the container).
		
		</life_cycle>	
		
		
		<JSP_Scripting_elements>

				The scripting elements provides the ability to insert java code inside the jsp. There are three types of scripting elements:

				1. scriptlet tag
				
				    <%  java source code %> 
				2. expression tag
				      <%=  statement %>  
				3. declaration tag
				<%!  field or method declaration %>  

         </JSP_Scripting_elements>
		 
		 <Implicit_Objects9>
		 
				out	                 JspWriter
				request	             HttpServletRequest
				response	         HttpServletResponse
				config             	 ServletConfig
				application	         ServletContext
				session	             HttpSession
				pageContext	         PageContext
				page	             Object
				exception	         Throwable
		 
		 
		 
		 </Implicit_Objects9>
		 
		 <JSP_directives>
		 
		 The jsp directives are messages that tells the web container how to translate a JSP page into the corresponding servlet.

				There are three types of directives:

				>>page directive
				   %@ page attribute="value" %> 
				   
				   Attributes of JSP page directive

					import
					contentType
					extends
					info
					buffer
					language
					isELIgnored
					isThreadSafe
					autoFlush
					session
					pageEncoding
					errorPage
					isErrorPage
				
				>>include directive
				    %@ include file="header.html" %> 
				
				
				>>taglib directive
				    %@ taglib uri="http://www.javatpoint.com/tags" prefix="mytag" %>  
  
				
				
		 
		 
		 
		 </JSP_directives>
		
		  <JSP_Action_Tags>
		  
		       There are many JSP action tags or elements. Each JSP action tag is used to perform some specific tasks.
               The action tags are used to control the flow between pages and to use Java Bean. 
			   
			   >>JSP Action Tags	Description
				    >>jsp:forward	forwards the request and response to another resource.
				
							<jsp:forward page="printdate.jsp" >  
							<jsp:param name="name" value="javatpoint.com" />  
							</jsp:forward>  
				    >>jsp:include	includes another resource.
				          <jsp:include page="printdate.jsp" />  
					>>jsp:useBean	creates or locates bean object.
					
							<jsp:useBean id= "instanceName" scope= "page | request | session | application"   
							    >>class= "packageName.className" type= "packageName.className"  
							    >>beanName="packageName.className" 
							</jsp:useBean> 
							
							>>Attributes and Usage of jsp:useBean action tag

									id: is used to identify the bean in the specified scope.
									scope: represents the scope of the bean. It may be page, request, session or application. The default scope is page.
									page: specifies that you can use this bean within the JSP page. The default scope is page.
									request: specifies that you can use this bean from any JSP page that processes the same request. It has wider scope than page.
									session: specifies that you can use this bean from any JSP page in the same session whether processes the same request or not. It has wider scope than request.
									application: specifies that you can use this bean from any JSP page in the same application. It has wider scope than session.
									class: instantiates the specified bean class (i.e. creates an object of the bean class) but it must have no-arg or no constructor and must not be abstract.
									type: provides the bean a data type if the bean already exists in the scope. It is mainly used with class or beanName attribute. If you use it without class or beanName, no bean is instantiated.
									beanName: instantiates the bean using the java.beans.Beans.instantiate() method.
							
							     <jsp:useBean id="obj" class="com.javatpoint.Calculator"/>  
  
										<%  
										    int m=obj.cube(5);  
										    out.print("cube of 5 is "+m);  
										%> 
					>>jsp:setProperty	sets the value of property in bean object.
					            <jsp:useBean id="u" class="org.sssit.User"></jsp:useBean>  
								<jsp:setProperty property="*" name="u"/>  
								  
								Record:
								<jsp:getProperty property="name" name="u"/>
								<jsp:getProperty property="password" name="u"/>  
								<jsp:getProperty property="email" name="u" /> 
					
					
					
					>>jsp:getProperty	prints the value of property of the bean.
					>>jsp:plugin	embeds another components such as applet.
					>>jsp:param	sets the parameter value. It is used in forward and include mostly.
					>>jsp:fallback	can be used to print the message if plugin is working. It is used in jsp:plugin.
			  
			  
			  
		  
		  
		  
		  </JSP_Action_Tags> 
	      
		  <EL>
		  
		      The Expression Language (EL) simplifies the accessibility of data stored in the Java Bean component, and other objects like request, session, application etc.

				There are many implicit objects, operators and reserve words in EL.

				It is the newly added feature in JSP technology version 2.0.
				Syntax for Expression Language (EL)
				${ expression }  
				
				Implicit Objects	Usage
				
				
				pageScope	               it maps the given attribute name with the value set in the page scope
				requestScope	           it maps the given attribute name with the value set in the request scope
				sessionScope	           it maps the given attribute name with the value set in the session scope
				applicationScope	       it maps the given attribute name with the value set in the application scope
				param	                   it maps the request parameter to the single value
				paramValues	               it maps the request parameter to an array of values
				header	                   it maps the request header name to the single value
				headerValues	           it maps the request header name to an array of values
				cookie	                   it maps the given cookie name to the cookie value
				initParam	               it maps the initialization parameter
				pageContext                it provides access to many objects request, session etc.
				
				Welcome, ${ param.name } 
				Value is ${ sessionScope.user }  
				Hello, ${cookie.name.value}  
				
				Precedence of Operators in EL

				There are many operators that have been provided in the Expression Language. Their precedence are as follows:

				[] .
				()
				-(unary) not ! empty
				* / div % mod
				+ - (binary)
				lt le gt ge
				== != eq ne
				and and
				|| or
				?:

		  
		  
		  </EL>
		          
		  <JSTL>
		  
		       <toFirstLetterUpper>
			        ${fn:toUpperCase(fn:substring(someString, 0, 1))}${fn:toLowerCase(fn:substring(someString, 1,fn:length(someString)))}
			   </toFirstLetterUpper>
		  
		  </JSTL>
          
		  <custom_TAG>
		      f
		  </custom_TAG>
		  
    </JSP>	  
		  
</JSP_SERVLET>

<mobile_development>
      
	  <ionic>
	  
	  </ionic>
	  
</mobile_development>

<Hibernate>
   
   <readDAILYwebArticleforHibernate/>
   
   <note>
      
	  1.>> hibernate configuration
	  2.>> model class
	  3.>> service to use hibernate API
	  
			  
			  Hibernate configuration can be done with "Hibernate.cfg.xml" or "hibernate.properties"
			  
			  1. Hibernate.cfg.xml(default) : have more fetures than "hibernate.properties"
							 both configuration and mapping of class can be done
				   
				   SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();
				   Session session = sessionFactory.openSession();
				   
			  2. Prgramatically	   
				  
				  Configuration cfg = new Configuration()
						.addClass(com.websystique.hibernate.model.Student.class)
						.addClass(com.websystique.hibernate.model.University.class).
						.setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLDialect")
						.setProperty("hibernate.connection.driver_class", "com.mysql.jdbc.Driver")
						.setProperty("hibernate.connection.username", "myuser");
						.setProperty("hibernate.connection.password", "mypassword")
						.setProperty("hibernate.connection.url", "jdbc:mysql://localhost:3306/websystique")
						.setProperty("hibernate.show_sql", "true")
						.setProperty("hibernate.format_sql", "true");
					 
					SessionFactory sessionFactory = cfg.buildSessionFactory();
					Session session = sessionFactory.openSession();
						  
	     
	  <sessionFactory_VS_entityMangerFactory>
	     
		 JPA:
			 entitymangerFactory and entity manager is a JPA specification implementation
			 entity manger uses:  Session session=entitymanger.unwrap(Session.class)
	  
	  
	  </sessionFactory_VS_entityMangerFactory>
	  
	  >>hbm2ddl.auto---create/update
	  
	  >> IF FIELD is static or transient then field will not be persisted into database
	  
   </note>
   
   
   <HQL>
   
          FROM:
		        String hql = "FROM Employee AS E";
				Query query = session.createQuery(hql);
				List results = query.list();

          SELECT:
			   String hql = "SELECT E.firstName FROM Employee E";
			   Query query = session.createQuery(hql);
			   List results = query.list();
		  
          WHERE:
                String hql = "FROM Employee E WHERE E.id = 10";
				Query query = session.createQuery(hql);
				List results = query.list();	
				
          ORDER BY:
				String hql = "FROM Employee E WHERE E.id > 10 ORDER BY E.salary DESC";
				Query query = session.createQuery(hql);
				List results = query.list(); 
				
		  GROUP BY:		
		        String hql = "SELECT SUM(E.salary), E.firtName FROM Employee E " + "GROUP BY E.firstName";
				Query query = session.createQuery(hql);
				List results = query.list();	
		 
          NAME /USER PARAM:		 
					String hql = "FROM Employee E WHERE E.id = :employee_id";
					Query query = session.createQuery(hql);
					query.setParameter("employee_id",10);
					List results = query.list();	
					
		  @NameQuery:(name="userBYId",query="select id from user where id= ?", resultclass="")			
		         Query q=ses.getNamedQuery("userBYid");

          @NamedNativeQuery(name="",query="select * from User wher uuserid=?")
          		 
		 

          UPDATE:
                String hql = "UPDATE Employee set salary = :salary "  + "WHERE id = :employee_id";
				Query query = session.createQuery(hql);
				query.setParameter("salary", 1000);
				query.setParameter("employee_id", 10);
				int result = query.executeUpdate();
				System.out.println("Rows affected: " + result);		
				
          DELETE:
				String hql = "DELETE FROM Employee "  +  "WHERE id = :employee_id";
				Query query = session.createQuery(hql);
				query.setParameter("employee_id", 10);
				int result = query.executeUpdate();
				System.out.println("Rows affected: " + result);	
				
          INSERT:
			  String hql = "INSERT INTO Employee(firstName, lastName, salary)"  + "SELECT firstName, lastName, salary FROM old_employee";
			  Query query = session.createQuery(hql);
			  int result = query.executeUpdate();
			  System.out.println("Rows affected: " + result);	

          AGGREGATE  
				avg(property name) The average of a property's value
				count(property name or *) The number of times a property occurs in the results
				max(property name) The maximum value of the property values
				min(property name)The minimum value of the property values
				sum(property name)The sum total of the property values
				
		  PAGINATION using Query
               
               1. Query setFirstResult(int startPosition) This method takes an integer that represents the first row in your result set, starting with row 0.
               2. Query setMaxResults(int maxResult) This method tells Hibernate to retrieve a fixed number maxResults of objects.		
                    String hql = "FROM Employee";
					Query query = session.createQuery(hql);
					query.setFirstResult(1);
					query.setMaxResults(10);
					List results = query.list();	
					
		
         disadvantages:
               		 
         					
   			
   
   </HQL>
   
   <CRITERIA> 
     
	        DIRECTLY RESTRICTION ON CLASS ENTITY
			
			Criteria cr = session.createCriteria(Employee.class);
            List results = cr.list();
			
			Criteria cr = session.createCriteria(Employee.class);
			cr.add(Restrictions.eq("salary", 2000));
			List results = cr.list();
			
			Criteria cr = session.createCriteria(Employee.class);

					// To get records having salary more than 2000
					cr.add(Restrictions.gt("salary", 2000));

					// To get records having salary less than 2000
					cr.add(Restrictions.lt("salary", 2000));

					// To get records having fistName starting with zara
					cr.add(Restrictions.like("firstName", "zara%"));

					// Case sensitive form of the above restriction.
					cr.add(Restrictions.ilike("firstName", "zara%"));

					// To get records having salary in between 1000 and 2000
					cr.add(Restrictions.between("salary", 1000, 2000));

					// To check if the given property is null
					cr.add(Restrictions.isNull("salary"));

					// To check if the given property is not null
					cr.add(Restrictions.isNotNull("salary"));

					// To check if the given property is empty
					cr.add(Restrictions.isEmpty("salary"));

					// To check if the given property is not empty
					cr.add(Restrictions.isNotEmpty("salary"));
					
					
					>>You can create AND or OR conditions using LogicalExpression restrictions as follows -

							Criteria cr = session.createCriteria(Employee.class);

							Criterion salary = Restrictions.gt("salary", 2000);
							Criterion name = Restrictions.ilike("firstNname","zara%");

							// To get records matching with OR conditions
							LogicalExpression orExp = Restrictions.or(salary, name);
							cr.add( orExp );

							// To get records matching with AND conditions
							LogicalExpression andExp = Restrictions.and(salary, name);
							cr.add( andExp );
							
							List results = cr.list();
					   
				
            SORT:
                     Criteria cr = session.createCriteria(Employee.class);

						// To get records having salary more than 2000
						cr.add(Restrictions.gt("salary", 2000));

						// To sort records in descening order
						crit.addOrder(Order.desc("salary"));

						// To sort records in ascending order
						crit.addOrder(Order.asc("salary"));

						List results = cr.list();	
						
						
            
			PROJECTION and  AGGREGATION:
			
                    Criteria cr = session.createCriteria(Employee.class);

					// To get total row count.
					cr.setProjection(Projections.rowCount());

					// To get average of a property.
					cr.setProjection(Projections.avg("salary"));

					// To get distinct count of a property.
					cr.setProjection(Projections.countDistinct("firstName"));

					// To get maximum of a property.
					cr.setProjection(Projections.max("salary"));

					// To get minimum of a property.
					cr.setProjection(Projections.min("salary"));

					// To get sum of a property.
					cr.setProjection(Projections.sum("salary"));			
   
   
   </CRITERIA>
   
   <NATIVE_SQL>
   
            SCALER:(RAW DATA -RESULTSET)
				   String sql = "SELECT first_name, salary FROM EMPLOYEE";
				   SQLQuery query = session.createSQLQuery(sql);
				   query.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP);
				   List results = query.list();
				   
            ENTITY:(CLASS ENTITY DATA)
				   String sql = "SELECT * FROM EMPLOYEE WHERE id = :employee_id";
				   SQLQuery query = session.createSQLQuery(sql);
				   query.addEntity(Employee.class);
				   query.setParameter("employee_id", 10);
				   List results = query.list();
   
   </NATIVE_SQL>
   
   <CACHING>
         
		 minimize number of hitting to database
        
		<FIRST_LEVEL_CACHE>
		
		   Session:
		
		
		</FIRST_LEVEL_CACHE>
		
		<SECOND_LEVEL_CACHE>
		
		   @cachable   --tells hibernate its a entity is cachable
		   @cahe(usage=CacheConcurencyStrategy.)   --tells hibernate how to fetch cache  --for--read/write/etc..
		   cache.use_second_level_cache==true
		   cache.provider.class ==org.hibernate.cache.NoCacheProvider
		                        == org.hibernate.cahce.
		
		   >> Across Session in an application
		   >> Acroos Application
		   >> Across Cluster
		
		
		</SECOND_LEVEL_CACHE>
     
	    <QUERY_LEVEL_CACHE>
                    
		     cache.use_query_level_cache==true
		     query.setcachable(true) in both quey
		
		</QUERY_LEVEL_CACHE>
  
  
  
   </CACHING>
   
   <ANNOTATION>
   
             <Entity>
			 
			 </Entity>
			 
			 <Entity_hibernate>
			          selectbeforeUpdate:  tells hibernate select and verify then update
			 </Entity_hibernate>
			 
			 
			 <Table>
			 
			 </Table>
			 
			 <Id> 
			 
			 </Id> 

             			 mark field as primary key
					@SequenceGenerator(name="seq",sequenceName="oracle_seq") 
						   if you not specify sequence name then hibernate will use default sequence 
						   
					@TableGenerator(name="book_generator", table="id_generator", schema="bookstore")

					
					@GeneratedValue(strategy=GenerationType.SEQUENCE, generator="seq") 	 
					
			 <GENERATEDVALUE>
			         (used as surrogate key) generate automatically value by hibernate wrt data types 
							   this tells how primary key should be genaerated
			 </GENERATEDVALUE>				   
			 
			  <Column>
			  
			 </Column>
		   
			 
			 <BASIC>
			 
			 
			 
			 </BASIC> 

			 <TRANSIENT_STATIC>
				THE filed with transient or static can not be persisted into the databse
				
				
			 </TRANSIENT_STATIC>

			 <TEMPORAL>
				 
				 this annoation is used to control DATE timestap

			 </TEMPORAL>	 
			 
			 <LOB_CLOB_BLOB>
			 
			 </LOB_CLOB_BLOB>
			 
			 <EMBEDED>
				 
				 @EMBEDABLE
							: This annotaion is used when any class will be used in another entity then call will be marked as @Embedebale
							  making class "reusable" for Entity
							dont have lifecycle its totaly depends on lifecycle of Entity
							
				 @Column()  : to make our own column name			 
				 @Embeded   :
							  This annotaon is used in Entity class for embeding anoter class for using all filed in entity calss.

							  e.g. Address is a class with different address field and 
								   Customer is a class Entity so customer have address and customer class can use Address class as embedable object
								   so all field of Address can be available in customer Entity
						   
				 @AttributeOverrides({@AttributeOverride(name="name" ,column=@Column(name="Animal_Name")), })	
							this annotation will be used to overide filed of embedeble object but with different param like column name length.
							
				
				 @EMBEDEDID  :		
							  used to make composite key
							  create class with anootation @embedeble then
							  implements  serilizable
							  public constructor
							  public or protected field
							  
							  
							  
				@ELEMENTCOLLECTION  : creates subtable(mapping with primary -foreign key)
				              
							    @ElementCollection
								@JoinTable(name="USER_ADDRESS",joinColumns=@JoinColumn(name="id"))
								Set Address addset=new HashSet Address();
				             
							 >> ElementCollection is a standard JPA annotation, which is now preferred over the proprietary Hibernate annotation 
							    CollectionOfElements.

                             >> It means that the collection is not a collection of entities, but a collection of simple types (Strings, etc.) 
							    or a collection of embeddable elements (class annotated with @Embeddable).

                             >> It also means that the elements are completely owned by the containing entities: they're modified when the entity is modified,
  							    deleted when the entity is deleted, etc. They can't have their own lifecycle.
								 
						     >> @ElementCollection is mainly for mapping non-entities (embeddable or basic) while @OneToMany is used to map entities. 
							    So which one to use depend on what you want to achieve.
                                				
							  
						   
			 
			 </EMBEDED>
			 
			 <PROXY_EAGER_LAZY>
			     
				   LAZY : BY DEFAULT  hibernate works as lazy FETCH means depending on request hibernate operates.
				             first hiberante generates proxyobject for every entity and eager/lazy works on proxy objects.
							 
					         >>is a design pattern which is used to defer initialization of an object as long as it’s possible
				   
				   EAGER :one time loading/ is a design pattern in which data initialization occurs on the spot
			 
			 </PROXY_EAGER_LAZY>
			 
			 
			 <NOTFOUND>
			             IF resource is not found then then dont throw exception
			 </NOTFOUND>
			 
			 <mapping>
			     
				 <1TO1>
				    
					    >> Seperate entity mapping
						   one class primary key is mapped to anoth class as foreign key
						
						default/unidirectional:primary-foreign key 
						                if data updated on parent then automatically will update child
										traversing in only one direction is possible
						      
							   class UserPan
								@OneToOne
								@JoinColumn(name="USER_PAN_ID")
								PanCard pancard;
							
								  >> It works as Primary-foreign key.
								  >> IN above class	UserPan will use primary key of pancard as foreign key
							  
						bidirectional: @onetoone in both class
						                 use mappedby in parent
										 traversing in both direction is possible
										 
						      >> calss  PanCard
							            @OneToOne
										@JoinColumn(name="USER_ID")
										UserPAN userpan;
										
								 calss	UserPAN
                                        @OneToOne(cascade=CascadeType.ALL,mappedBy="userpan")
                                        PanCard pancard;								 
				 
				 </1TO1>
				 
				 <1TOMANY>
				 
				    @OneToMany --on collection
					@ManyToOne  --on reference
				 
				     Many2One is same as 1TOMany
					  
				     UNIDIRECTIONAL: only using onetomany or  manytoone in entity but not both
					 		
                     BI-DIRECTIONAL: use  @joinColumn(use with @manyToOne) so that no other table will be created by hibernate. 
					               : use mappedBy with @oneToMany
								   : both entity should have @oneToMany and @ManyToOne
								   
						   no owning side: side where mappedby pro used
						   owning side: side where mapped by prop not used(primary key of mapped by entity will be added)
					  >> one record have multiple sub record.
							  e.g. One Cart have many Items.
							  
							  eg. 
							  calss :
									   Student5 
									   @OneToMany(mappedBy="setSTD")
									   Set of Phone phone;
							  
							  class :
										@ManyToOne
										@JoinColumn(name="STD_ID" )
										Student5 setSTD;
                        					 
				 </1TOMANY>
				 
				 <many2MANY>
				 
				       only one way to do manyto many is mapping table
					 
								 @ManyToMany()
								//@JoinColumn(name="VEHICLE_ID")
								List VehicleM2M veh=new ArrayList VehicleM2M();
	
									@ManyToMany(mappedBy="veh")
							   // @JoinColumn(name="USER_ID")
								List UserDetailsM2M user=new ArrayList UserDetailsM2M();
				    
					
				 
				 
				  
				 </many2MANY>
			    
			 
			 
			 </mapping>
			
	 
   
   </ANNOTATION>
   
   <METHOD>
   
         >>   session.save(Entity); insert
		 >>   session.get(Entity.class,primary key id) --from persisted state
		      session.load---> Exception in thread "main" org.hibernate.ObjectNotFoundException: No row with the given identifier exists:
			  
			   1.   get()eraly-eager- loads the data as soon as it’s called whereas load()-lazy returns a proxy object and loads data only when it’s actually required, 
			             so load() is better because it support lazy loading.
               2.   Since load() throws exception when data is not found, we should use it only when we know data exists.
               3.   We should use get() when we want to make sure data exists in the database.
			       
	        
		      update : either through transient state or from persisted state(get)(if you get data from persisted then hiberante will atomatically 
			           update data , no need of save)
		      delete : session.delete()--transfered to transient/ removed from session
		
		
		TRansient: Object before hibernate
		persited: data in hibernate and persited to databse --session.save()
		detached: sesion.close()
		
		>> DETACHED  TO persisted
		 
					 get session
					 get userobject 
					 do some operation
					 sesion.commit
					 session.close
					 
					 get session
					 session.update(previous user);
	  
   </METHOD>
   
   <FETCH_EMBEDED_DATA>
         
		 better to use Native sql/hql/criteria
   
         CRITERIA:
		 
					  Criteria cr=ses.createCriteria(Lion.class);
					  cr.add(Restrictions.eq("animal.name", "Lion"));
					  List Lion ln=cr.list();
			  
	     HQL:
					  String hql="From Lion l where l.animal.name='Tiger'";
					  org.hibernate.Query query=ses.createQuery(hql);
					  List Lion ln=query.list();
			  
		 get/load:
                      Lion lion1=ses.get(Lion.class,anipr );
					  AnimalPr anp=lion1.getAnimPr();
					  Animal an1=lion1.getAnimal();		


         Embeded/Element Collection: 
		              act like one to manyrelationship. 
 		 
		 
	  
	</FETCH_EMBEDED_DATA>
	
	<FETCH_EMBEDED_ELEMENTCOLLECTION_DATA>
	
	     CRITERIA:
		             ses=HibernateConnection.getSession();

					Criteria cr=ses.createCriteria(UserDetails.class);
					cr.add(Restrictions.eq("user_name", "Ram"));
					//cr.add(Restrictions.eq("USER_ADDRESS.street_name", "Sadar"));

					List UserDetails listUd=cr.list();

					listUd.forEach(Ud->
									 {
										  System.out.println("User ID:"+ud.getId());
										System.out.println("User name :"+ud.getUser_name());
										System.out.println("Addre obar :"+ud.getAddset().toArray());
										ud.getAddset().forEach(
													  add->
														   {
															   System.out.println("Street Name :"+add.getStreet_name());
															   System.out.println("Country Name :"+add.getCountry_name());
														   }
														   );
									 }
									 );

	     HQL: 
		 
		        String hql="from UserDetails ud where ud.user_name='Ram'";
                Query query=ses.createQuery(hql);
                List UserDetails listUd=query.list();
	
	
	
	
	</FETCH_EMBEDED_ELEMENTCOLLECTION_DATA>
	  
   <JAVA_ORACLE_HIBERNATE_MAVEN>
   
				    <dependency>
							<groupId>org.hibernate</groupId>
							<artifactId>hibernate-core</artifactId>
							<version>5.2.1.Final</version>
				   </dependency>
				   <dependency>
							<groupId>org.hibernate</groupId>
							<artifactId>hibernate-core</artifactId>
							<version>4.2.3.Final</version>
				   </dependency>
				   
				   <configuration>
				                    Hibernate.cfg.xml
									  <hibernate-configuration>
									  
											   <session-factory>
													   <property name="hibernate.dialect">org.hibernate.dialect.Oracle10gDialect</property>
													   <property name="hibernate.connection.username">system</property>
													   <property name="hibernate.connection.password">maqoracle</property>
													   <property name="hibernate.connection.driver">oracle.jdbc.driver.OracelDriver</property>
													   <property name="hibernate.connection.url">jdbc:oracle:thin:@localhost:1521:xe</property>
													   <property name="show_sql">true</property>
													   <property name="hibernate.hbm2ddl.auto">update</property>
													   <property name="hibernate.jdbc.batch_size">50</property>
												</session-factory>
									 </hibernate-configuration>
					
				   </configuration>
					  	   
   </JAVA_ORACLE_HIBERNATE_MAVEN>
   
   <SPRING_ORACLE_HIBERNATE_MAVEN>
   
   
				<dependency>
				  <groupId>org.springframework</groupId>
				  <artifactId>spring-orm</artifactId>
				  <version>${spring-framework.version}</version>
				</dependency>
				
				<!-- Hibernate -->
					<dependency>
						<groupId>org.hibernate</groupId>
						<artifactId>hibernate-entitymanager</artifactId>
						<version>${hibernate.version}</version>
					</dependency>
					
					<dependency>
						<groupId>org.apache.tomcat</groupId>
						<artifactId>tomcat-dbcp</artifactId>
						<version>7.0.55</version>
					</dependency>

					<dependency>
						<groupId>commons-pool</groupId>
						<artifactId>commons-pool</artifactId>
						<version>1.6</version>
					</dependency>
							
							
					<!-- oracle jar -->
					<dependency>
						  <groupId>oraclejar</groupId>
						  <artifactId>oraclejarA</artifactId>
						  <version>6</version>
					 </dependency>
					 
					 >> For Hibernate.cfg.xml
					 
					 <hibernate-configuration>
						   <session-factory>
						   
						   <property name="hibernate.dialect">org.hibernate.dialect.Oracle10gDialect</property>
						   <property name="hibernate.connection.username">system</property>
						   <property name="hibernate.connection.password">maqoracle</property>
						   <property name="hibernate.connection.driver">oracle.jdbc.driver.OracelDriver</property>
						   <property name="hibernate.connection.url">jdbc:oracle:thin:@localhost:1521:xe</property>
						   <property name="show_sql">false</property>
						   <property name="hibernate.hbm2ddl.auto">none</property>
						   
							 <property name="hibernate.cache.use_secon_level_cache">true</property>
						   <property name="cache.provider_class">org.hibernate.cache.EhCacheProvider</property>

							<property name="hibernate.cache.use_secon_level_cache">true</property>
						   <property name="cache.provider_class">org.hibernate.cache.EhCacheProvider</property>

  
						</session-factory>
				     </hibernate-configuration>
                        
				     
            >> Spring configuration spring-mvc.xml

                      
                <!--Connection pool  -->
							   <bean  id="dataSource" class="org.apache.tomcat.dbcp.dbcp.BasicDataSource">
								   <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"></property>  
								   <property name="url" value="jdbc:oracle:thin:@localhost:1521:xe"></property>  
								   <property name="username" value="system"></property>  
								   <property name="password" value="maqoracle"></property>  
							  </bean> 
		  
		    
				<!--Spring local session factory  -->   
								<bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean">
									
									 <property name="configLocation" value="/WEB-INF/Hibernate.cfg.xml" ></property>
									  <property name="annotatedClasses">
										<list>
											  <value>com.mvc.model.CarUser</value>
										</list>
									  </property>          
								</bean>
	    
				<!-- spring hibernate template -->
								  <bean id="template" class="org.springframework.orm.hibernate4.HibernateTemplate">
										  <property name="sessionFactory" ref="sessionFactory"></property>
										  <property name="checkWriteOperations" value="false"></property>
								  </bean>  
		      
		       <!-- spring hibernate transaction -->
		      
								  <bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager">
										   <property name="sessionFactory" ref="sessionFactory" />
										   <property name="dataSource" ref="dataSource"></property>
								  </bean>
              
               <!--spring DAOImpl DI  --> 
								 <bean id="carUserDaoImpl" class="com.mvc.daoImpl.CarUserDAOImpl">
									   <property name="ht" ref="template"></property>
								 </bean>      			
   
   
   
   
   
   </SPRING_ORACLE_HIBERNATE_MAVEN>
   
   <JAVA_MONGO_HIBERNATE_MAVEN>
   
   
   </JAVA_MONGO_HIBERNATE_MAVEN>
   
   
</Hibernate>

<webservices>
    
	 <readDAILYwebArticleforwebservices/>
	
	<REST>
	         read daily web article and do some practice and refer spring_rest in spring section below
	</REST>
	
	<SOAP>
	
	</SOAP>


</webservices>

<SPRING>
   
   <1_spring_core>
   
		   <NOTE>
		   
				Minimum requirements

				JDK 8+ for Spring Framework 5.x
				JDK 6+ for Spring Framework 4.x
				JDK 5+ for Spring Framework 3.x
				
				Commons.jar
				spring.jar
				spring.core.jar
				spring.context.jar
		   
			   >> DEVELOPED BY  Rod Johnson in 2003
			   >> spring.org////pivotal org
			   >> first name ---interface21
			   >> it is light weighted.....no dependent on Application Server like swing--jvm lib.
			   >> it is loosly coupled....all layers are independent to each other and can be easily plugged and unplugged.
				  >> ejb is heavy weighted----dependent on application server. like awt--os library.
				  >> ejb is tightly coupled---all layers are dependent to each other and very complex for plugging and unplugging resources.
			   
			   >> spring achived loosly copled
					...>by RTP(runtime polymorphism)
					...>by interface
					
					<looseVStightcoupling>
					   
					   Tight coupling:
					                     Means directly creating class onject in class and calling method
									   
												   class Traveler
														{
															Car c=new Car();
															void startJourney()
															{
															   c.move();
															}
														}
														 
														class Car
														{
														  void move()
														  {
															 // logic...
														  }
														}
										 In the above example, Traveler object is depends on car object.  So traveler class creating an object of Car class 
										 inside it [ line number 3 ]
                                         If the other class object is created in the dependent class [ like Car class object in Traveler class ], 
										 there exist tight coupling, it mean if method in car object is changed then we need to do the changes in
										 the Traveler class too so its the tight coupling between Traveler and Car class objects

                       Loose Coupling:										 
						------
										class Traveler
										{
											Vehicle v;
											public void setV(Vehicle v)
											{
											  this.v = v;
											}      
										 
											void startJourney()
											{
											   v.move();
											}
										}

										Interface Vehicle
										{
										   void move();
										}

										class Car implements Vehicle
										{
											public void move()
											{
												 // logic
											}
										}

										class Bike implements Vehicle
										{
											public void move()
											{
												 // logic
											}
										}						
					                   
									   
									    In above example, spring container will inject either Car object or Bike object into the Traveler by calling 
									    setter method, So if Car object is replaced with Bike then no changes are required in Traveler class, this means 
									    there is loose coupling between Traveler and Vehicle object.  Actually setter method will be activated through xml file,
									   
									   
									     bean id="traveler" class="com.test.Traveller">
											 property name="v" ref="bike" />
										 /bean>
										
										 bean id="bike" class="com.test.Car" />
										 bean id="car" class="com.test.Bike" />
									  
					</looseVStightcoupling>
					
					
					
				
				>> in spring model/contrller/service/business/ all layers is desigend using simple POJO class.
				>> spring recommends to use Has-a relation(loose-coupling).

				>> All container IOC---core/J2EE	and MVC--web.....uses xml/java configuraton to configure POJO class.
				
				container::::>> 1.xmlread/configure pojo/create instance/dynamic value to POJO(Dependency Injection)
								2.life cycle of pojo 
				


				<container>
					 
					 IOC: 1.  core------BeanFactory(I)-------------------------XMLBeanFactory(C)
						  2.  j2ee------ApplicationContext(I)
										ConfigurableApplicationContext(I)------ClasspathXMLApplicationContext(C)  ----
						  
					 MVC: 1.  web-------WebApplicationContext(I)---------------WebApplicationContextUtil(C)	  
					 
				</container>	

				>> Resources rs=new ClasspathResources("resource/spring.xml");
				   BeanFactory factory=new XMLBeanFactory(rs);
				   Test test=factory.getBeans("t");
						test.hello();

				>>spring.xml
				   <beans>
					   <bean class="pck.Test" id="t">
					   </bean>

				   </beans>		   
				 
				>> IOC  ---------------------->Test CLAss
					 1.getbeans()
					 2.getbeans()
					 3.getbeans()
					 
					 only one instance will be created per POJO/bean.
					 to create multiple instance change scope---prototype
					 or set singleton="false" in bean configuration file.
					 
					>>web...>request/session/context/prototype/singleton. 
					
					
					container  uses  SAX parser to read XML
					 ------
						1. create instances of POJO
						2. life cycle of POJO
						2. DI into POJO
					
					1. core------ BeanFactory....
							>>   while loading check  xmltag validation
							>>   after request the bean instantiation is done
					
					
					2. j2ee------ApplicationContext------early/load-on-startup/recommended container
							>>   while loading check tag validation
							>>   if scope is singleton  while loading it will instantiniate
							>>   if scoe is prototype will create intanitiate depending on the number of request
							
							
					>>>spring can create object of private constructor classes	outside class	
						
						...>>ClassForName(test.class).newInstances(); will create object only if class and cons are public
						...> to solve this reflection API is used.
						
							 Class cl==Class.forName(Test.class);
							 Constructor cons=cl.getDeclaredConstructor();
								cons.setAccesible(true);
							 Test test=cons.newInstances();		
							 
				 
		   </NOTE>
		   
		   <DI>
			   
			   1. Model>>POJO
					  >>DAO------->  dependency of Driver/jdbc templates/connection pool/session factory
					  >>Business---  dependency of DAO /may require service
					  >>Service---   dependency of TX/JMS/Securirty/Mail/......
			   
			   
			   2. Controller>>POJO
						   dependency of Business	

			   >>here model and controller everthing is POJO class
				  and we can pass value input to these POJO through xml file.
				  And IOC container will read xml and will pass to POJO.

			   >>To receive vlaue form IOc cntainer, A class either have constructor or setters and getters. 	

			   
				>> A class can have any type of dependency injection.
					 >> primitive
					 >> secondry---reference
					 
					 >> primitives arrays
					 >> secondary arrays
					 >> Collections
					 
				<note>
				   
							   In spring... dependencies can be injected in three/3 ways
							   1. contructor
							   2. setter method
							   3. interface/abstract--lookup method
							   
							   by defalut the spring inject dependencies with bydefault constructor if user defined cons is not available or other 
									  property based injector is not used			   

				</note>		
				
				<lifecycle>
				   
							   >> for every module business/service/dao/controller simple PoJo class is enough
							   >>ConfigurableAppicationContext
										>>> here  
										  1. while loading will call all init method
										  2. by closing close() will call all destroy method.
							   
							   
							   >>  Spring bean factory is responsible for managing the life cycle of beans created through spring container. 
							       The life cycle of beans consist of call back methods which can be categorized broadly in two groups:

								      1. Post initialization call back methods
								      2. Pre destruction call back methods
								
							   >>  Spring framework provides following 4 ways for controlling life cycle events of bean:

								      1. InitializingBean and DisposableBean callback interfaces
								      2. Other Aware interfaces for specific behavior
								      3. custom init() and destroy() methods in bean configuration file
								      4. @PostConstruct and @PreDestroy annotations
															   
							   
							   
							   
							  >> A bean life cycle includes the following steps. 
										
										1. Within IoC container, a spring bean is created using class constructor. 
										2. Now the dependency injection is performed using setter method. 
										3. Once the dependency injection is completed, BeanNameAware.setBeanName() is called. It sets the name 
										   of bean in the bean factory that created this bean. 
										4. Now  code>BeanClassLoaderAware.setBeanClassLoader() is called that supplies the bean class loader 
										   to a bean instance. 
										5. Now  code>BeanFactoryAware.setBeanFactory() is called that provides the owning factory to a bean instance. 
										6. Now the IoC container calls BeanPostProcessor.postProcessBeforeInitialization on the bean. Using 
										   this method a wrapper can be applied on original bean. 
										7. Now the method annotated with @PostConstruct is called. 
										8. After @PostConstruct, the method InitializingBean.afterPropertiesSet() is called. 
										9. Now the method specified by init-method attribute of bean in XML configuration is called. 
										10. And then BeanPostProcessor.postProcessAfterInitialization() is called. It can also be used to apply
   										    wrapper on original bean. 
										11. Now the bean instance is ready to be used. Perform the task using the bean. 
										12. Now when the ApplicationContext shuts down such as by using registerShutdownHook() then the method
 										    annotated with @PreDestroy is called. 
										13. After that DisposableBean.destroy() method is called on the bean. 
										14. Now the method specified by destroy-method attribute of bean in XML configuration is called. 
										15. Before garbage collection, finalize() method of Object is called.
																	   
							   Initialization Callbacks:
							   ------------------------
							   
							            1. First @PostConstruct will be called. 
										2. Then InitializingBean.afterPropertiesSet() is called 
										3. And then method specified by bean init-method in XML or initMethod of @Bean in JavaConfig.
							   
							   
							   Destruction Callbacks:
							   ---------------------
							   
							            1. First @PreDestroy will be called. 
										2. After that DisposableBean.destroy() will be called. 
										3. And then method specified by bean destroy-method in XML configuration is called.
							   
							   
							   ==================================================================================================================
							   
							   approach
							   -----
							   1. programatinc....(not recommended way because your bean calls is tightly coupled with spring contaier better to use =init-method/destroy-method)
								   >>   InitilizingBean(I)---afterpropertyset()
								   >>   DisposableBean(I)--destroy()
								   
								              public class Database implements InitializingBean, DisposableBean
													{
														//Other bean attributes and methods
														 String username;
														 String password;
														 
														@Override
														public void afterPropertiesSet() throws Exception
														{
															//Bean initialization code
														}
														 
														@Override
														public void destroy() throws Exception
														{
															//Bean destruction code
														}
													}
								   
								   >> here spring making dependent by imlementing these interface.
								   
									   <bean class="com.program.Database" id="test">
											 <property name="username" value="Maqsood"></property>
							   
											 <property name="password" value="Pass@345"></property>
											 
									   </bean>
								   
							   
							   2. xml 	   
								     >>  any method in POJO to write logic for bean property intilization or modification
								     >>  and inside xml write configure pojo method like init-method/destroy-method
								   
									 
							                   <beans>
 
													<bean id="demoBean" class="com.howtodoinjava.task.DemoBean"
																	init-method="customInit"
																	destroy-method="customDestroy">
													</bean>
												 
												</beans>
																							
												<beans default-init-method="customInit" default-destroy-method="customDestroy">  
 
                                                       <bean id="demoBean" class="com.howtodoinjava.task.DemoBean"></bean>
 
                                                </beans>
								   
								                public class DemoBean
																{
																	public void customInit()
																	{
																		System.out.println("Method customInit() invoked...");
																	}
																 
																	public void customDestroy()
																	{
																		System.out.println("Method customDestroy() invoked...");
																	}
																}
								   
								   
							   3. Annotation(spring 2.5 above)
									  @PostConstruct at init method
									  @PreDestroy  at destroy method

									  >>to activate this annotation you must initilize
												  >>RequiredAnnotationBeanPostProcessor	
									  >> to activate bean life cycle for annotation
											   CommonAnnotationBeanPostProcessor	

												            <bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor">
												            
															</bean>
															
															<bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"></bean>
															
														    <bean class="com.annotaion.Database" id="test">
																   
																   <property name="username" value="Maqsood"></property>
														   
																   <property name="password" value="Pass@345"></property>
														   
														    </bean>
											   
								  >> To configure 100 bean class life cycle configure into main root tag beans   
  								     default-destroy-method="" default-init-method=""  
					   
					   
					   
					      >> @Bean(initMethod=)
		   </lifecycle>
					 
				>>  PRIMITIVE 

					<1_setters>
				 
						 <bean id="msgObj" class="com.bean.Message"  scope="prototype">  
					   
									   <property name="message_id" value="123"></property>  
									   <property name="mesage" value="Hello Spring mesage"></property>  
									   
						 </bean>  
				 
					</1_setters>		
				 
					<2_cons>
						>>if follow order wil assign depending on passed value
						>> if not  want to follow order use "index"
								 
						<bean  id="msgObj" class="com.bean.Message"  scope="prototype">  
							   
							   <constructor-arg type="int" index="0"> 
								  <value>123</value>
							   </constructor-arg>
							   
								<constructor-arg type="String" index="1">
								  <value>Hello MAqsood</value>
							   </constructor-arg>
							  
						</bean>  
				 
					</2_cons>
                      
					 
			        <3_lookupMETHOD_or_method_injection>
			 
							>> in interface all methods are lookup method
							>> in abstrace class all abstract method is lookup methohd
							>> concrete class  if you dnt want implementation of method then it is lookup method.
							
							>> spring will provide runtime implementation to method
							
							>> used if method return reference type/secondry type
							
							>> use if instance is required for every request 
							
							>>to generate runtime proxy use cglib.jar
							
							>> use this to overcome the drawback of 
							   ( prototype bean injected into singleton bean.... ) 
							      here if parent is singleton bean and injected prototype bean then parent bean 
								  will be created only once but child will also get created only once because parent is singleton
								  so prototype will not work.
								  to overcome this issue lookup-method will use
								  
								  here lookup method is abstarct method/interfac method/ concreate method 
								  and this mehtod implementaton will be provided IOC container
								  
								            ApplicationContext actx=new ClassPathXmlApplicationContext("spring.xml");
		                                    Bus bus=(Bus)actx.getBean("bus");
									       
											>> above code will get new instances(Engine) on every request of bus.										   
								  			
								  
							
							<abstract>
							
							      >>  at run time spring will create proxy class for abstract classes
								      and override lookup method.
								   
								      and the declaration of bean in xml file wil return 
									 
									       <bean id="bus" class="com.abstractl.Bus">
												   
												   <lookup-method name="myBusEngine" bean="engine"/>
										   
										   </bean>
										   
										   <bean id="engine" class="com.interfacel.Engine">
											
													<property name="engine_name" value="Tata"></property>
										   
										   </bean>          
							
							</abstract>
				
							<interface>
							   
									>>If an interface have method that returns another class reference then by using lookup spring can generate reference of 
									interface.
								  
									  suppose car is interface and have method that return Engine class reference
								  
										public interface Car 
										{
											   public Engine getCarEngine();
										}
										
										Then in xml
										
										 <!-- for car lookup  -->
										   <bean id="car" class="com.interfacel.Car">
												  <lookup-method name="getCarEngine" bean="engine" />
										   </bean> 
							   
										   <bean id="engine" class="com.interfacel.Engine">
												  <property name="engine_name" value="Swift"></property>
										   </bean>
										
										and in test class by using simply car reference we can get Engine data.
										
							</interface>
							
							<concrete>
								
								        >>if a class has method with implementation then this method can also be lookup and spring will provide 
										  implementation at runtime
										   
										   <bean id="truck" class="com.concrete.Truck">
												 <lookup-method name="myTruckEngine" bean="engine1"/>
										   </bean>
										   
										   <bean id="engine1" class="com.interfacel.Engine">
											      <property name="engine_name" value="Eicher"></property>
										   </bean>   
										   
										   in above bean xml Truck is a class with method "myTruckEngine()" and this method is fully implemented and returning 
										   Engine reference  e.eg
										   
										              public Engine myTruckEngine()
														{
														
															Engine engine=new Engine();
															engine.setEngine_name("Tata truck");
															return engine;
															
														}
										    but if you want to provide implementation at runtime with Engine object means whatever reference of Engine is available 
											that will be bind to myTruckEngine()
											then "lookup-method" used
											
											 <bean id="truck" class="com.concrete.Truck">
												 <lookup-method name="myTruckEngine" bean="engine1"/>
										     </bean>
											
								
							</concrete>
			
			        </3_lookupMETHOD_or_method_injection>
					
				>>  SECONDRY........use instane/reference
					 
					 <note>
					 
							  >>pass by reference 
							  
								<property name="engine " ref="engineObj"></property>
				 
							  
							  >>paas by instance also called inner bean
								  
								  <bean id="carObj" class="com.beans.Car" >
				  
										  <property name="car_name" value="Audi"> </property>
										  <property name="engine " >
												  
												  <bean class="com.beans.Engine"> 
													   <property name="model_name" value="190000Z"></property>
												  </bean>
										  </property>
								  </bean>
						
					</note>
				 
				>>  Primitives arrays
					 
					 <note>
					 
								 <property name="carName" >
										 <list>
											   <value>Audi</value>
											   <value>Pajero</value>
											   <value>royals</value>
										 </list>
								 </property> 
					 
					 
					 </note>
				 
				 
				>> Secondary arrays
				  
					 <note>
					 	  <property name="engine " >
								<list>
									 <ref bean="engObj1"/>
									 <ref bean="engObj2"/>
									 <ref bean="engObj3"/>
							   </list>
					      </property>
					 
					 </note>
					 
					 
				>> Collections
					   
					   <primitivess>
						  
						  >>List.... by default it uses Array List
								  <bean  id="engineObj" class="com.beans.Engine" >  
			   
											   <property name="model_name" >
											   
												 <list>
													<value></value>
													<value></value>
													<value></value>
												 
												 </list>
											   
											   </property>
											  
									</bean>  
						  
						  >>Set... by default  Linkedhashset
						  
									   <bean  id="engineObj" class="com.beans.Engine" >  
						   
														   <property name="model_name" >
														   
															 <set>
																<value></value>
																<value></value>
																<value></value>
															 
															 </set>
														   
														   </property>
											  
									  </bean>  
						  
						  >>MAP...by default  LinkedHash Map
						  
								  <bean  id="engineObj" class="com.beans.Engine" >  
			   
												   <property name="model_name" >
												   
													 <map>
															<entry key="" value=""></entry>
															<entry key="" value=""></entry>
															<entry key="" value=""></entry>
													 
													 </map>
												   
												   </property>
									</bean>  
					   
					   
						   >> in case if List uses different list type like Vector/LinkedArray
							   and set ----treeSet
							   and Map---hashtable
							   
							   to use perticular collectin type  use util declaration
							   
							   LIST...> 
											<util:list list-class="">
												 <value> s</value>
											</util:list>
							  
							  SET....>
							  
										   <util:set set-class="">
												 <value></value>
										   </util:set>
										   
							  MAP ...>
										   <util:map map-class="">
												<entry key="" value=""></entry>
										   </util:map>
										  
										  
							  Properties ...> will store into context scope
										  
										  >>dtd...
												   <props>
														  <prop key="1">123</prop>
												   </props>
										  
										  >>	to read
												  <util:properties location="classpath:resources/drivers.properties">
												  </util:properties>	 
										
					   </primitives>
				  
				 <dependency_checking>
						  
						  >> To make setter dependency mandatory
						  >> must pass value to setter 
						  >> dependency-check
						  >> none(default) /  simple(primitive)  / object (secondary) /all
						  >> disadvantage is mandatory to set all attribute
						  
						  >> for DAO it is not recommended
						  
						  >> depricated in 3.0
						  
						  
						  <primitive>
							 
							 <bean  id="testClPri" class="com.bean.Test"  dependency-check="simple">  
			   
									   <property name="fruits" >
									   
										   <list>
											 <value>Apple</value>
											 <value>Mango</value>
											 <value>Chiku</value>
										   </list>
										   
									   </property>
							 </bean>
							 
						  </primitive>
						  
						  <secondary>
							   
							   <bean  id="testClPri" class="com.bean.Test"  dependency-check="simple">  
			   
								 <property name="engine">
									   
									   <list>
											 <ref bean="engObj1"/>
											 <ref bean="engObj2"/>
											 <ref bean="engObj3"/>
									   </list>
								 </property>	   
							  
							  </bean>  
			   
						  </secondary>
				 
					   >> To over come disadvantages of dependency-check Annotation is used
					   
					   >>@Required --to setter method
						   --to start this annotation it is compulsary to instanite class
						   --RequiredAnnotationBeanPostProcessing
						   
							<bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"></bean>
		    
			              >>if dependency is not configured with @required then it will throw exception during initialization phase
                                   "BeanInitializationException"						  
				 
				 </dependency_checking>
				 
				 <depends_on>
				 
					  >>Apply dependency for class
					  >>A---B--C
					  
					  <bean  id="car" class="com.bean.Car"  depends-on="engine">  
					  </bean>
					  
				 </depends_on>
				 
				 <P_name_space>
				 
					  >>  used to reduce tag from bean xml
					  >>  p-namespace simplifies the setter-based dependency injection code by enabling you to use the parameters to be 
					      injected as attributes of bean definition instead of the nested <property> </property>elements. 
					  >>  For each nested property tag, add an attribute at the bean with name having a format of p:>property-name> and set attribute value 
					      to the value specified in the nested property element.
                         
					  >>  If one of your property is expecting another bean, then you should suffix -ref to your property name while constructing 
						  the attribute name to use in bean definition. For eg, if you property name is address then you should use 
						  attribute name as address-ref	 
					 
					 <bean  id="car" class="com.bean.Car"  depends-on="engine" p:car_name="audi">  
					 </bean>
					 
					 <bean  id="car" class="com.bean.Car"  depends-on="engine" p:engine-ref="engine">  
					 </bean>
	
				 </P_name_space>
				 
				 <C_name_space>
				 
				       >>  c-namespace is similar to p-namespace but used with constructor-based dependency injection code. It simplifies 
					       the constructor-based injection code by enabling you to use the constructor arguments as attributes of bean definition rather 
					       than the nested >constructor-arg> elements.
				 
					   <bean  id="car" class="com.bean.Car"  depends-on="engine" c:car_name="" c:engine-ref="">  
					   </bean> 

				 </C_name_space>
				 
				 <AWARE_INTERFACE>
				 
				           >>> tightly coupled and not follow the inversion of control. 
				           >>> tightly coupled and not follow the inversion of control. 
				               Sometimes it is required that our beans needs to get some information about Spring container and its resources.
                               For example, sometime bean need to know the current Application Context using which it can perform some operations like 
						       loading specific bean from the container in a programmatic way.
                               So to make the beans aware about this, spring provides lot of Aware interfaces.
                               All we have to do is, make our bean to implement the Aware interface and implement the setter method of it.
						  
						  >>   The Aware interface is a mix of callback, listener, and observer design patterns. It indicates that the bean is eligible to be notified by 
						       the Spring container through the callback methods.


						  
						  
						  org.springframework.beans.factory.Aware is the root marker interface.

						  >> All the Aware interfaces which we use are the sub interfaces of the Aware interface.

							Some of the commonly used Aware interfaces are

							1) ApplicationContextAware
							        Bean implementing this interface can get the current application context and this can be used to call any service from
									the application context

							2) BeanFactoryAware
							        Bean implementing this interface can get the current bean factory and this can be used to call any service from 
									the bean factory

							3) BeanNameAware
							        Bean implementing this interface can get its name defined in the Spring container.

							4) MessageSourceAware
							        Bean implementing this interface can get the access to message source object which is used to achieve internationalization

							5) ServletContextAware
							        Bean implementing this interface can get the access to ServeltContext which is used to access servlet context parameters 
							         and attributes

							6) ServletConfigAware
							        Bean implementing this interface can get the access to ServletConfig object which is used to get the servlet 
									config parameters

							7) ApplicationEventPublisherAware
							         Bean implementing this interface can publish the application events and we need to create listener which listen this event.

							8) ResourceLoaderAware
							          Bean implementing this interface can load the resources from the classpath or any external file.
						  
						  

				 </AWARE_INTERFACE>
				 
		   </DI>
		   
		   <autowiring>
			   
			   >> automatic dependency injection
			   >> only secondrry types
			   >> can apply for setters or constructor
			   
			   >> suppose Controller--Business--DAO
					 then  if 100 Controller is used then 100 time we must have to inject Business into Controller.
					 so to avoid writing 100 times injecting dependency we use autowiring.
					 
			   >> autowire="default/byName / byType / Constructor / autodetect / no".
			   >> To apply to all bean then use default-autowire="byType"	in beans root tag.
			   >> to apply to specific bean then use in bean tag.	 
			   >> autowire-candidate="default"

			   <byType>
			   
				  >>   if autowire is applied to any class the IOC will read all parameter and for that parameter if ther is setter paramet then
					   IOC will read as dependent parameter
				   
					   then it will find valid type reference in bean declaration
					   but multiple reference found then will through exception "UnsatisfiedDependencyException"
				   
				   
								bean id="employee" class="com.howtodoinjava.autowire.byType.EmployeeBean" autowire="byType">
									 property name="fullName" value="Lokesh Gupta"/> 
								/bean>
							 
								bean id="department" class="com.howtodoinjava.autowire.byType.DepartmentBean" >
									property name="name" value="Human Resource" />
								/bean>
			   

			   </byType>	   
			   
			   <byName>
				  
				   >> search by type and name(same as in bean xml and pojo class)
				   
				                bean id="employee" class="com.howtodoinjava.demo.beans.EmployeeBean" autowire="byName">
									property name="fullName" value="Lokesh Gupta"/>
								/bean>
							   
								bean id="departmentBean" class="com.howtodoinjava.demo.beans.DepartmentBean" >
									property name="name" value="Human Resource" />
								/bean>
			   
			   </byName>
			   
			   <Constructor>
			   
					>>if constructor dependency used 
					
						        bean id="employee" class="com.howtodoinjava.autowire.constructor.EmployeeBean" autowire="constructor">
									property name="fullName" value="Lokesh Gupta"/>
								/bean>
							  
								bean id="department" class="com.howtodoinjava.autowire.constructor.DepartmentBean" >
									property name="name" value="Human Resource" />
								/bean>
								
						    >>If you are not using autowire="constructor" in bean definition, then pass the constructor-arg as follow:
										  bean id="employee" class="com.howtodoinjava.autowire.constructor.EmployeeBean">
											   property name="fullName" value="Lokesh Gupta"/>
												 constructor-arg>
												   ref bean="department" />
												 /constructor-arg>
										  /bean>
										  
										  public class EmployeeBean
											{
												private String fullName;
												 
												public EmployeeBean(DepartmentBean departmentBean)
												{
													this.departmentBean = departmentBean;
												}
												
												etc....
										    }		
			   
			   </constructor>
			   
			   <autodetect>
				   
				   >>auto detect for setter and getters
				   >>if 100 class used then dnt know what dependent used setter or constructor then go for autodetect .bydefault  byType.
				   
				   >>depricated in spring 4 version
				   
				   >>if class have default constructor and setter method then IOC will use setter dependency
				   
				   >>if param cons and setter method then will go through cons dependency
				   
				   
			   </autodetect>
		   
			   
			   <annotation>
				
					>>@Autowire--byType
					  >>@Qualifier(value="")           -- to remove conflict while using byType
					      @Autowired on properties                --  byType
						  @Autowired on property setters          --  byType
						  @Autowired on constructors              --  constructor
					  
					  
					     --can also be used @Resource/@Inject
					  
					  
							>> to activate above two annotaion must instansite ""
								 <bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor" />
								 
								  >> >>context annotaion config ....get discover registered bean from container
											 <context:annotation-config></context:annotation-config>
							   
							 >>Making autowiring error safe using required=false

										1)If you want to make specific bean autowiring non-mandatory for a specific bean property, use required=”false” attribute in @Autowired annoration

													@Autowired (required=false)
													@Qualifier ("finance")
													private DepartmentBean departmentBean;
													
										2) If you want to apply optional autowiring at global level i.e. for all properties in all beans; use below configuration setting.

												<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor">
													
													<property name="requiredParameterValue" value="false" />
												
												</bean>			
																									
					         >> Excluding a bean from being available for autowiring
							       
									1.	
								        <bean id="finance"      class="com.howtodoinjava.autowire.constructor.DepartmentBean" autowire-candidate="false">
										      <property name="name" value="Finance" />
									    </bean>
							        
									2.  Another option is to limit autowire candidates based on pattern-matching against bean names.
  									    The top-level beans/> element accepts one or more patterns within its ‘default-autowire-candidates‘ attribute
										
										<beans default-autowire-candidates="*Impl,*Dao">
                                         
										 </beans>
							 
							 
							 
							
					>> if class have secondry type dependency then only we should use sterotype annotation.
					 otherwise if it contains  primitive type annotation then we must have to configured manually
									
				
					>>Stero Type
						1. @Component   Indicates that an annotated class is a “component”
							  can be replaced with @Named
						
									   @Component
										public class Car 
										{

											@Resource
											private Engine engine;
										}
											
							
						
						2. @Controller	 Indicates that an annotated class is a “Controller”
						 
						
						3. @Service	     Indicates that an annotated class is a “Service”,
										 originally defined by Domain-Driven Design (Evans, 2003) as “an operation 
										 offered as an interface that stands alone in the model, with no encapsulated state.”
						
						4. @Repository	 Indicates that an annotated class is a “Repository”, originally defined by Domain-Driven Design (Evans, 2003) 
										 as “a mechanism for encapsulating storage, retrieval, and search behavior which emulates a collection of objects”.    
			   
			   
						
				   >>context componet scan
					   used to register bean into container
					   
					   
					  
				   >> to activate 

		 
					<beans xmlns="http://www.springframework.org/schema/beans"
						   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
						   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
						http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd" />
							 
						   
					   
					   
					   just scan call 
					  >> if class have secondry type dependency then only we can use component scan
					  >>  otherwise we ll go for normal bean declaration with Autowired/qualifier.
					  
					  
					  
				  
			   </annotation>
			   
			   <annotationBY_JDK>
				   
				   recommended
				   
				   1.  @Resource -----equivalent to @Autowired
						  bydefault ---byname
				   2.  @Inject   -----equivalent to @Qualifier
						  bydefault ---bytype if same bean have different id type
			   
			   
			   </annotationBY_JDK>
			   
		   </autowiring>
		   
		   <staticDI>
			
				  >>MethodInvokingFactoryMethod
							>>setArguments(objects[] arg)
							>>setStaticMethod(String static method)
							
							 <bean id="car" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"  >
					   
										   <property name="staticMethod" value="com.bean.Car.setCar_name"></property>
										   
											  <property name="arguments" >
												 <list>
												 
												  <value>Audif</value>
												 </list>
											  
											  </property>
							 </bean>
			   
			   
			   </staticDI>
		   
		   <singletonDI_interfaceBean>
		   
			   >>like ResourceBundle  in jre is singleton
			   
			   >>if a class contain dynamic content then it is not recommended to make this class as singleton
				  only static content class should be single otherwise it will be no use every user will overide others data.
				  
			   >> spring can create instnace of private constructor
				   so to avoid this we can throw Exception in constructor
				   
			   >> so other ways to create instance of class is Fatory method.
						  Calendar cl=Calendar.getInstance();
					 <bean id="" class="com.util.Calendar" factory-method="getInstance">

					 </bean>	
					 
			   >> to restrict singleton class to clonable then implement clone interface and throw exception inside clone();
					 
			  >> if factory used with singleton then it will send same class instance and if factory used with factory class then 
			  >> factory classes used to return implementation class
			  
			  >>> to build factory class
				  1. static method  ---no need to implement required class
				  2. instance method
				  3. FactoryBean
			  
			  
			  >> 1. if factory uses static method then
					  logger factory is static factory
				   <bean  class="" factory-method="" >

				   </bean>
				   
				   >>
				   here we uses
				   
					  >> interface "CarStatic" and this interface will be used by other class/vendor like mysql oracle uses connection interface.
						   here for reference we created vendor class like "AudiCarImpl" and "MarutiCarImpl".
					  
					  >> then we write factory class and inside factory class we write 
						   "static method" to return class /"AudiCarImpl" or "MarutiCarImpl"./ reference who implemented our interface "CarStatic".
				   
					   then in xml file first we will have to invoke "MethodInvokingFactoryBean" class to make singleton and use static method for factory
							 then calss declaraton where static method is defined.
							 
							 <bean   class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"  >
					   
										   <property name="staticMethod" value="com.staticA.CarFactoryStatic.setCar_name"></property>
										   
										   <property name="arguments">
											  <list>
												 <value>com.staticA.MarutiCarImpl</value>
											  
											  </list>
										   </property>
											 
										
										</bean>
										
							<bean id="cars" class="com.staticA.CarFactoryStatic" factory-method="getIstance">
						
							 </bean>
							 
									 public class CarFactoryStatic 
									 {
														private static String car_name;
																										
														public static void setCar_name(String car_name) {
															CarFactoryStatic.car_name = car_name;
														}
																										
														public static CarStatic getIstance() throws InstantiationException, IllegalAccessException, ClassNotFoundException
														{
															CarStatic cars=(CarStatic) Class.forName(car_name).newInstance();
															
															return cars;
															
														}										
									 }
									 
									 public class AudiCarImpl implements CarStatic
									 {

														@Override
														public void drive(String speed) {
															// TODO Auto-generated method stub
															
															System.out.println("Audi car driving with speed of ...>"+speed );
															
														}
													}
					

				>> 2. if factory uses instance method then
				
				
						 >> interface "CarInstance" and this interface will bw used by other class/vendor
								   here for reference we created vendor class like "MarutiCar" and "AudiCar".
							  
							  >> then we write factory class and inside factory class we write 
								   "instance method" to return class /"MarutiCarImpl" or "AudiCarImpl"./ reference who implemented our interface "CarStatic".
						   
							   then in xml file first we will have to invoke "MethodInvokingFactoryBean" class to make singleton and use static method for factory
									 then calss declaraton where static method is defined.
				
						 >> hibernate session factory is instance factory
								 <bean  class="" factory-bean="" factory-method="" >

								 </bean>	
				 
				 
						 >>
								<bean id="carF" class="com.single.CarFactory" >
									
										 <property name="car_name" value="com.single.ClientMaruti"></property>
									
								</bean>
								
								<bean id="car" factory-bean="carF" factory-method="getCar">
								
								</bean>
								
								
								                        public class CarFactory
																	{

																		private String car_name;
																		 
																		public void setCar_name(String car_name) {
																			this.car_name = car_name;
																		}
																		
																		private  CarFactory() 
																		{
																			// TODO Auto-generated constructor stub
																		}
																		
																		public  CarInterface getCar() throws InstantiationException, IllegalAccessException, ClassNotFoundException
																		{
																			   System.out.println("inside getCar");
																			
																				return (CarInterface) Class.forName(car_name).newInstance();
																			
																		}
																	}
																	
																	public class ClientAudi implements CarInterface{

																			@Override
																			public void drive(String speed) 
																			{
																				// TODO Auto-generated method stub
																				
																				System.out.println("Audi car is driving with speed of ..>"+speed);
																			
																			}
																		}


						>>  use of Factory class	
							>> used to return interface reference  so factory clss will be client indpendent
							>> hide instatiation login
							>> return into interface result	

						    >> Create interface  with required field method and client must implement this interface
						    >> Then create facory class and depending on input perform client process and return client output.	

				 
				 >>3. FactoryBean(I)
				 
						  >> to make layer independent.
						  >> hide implementation 
						  >> getObject--object
						  >> getObjectType---class
						  >> isSingleton-----boolean		

						 here we create factory class that implement FactoryBean interface and inside get object create instance of required implmented 
						 class that implementd our interface..

						 in our case we created interface	CarInterface then AudiImpl and MarutiImpl  implementd our interface.
						 >>and inside xml file we simply configure factory class and set parameter

						<bean id="carF" class="com.Factory.CarFactory" >
										
		                         <property name="car_name" value="com.Factory.AudiCarImpl"></property>
										
						</bean>				 
						
						public class CarFactory implements FactoryBean
									{
									    private String car_name;
										
										public void setCar_name(String car_name) {
											this.car_name = car_name;
										}
										
										@Override
										public Object getObject() throws Exception 
										{
											// TODO Auto-generated method stub
											Car car=(Car) Class.forName(car_name).newInstance();
											
											return car;
										}

										@Override
										public Class getObjectType() {
											// TODO Auto-generated method stub
											return Car.class;
										}

										@Override
										public boolean isSingleton() {
											// TODO Auto-generated method stub
											return true;
										}

									}
									
									public class MarutiCarImpl implements Car 
									{

											@Override
											public void drive(String speed) 
											{
												// TODO Auto-generated method stub
												System.out.println("Maruti is running with speed of ...>"+speed);
											
											}
										}


										 
		   </singletonDI_interfaceBean>
		   
		   <method_replace>
			   
			    >>  used to override/replace current working method.
			   
				>>> MethodReplacer(interface)
					 .....> public Object reimplement(Object o, Metod m,Object[] param)
				
				>>> write new class with interface and write new code
				>>> add replace-method name="" replace=""/>	 in bean of old class.	
				
				    <bean class="com.bean.Bank" id="bank" >
						   
						   <property name="bank_name" value="Icici"></property>
						   <replaced-method name="calcInt" replacer="newInt"></replaced-method>
				   
				    </bean>
				   
				    <bean class="com.bean.NewInterestImpl" id="newInt">
					  
				    </bean>
				   
				   public class NewInterestImpl implements MethodReplacer
						{

							@Override
							public Object reimplement(Object arg0, Method arg1, Object[] arg2) throws Throwable {
								// TODO Auto-generated method stub
								
								System.out.println("new Interest...>"+15);
								return arg0;
							}

						}
			 
			 </method_replace>
			 
		   <property_TO_class>
			 
				   >>   PropertyPlaceHolderConfigurer(Class)
						   ...>setLocation() 
					  
					  >>IOC will load property file into context
					  >>To read value from context 
						  ${key}
						  
						  
							<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
								 <property name="location" value="car.properties"></property>
							</bean>
					 
		  
							<bean class="com.bean.Car" id="car" >
									   <property name="car_name" value="${carname}"></property>
									   <property name="car_model" value="${carmodel}"></property>
							</bean>
			 
				   >>  Only string data are recommended to put into properties file.
				   
		   </property_TO_class>
			
		   <annotation_used_in_core>
			 
			   @Bean  : declare bean in java class sam like bean declaration in xml.
			   
			   
			   
			   @import : if have multiple spring xml file  then to combine into one xml...import resource="StaffConfig.xml"/> (xml)is used
			             so by loading parent bean all beans from child xml will also be loaded.
						 
						 same can be done in java configuration
						 @import will import other java bean configuration class
						 
			   @Required/dependency-check: used at setter method which makes property to mandatory inject. its a dependency-check
			              if property is not set then it will generate error "BeanInitializationException "
						  RequiredAnnotationBeanPostProcessor is required to use @Required annotation.
						  
				@Configuration:
                                 used to write bean in java class without using xml		

                @PostConscruct   ---to call method bean after loading and property set.
                @PreDestroy         --call method before bean gets destroyed
                                      to use above two annotation "CommonAnnotaionBeanPostProcessor" is required. 	

                 @Autowired      		
                 @Qualifier

				@ComponentScan   --
									 This annotation is used with @Configuration annotation to allow Spring to know the packages to scan for annotated components.
									 @ComponentScan is also used to specify base packages using basePackageClasses or basePackage attributes to scan. If specific packages are not defined, scanning will occur from 
									 the package of the class that declares this annotation.

                @Lazy
                                      This annotation is used on component classes. By default all autowired dependencies are created and configured at startup. 
									  But if you want to initialize a bean lazily, you can use @Lazy annotation over the class. This means that the bean will be created and 
									  initialized only when it is first requested for. You can also use this annotation on @Configuration classes. 
									  This indicates that all @Bean methods within that @Configuration should be lazily initialized.
                 @Value
                                      This annotation is used at the field, constructor parameter, and method parameter level. The @Value annotation indicates a 
									  default value expression for the field or parameter to initialize the property with. As the @Autowired annotation tells Spring 
									  to inject object into another when it loads your application context, you can also use @Value annotation to inject values from a
									  property file into a bean’s attribute. It supports both #{...} and ${...} placeholders.  
									  
			   
			
			
			
			</annotation_used_in_core>
	
		   <internationilaztion>
			 
						  <I18n>
						  
							      >> LANGUAGE SUPORT
							      >>  for multiple language support we must have to create properties file for each laguage support.
								     and that properties file contains unicode char 
						  
						  </I18N>
				  
				  <lOCALIZATION>
				  
						  <L10N>
							  
							  >>BUSUNESS SUPPORT BASED ON LOCAL
						  
						  </L10N>
				  
				  >>use Resource Bundle or /ApplicationCOntxt.getMessage() and pass base proprties file in spring.xml
				   <bean id="messagesource" class="ResourceBindleMesageSource"/>
					 <property name="basename" value="Data"/>
				  
				  </lOCALIZATION>
				  
				  >>in mvc by using taglib this can be done
			 
			 
			 </internationilaztion>
			 
		   <event_handlers>
			 
			      >> for standalone application may useful
			 
		   </event_handlers>
	 
	 </1_spring_core>
	 
   <2_spring_mvc>
   
        >>   spring mvc uses Ioc container "Webapplicationcontext"
		>>   spring mvc provide support to view to controller and remaining model services business are supported by spring IOC core container.
		>>   
				
		>> for designing mvc based application 
		   
		   1. JSP --Model architecture (recommended).
		      
			             1                        2 FRONT controller                            3
			   jsp1---------------------                                              --controller1
			   jsp2---------------------											  --controller2
			   jsp3---------------------   Validation(read and hold into bean)        --controller3
			   jsp4---------------------                                              --controller4
			   jspn---------------------                                              --controllern
			   
			   
			   >> if front controller is jsp then it is                   -----> JSP-Model 1
			   >> if fron controller is servlet then it is                -----> JSP-Model 2---recommended(spring)
			   >> if fron controller is servlet-filter then it is         -----> JSP-Model 3---recommended
			   >> if fron controller uses Tag support then it is          -----> JSP-Model 4
        
		
		      ---FrontController
			         ....DispatcherServlet---request goes from here
					 
					 <servlet>
					           name:s1
					           class:DispathcerServlet
					 </servlet>
					 
					 <servlet_mapping>
					 
					          name:s1
							  url:/login
							  url:/register
							  url:/upate
							  url:/n....
							  
							  url:
					 </servlet_mapping>
					 
					 url...>
					    1. complete char sequence
						2. /*  (recommended for single framework)
						3. *.extension(recommended for multiple framework)  *.do  e.g...>>>>login.st/login.sp
					 
					 
				>> view(html,spring-form )--request goes from Dispatcher servlet  ---then controller ----then back to dispatcher--view
				
				>>To write user defined controler
				   
				   <controller>
				   
				   core(2)
				   ----
				    1. Controller(I) core
					
					      @Ovderide
						  public ModelAndView handle(http re, responce) throws exception
						  {
						      req.getParnmName();
							  
							  MAp===hashMAp;
							  map.put(name,"helle");
							  return newModelView("",map);
						  }
					
					
					
					
					2.>> AbstractController
						  
						  abstract handleRequestInternal()
						  {}
						  its a dependecny cheking we must have to pass value from xml
						   >> viewNAME
						 
						 
						     view controller
							 ---------
									 >>1.paramatablizable view controller   
                                              with  handlerequst/handlerequestInternal()
											  //string viewName;
											  setviewName(viewName);
											  getviewName
											  
									 >>2.UrlFileNameViewController (for simple forword controller)
									          >> JUST for hyperlinkc forword request
											  >>handlerequestInternal()
											     read url action
												 and same action will map to model and view
												 return model and view
												 
												 <a href="hello.do">click for hello jsp</a>
												 here we can also directly give path to hello.jsp
												    but user can read path of jsp
												 to hide path
												 we must go for controller "UrlFileNameViewController"
												 
												 so configure in spring.xml
												 
												  <bean name="hello.do" class="org.springframework.web.servlet.mvc.UrlFilenameViewController"></bean>
     
	                                              this will return model and view "hello" to internalviewressolver
												  
												  then internalviewresolver will search for hello.jsp in configured locaton
												 
											hello.ds can map to hello.jsp	 
											
											----
											urlFIleNAmeViewController
											      handleRequest()
												  
												  handlerRequestInternal()
												  { 
												     /read action (remove slash and extentention)
													 
													 return MNV(action)
												  
												  }
							 
							 --------
							 >>ThrowAwayController(1)
							 
							 
							   >>form data will map to bean 
								 and bean implemt from ThrwAwayControllerInterface
								  
								  execute()
								  {
								           will process and return mnv
								  }
							 
							 commandController
							 -------
							 
							 here controller responsible to store form data(not ds) into defined bean
							 
							 >>1.BaseCommand controller (5)
							      
								  >>setCommandName
							             >>must use spring lib in form jsp
									       and set commandname in form tag
									       then in controller clas setcommandname with vlaue that you saved in jsp
                                  >>setCommandClass(BeanClass for from you created)
								  
								  >>setValidator()
								     >>crate ne class that implemnts Validator interface
									   write validation code inside validate()
									     --inside validate()
										            --fetch Formbean

								  
							      >> setFormView("index") page of validation got error
								     
							         >>2. AbstractFromController--form
									         >>3.simple form controller--form
											     
												 -->onsubmit()
											      
												  
												  
										     >>4.Abstract widget controller--from
									
									 widget
                                      -------									
								     >>5.AbstractCommand controller
							 
							 >>MultiAction Controller
							      >> custom methoh with handlerequest signature
							      >> must write user defined method
					              >> action name and custom method name should be same 
								 
								  
								  >> first control will go to ds and go execute handelrequest
								      here slash and extention will be remove then will be passed
									  /mapped to method.
									  
									  
									  
								    class must implements MultiActionController
									and custom method same as action name
									
							   >> if dnt want to follow action and method name same then
								     will go for view resolver 
									 
									 set inside class that implements MultiActionCOntroller
									 setmethodNameResolver(InternalPathMethodNameResolver)
									 {
									 }
									 and InternalPathMethodNameResolver calss
									     --setprefix("Durga")
										 --setsuffix("cRUD");
										 
										 set in xml
										 bean usercontroler
										    --propertname="methodNameResolver"
											       -bean multiactioncontroller
												        --property supffix/pefix
								  
					
					SteroType
					@Controller
					
					>>> in servlet.xml
					
					    <bean id="/hello.htm" class=""/>
				    
					 >>and to control what to dispaly depending upon controller output
                       InternalViewResolver shuld be configured.

							<beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
									<beans:property name="prefix" value="/WEB-INF/views/" />
									<beans:property name="suffix" value=".jsp" />
							</beans:bean>					   
					 >> and in view by simply using OGNL we can read data came from controller 
					 
                 </controller>
                    
					
					In any controller first must execute handlerequest of controller interfce
					here simply request delegation happen.
					then go to HnadlerequestInternal().
   
   
                 <handler>
				 
				     1. BeanNameUrlHandlerMapping(default class)
					 
					         >>  <bean name="/url-patern.extn" class="ControllerClassName" />
						 
						     >> here dispatcher will send request response to handler mapping along with url 
						          then BeanNameUrlHandlermapping will chek for url name configured in bean and corresponding 
								  controller class will be executed.
							
							
					 
					 2. SimpleUrlHandlerMapping(recommended)
					      to map url to id
						  
						  setMapping(propeerties mapping)
						  {
						  }
						  
						  <bean class="SimpleUrlHandlerMapping">
						      
							  <property name="mappings">
							      
								  <props>
								     <prop key="/hello.ds ">r</prop>
								  </props>
							
							  </property>
							  
						  </bean>
						  
						  <bean id="r" class="controllercalss"/>
						  
					 3. ControllerClassNameUrlHandlerMapping(configure controller class name--if url pattern and controller class name is same / must follow naming convention url and controller)
					       <bean  class="controllerClassNameUrlHandlerMaping"/>
						 

						 <bean class="controlclass"/>
					

					4. CommonsPathMapHandlerMapping
				 
				 </handler>
				 
				 <ViewResolvers>
				    
					      1.InternalResourceViewResolver
					      2.TilesViewResolver
					
				 </ViewResolvers>
				 
				 ---To restirct method in controller to return view add ResponseBody before method and method response will be reflected on browser.
				 
				   (1)             (2)                                                                          (4)
				 >>  view---------->DispatcherServlet(req,res)             >------response/request------>       Controller
				         -----      |                    |                        
							(7)		   |				    |              ---------ModelAndView-----
									   |					|                       (5)
                                 Dispatcher 		  Dispatcher
								 will take 			  will take
								 help of     	      help of							
									   |                    |
									   | (6)                   |(3)
						          ViewResolver          HANDLER Mapping (wiil return controller Name to Dispatcher)
								  
								    
						 
				>> so from controller "ModelAndView" will be return with viewname along with Map objects .
				 >>so by simply viewName returned from Controller dispatcher will not identify which views to select
				    so here DispathcerServlet will use "ViewResolver"
					
			     >>View resolver suggest dispathcer servlet		
				         1. location of view
						 2. extention of view
						 
				  >> spring file ,must be same as dispathcher servlet name configured in web.xml 
					in case to avoide restriction then create spring file as you wish and configured that 
					file name in dispathcher servlet with init param.
					
					or configure with context param and listener
					
					
					<!-- The definition of the Root Spring Container shared by all Servlets and Filters -->
					<context-param>
						<param-name>contextConfigLocation</param-name>
						<param-value>/WEB-INF/spring/root-context.xml</param-value>
					</context-param>
					
					<!-- Creates the Spring Container shared by all Servlets and Filters -->
					<listener>
						<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
					</listener>

					
					<!-- Processes application requests -->
					<servlet>
						<servlet-name>appServlet</servlet-name>
						<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
						<init-param>
							<param-name>contextConfigLocation</param-name>
							<param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
						</init-param>
						<load-on-startup>1</load-on-startup>
					</servlet>
						
					<servlet-mapping>
						<servlet-name>appServlet</servlet-name>
						<url-pattern>/</url-pattern>
					</servlet-mapping>
									   
									  
                  
			>> to load multiple xml first load webinf xml then class path
			
				<init-param>
					<param-name>contextConfigLocation</param-name>
					<param-value>/WEB-INF/mvc-config.xml,classpat:resource/spring.xml</param-value>
				</init-param>
				
				>> this can also be done with context param with listener
				
				  <context-param>
					<param-name>contextConfigLocation</param-name>
					<param-value>classpath:spring/application-config.xml</param-value>
				</context-param>
			   
               >> through @import also multiple xml file can be load into IOC.			   
				
				  
				  
       <form_backup_support>
	      
		  >> used for presentation support
          >> form data we can hold into bean classes
          >> and for Bean it allows validation
          
		  >> supported by using spring TAG library		  
	   
	   
	   
	   </form_backup_support>
	   
	   
	   
	   <controller>
	      
		  1. MultiAction Controller
		           one controller have multiple action
		  
		  2. MultiForm Controller
		           multiple form can be controlled by single controller.
	   
	   </controller>
	   
	   
	   <ANNOTATION>
	   
	          1. @Component
			               annotation marks a java class as a bean so the component-scanning mechanism of spring can pick it up and pull 
						   it into the application context. 
			  
			  2. @Service
			              annotation is also a specialization of the component annotation. It doesn’t currently provide any additional behavior over 
						  the @Component annotation, but it’s a good idea to use @Service over @Component in service-layer classes because it specifies 
						  intent better. Additionally, tool support and additional behavior might rely on it in the future.
			  
              3. @Repository
			              The @Repository annotation is a specialization of the @Component annotation with similar use and functionality. 
						  In addition to importing the DAOs into the DI container, it also makes the unchecked exceptions (thrown from DAO methods) 
						  eligible for translation into Spring DataAccessException.
			  
			  
			  4. @Controller	
			               annotation marks a class as a Spring Web MVC controller. It too is a @Component specialization, so beans marked with it
						   are automatically imported into the DI container. When you add the @Controller annotation to a class, you can use another 
						   annotation i.e. @RequestMapping; to map URLs to instance methods of a class.
						   
			  5. @RequestMapping
                            This annotation is used both at class and method level. The @RequestMapping annotation is used to map web requests onto specific handler 
							classes and handler methods. When @RequestMapping is used on class level it creates a base URI for which the controller will be used. 
							When this annotation is used on methods it will give you the URI on which the handler methods will be executed. From this you can infer 
							that the class level request mapping will remain the same whereas each handler method will have their own request mapping.
							
			  6. @CookieValue
                            This annotation is used at method parameter level. @CookieValue is used as argument of request mapping method. The HTTP cookie is bound to 
							the @CookieValue parameter for a given cookie name. This annotation is used in the method annotated with @RequestMapping.
                            Let us consider that the following cookie value is received with a http request:

                            JSESSIONID=418AB76CD83EF94U85YD34W	

              7. @CrossOrigin
							This annotation is used both at class and method level to enable cross origin requests. In many cases the host that serves JavaScript will be different from 
							the host that serves the data. In such a case Cross Origin Resource Sharing (CORS) enables cross-domain communication. To enable this communication you just need to add 
							the @CrossOrigin annotation.
							By default the @CrossOrigin annotation allows all origin, all headers, the HTTP methods specified in the @RequestMapping annotation and maxAge of 30 min. 
							You can customize the behavior by specifying the corresponding attribute values.

							An example to use @CrossOrigin at both controller and handler method levels is this.


							@CrossOrigin(maxAge = 3600)
							@RestController
							@RequestMapping("/account")
							public class AccountController {

							@CrossOrigin(origins = "http://example.com")
							@RequestMapping("/message")
							  public Message getMessage() {
								  // ...
								}
							 
							@RequestMapping("/note")
								public Note getNote() {
									// ...
								}
							}

							@CrossOrigin(maxAge = 3600)
							@RestController
							@RequestMapping("/account")
							public class AccountController {
							 
							@CrossOrigin(origins = "http://example.com")
							@RequestMapping("/message")
							  public Message getMessage() {
								  // ...
								}
							 
							@RequestMapping("/note")
								public Note getNote() {
									// ...
								}
							}
							In this example, both getExample() and getNote() methods will have a maxAge of 3600 seconds. Also, getExample() will only allow cross-origin requests
							from http://example.com, while getNote() will allow cross-origin requests from all hosts. 							
				
				
              8. @PropertySource("classpath:mysqldatabase.properties")				
							   to load prperties file at class level and value of properties file can be used with class with @Value annotation. 
	   
	   
	          >> ENABLE Annotation:
			                context:component-scan base-package="com.howtodoinjava.demo.service" />
							context:component-scan base-package="com.howtodoinjava.demo.dao" />
							context:component-scan base-package="com.howtodoinjava.demo.controller" /> 
	   
	   </ANNOTATION>
	   
	   <validation_support>
	   
	        <map_request_form_data_to_model>
			
			                   this always gets executed before handler method
							   
							   @Controller
								public class CountryController {
								 
								 @ModelAttribute
								 public Country getCountry(@RequestParam String countryName, @RequestParam  long population)
								 {
								  Country country=new Country();
								  country.setCountryName(countryName);
								  country.setPopulation(population);
								  return country;
								 }
								 @RequestMapping(value = "/addCountry", method = RequestMethod.POST)
								 public String addCountry(@ModelAttribute Country country,ModelMap model) {
								  model.addAttribute("countryName", country.getCountryName());
								  model.addAttribute("population", country.getPopulation());
								  return "countryDetails";
								 }
								}
											  
											
			
	         
			</map_request_form_data_to_model>
	   
	   
	   </validation_support>
	   
	   
	   
	   
	   <internationalization_support>
	   
	   </internationalization_support>
	   
	   <interceptior_support>
	              
				  
				  Sometimes you need to intercept incoming request and do some preprocessing or you need to do it after completion of request.
				  It is very much similar to filters that we use with servlet.
                  There are two ways to use interceptor with Spring MVC.
				  
				  
				  >>HandlerInterceptor Interface :
                                 We can implement HandlerInterceptor interface to use interceptor. It has three methods which we need to implement.

									public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) : 
												  This method is executed before request is handed over to handler method.
												  If you notice it has boolean return type. If this method returns true, then it will go to other interceptors 
												  or to handler method. If this method returns false then this request is handled by interceptor only and
												  we should use response object to send back to client.
												  
									public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,ModelAndView modelAndView) :
												  This method is called when handler method has completed its process but dispatcherServlet is yet process the view.
												  This method can be use to add some model view objects that can be used in view. It can be done by adding 
												  object to modelAndView object.
												  
									public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) : 
												 This method is called after view is render and request is completely processed.
												 
				 >>HandlerInterceptorAdapter class:
					    Issue with HandlerInterceptor is that you need to implement all the methods but if you extend to 
						abstract class called HandlerInterceptorAdapter, you can implement only those method which you want and 
						other methods will have default implementation.
						
						
						public class SampleInterceptor extends HandlerInterceptorAdapter 
						{
 
									 @Override
									 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
									   throws Exception {
									  request.setAttribute("blogName", "java2blog");
									  return true;
									 }
									 
									 @Override
									 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
									   ModelAndView modelAndView) throws Exception {
									  String blogName = (String) request.getAttribute("blogName");
									  // We are adding some modelAndView objects here and will use it in view jsp.
									  modelAndView.addObject("blogName",blogName);
									  modelAndView.addObject("authorName", "Arpit");
									 }
									 
									 @Override
									 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
									   throws Exception {
									  String blogName = (String) request.getAttribute("blogName");
									  String authorName = (String) request.getAttribute("authorName");
									  System.out.println("Request URL::" + request.getRequestURL().toString());
									  System.out.println("Blog name : " + blogName);
									  System.out.println("Author Name : " + authorName);
									 }
						}
						
						
						>> Now when you have created your request handler, it must be declared into spring configuration file so that spring
						  can pass requests to it at appropriate time.

                        >> A handler interceptor is registered to the DefaultAnnotationHandlerMapping bean, which is charged with applying
 						   interceptors to any class marked with a @Controller annotation. You can specify multiple interceptors in 
						   the interceptors property, whose type is an array.
						   
									 bean id="customRequestHandler" class="com.howtodoinjava.demo.handlers.CustomRequestHandler" />
		 
									 bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter" />
										 
									 bean class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping">
										 property name="interceptors">
											 list>
												 ref bean="customRequestHandler" />
											 /list>
										 /property>
									 /bean>
						>> Well, using above approach you handler will be applied on all controllers in your application 		
						
						
						
						Applying HandlerInterceptor Interface to certain URLs only
						--------------------------
						   >> If you want to map your handler to certain URL only then you will have to use  mvc:interceptors>> tag.
						      
							            mvc:interceptors>
											 mvc:interceptor>
												 mvc:mapping path="/somepath_one/*"/>
												 ref bean="customRequestHandler_one" />
											 /mvc:interceptor>
											 mvc:interceptor>
												 mvc:mapping path="/somepath_two/*"/>
												 ref bean="customRequestHandler_two" />
											 /mvc:interceptor>
										 /mvc:interceptors>
						
						
						
						in spring.xml
						
						             <interceptors>
									 
									          <interceptor>
											  
												   <mapping path="/helloworld.html" />
												   
												   <beans:bean class="org.arpit.java2blog.springmvc.interceptor.SampleInterceptor"> </beans:bean>
												   
											  </interceptor>
									 
									 </interceptors>
 
						   
	   
	   
	   
	   
	   </interceptor_support>
	   
	   <view_resolvers>
	   
	   </view_resolvers>
	   
	  
  
   </2_spring_mvc> 
   
   <3_spring_DAO>
   
         Also refer >spring_hibernate>
   
         DATA Access Object
	   >>need to do persistent operation
	     >>file/database/rdbms/nosql/xml/ldap
		 
		BUSINESS-----------------------------DAO

         OJM-for no sql
      		 
        >> help to busiess either show/save/etc data.
		
		>> for implementing DAO must follow interface pattern.
		
		>> used for making application independent of databse vendor.
		
		>.use connection pool
		
		standard DAO
		1. Model (must have property of table) model can have any number of properties and can have business logic  
		2. signature with model
		3. connection pool
		
		    connection pool maintain free and consmed connection map
		    
			   implementation of connection pool;
			   
			   >> maintain 2 Map "FreeMap" "ConsumedMap"
			   
			   Datasource(I)--sun
			
			   BasicDataSource--apache   
			   
						BasicDataSource bds=new BasicDataSource();
						  bds.setclas()
						  bds.seturl;
						  bds.setuser;
						  bds.pas;
						  bds.setmaxA;
						  bds.MinIdle;
						  bds.setwaitTime;
						  
						  bds.getConnection();  to get connection from pool
						  
				   		  
				  
			   DriverManagerDataSource --  spring
			   
			   ComoboPool DataSource   -- mchange
			
			   WebLoginDataSource----weblogic
		
		steps
		-----
		
		1. configure datasource in bean xml
		
		2. create model calss like Student
		
		3. Create DAO interface (method signature)
		     create/update/delete/save/findByID/findByName
			 
	    4. create DAO implementation	
               --create datasource 
			   
	    5. map datasource reference to daoImplementation ds property		   
            

			
      -----> 
	  <jdbc_template>
	       
			   >> No need to handle compiletime exceptions
			   >> compiletime exception convert into runtime DataAccess Exception
			   >> No need to close connection
			   >> All methods are type safe.
		   
	  </jdbc_template>
	  
	  <hibernate_template>
	  
	           >>> inject session factory into hibernate template then se hibernate templateinto DAOImpl
		  
	  </hibernate_template>
	  
	  for baisc CRUD OPERATION
	   >> USE model in signature
      
      for complex CRUD operation
        >>  for use case use method name
        >>  have to create DTO
        >> use DTO as a method arguments
		
		   all commit and rollback should be done by business
		 

      To execute services paralel to business use AOP		
	  
   </3_spring_DAO>
   
   <4_spring_AOP>
   
       Before
	   ------
	      MethodBeforeAdvice
		  
		After
         -- AfterReturningAdvice
        
        Around   >> MethodInterceptor		
        
		whileExceptioon   >>Throws Advise
		
		
		proxy
		         >> To mix business and services and finally business + services + proxy  will be returned to controller.
   
         class ProxyFactoryBean
		 
		keywords
         >>  AOP         >>   aspect(services) oriented programming	
         >>  advice      >>	  service provider	 
		 >>  point cut   >>   condition to execute aspect for business
		          
   
   </4_spring_AOP>
   
   <Spring_Transaction>
   
             >> Transactions are basically units of work (ie changes to something) that are managed as a single operation that can be either committed or 
			    rolled back.
				
				
			 >> The concept of transactions can be described with the following four key properties described as ACID -

						Atomicity -
           						     A transaction should be treated as a single unit of operation, which means either the entire sequence of 
									 operations is successful or unsuccessful.

						Consistency -
    						          This represents the consistency of the referential integrity of the database, unique primary keys in tables, etc.

						Isolation - 
						              There may be many transaction processing with the same data set at the same time. Each transaction should 
									  be isolated from others to prevent data corruption.

						Durability - 
						              Once a transaction has completed, the results of this transaction have to be made permanent and cannot 
									  be erased from the database due to system failure.	
										
										
				
				
				
			>> Spring framework provides an abstract layer on top of different underlying transaction management APIs.
 			   Spring's transaction support aims to provide an alternative to EJB transactions by adding transaction capabilities to POJOs. 
			   Spring supports both programmatic and declarative transaction management. EJBs require an application server,
			   but Spring transaction management can be implemented without the need of an application server.	
             
			
			>> Local vs. Global Transactions
                              >> Local transactions are specific to a single transactional resource like a JDBC connection, 
							     whereas global transactions can span multiple transactional resources like transaction in a distributed system.

                              >> Local transaction management can be useful in a centralized computing environment where application components 
							     and resources are located at a single site, and transaction management only involves a local data manager 
								 running on a single machine. Local transactions are easier to be implemented.

                              >> Global transaction management is required in a distributed computing environment where all the resources 
							     are distributed across multiple systems. In such a case, transaction management needs to be done both 
								 at local and global levels. A distributed or a global transaction is executed across multiple systems, 
								 and its execution requires coordination between the global transaction management system and all the local 
								 data managers of all the involved systems. 
			 
			>> Spring Transactions
                 			are designed to give you fine grained control of all your transactional resources while abstracting away 
			                the often messy coding required to co-ordinate the transactions.
							
		    >> Spring supports two types of transaction management:

            <Programmatic_transaction_management> 
			
		                                  This means that you have to manage the transaction with the help of programming. That gives you extreme flexibility, 
										  but it is difficult to maintain.
										  
            </Programmatic_transaction_management> 
			
            <Declarative_transaction_management>
			
                              			 This means you separate transaction management from the business code. You only use annotations or XML based
										 configuration to manage the transactions.	
                             
							 
							 >>  specify in xml--> tx:annotation-driven> 
							             
										  >> for Spring Transactional @Transactional

										 
    		</Declarative_transaction_management>


             >> DataSourceTransactionManager --  JDBC
             >> HibernateTransactionManager  --  HIBERANTE			 
   
   
   
   </Spring_Transaction>
   
   <Spring_JDBC_TEMPLATE>
   
   
       <INFO>
	      
					  Spring JdbcTemplate is a powerful mechanism to connect to the database and execute SQL queries. It internally uses JDBC api, 
					  but eliminates a lot of problems of JDBC API.
					  
		  
		  
	   </INFO>
	   
	   <Problems_of_JDBC_API>
	   
				 The problems of JDBC API are as follows:

				 1.  We need to write a lot of code before and after executing the query, such as creating connection, statement, closing resultset, connection etc.
				 2.  We need to perform exception handling code on the database logic.
				 3.  We need to handle transaction.
				 4.  Repetition of all these codes from one to another database logic is a time consuming task.
   
       </Problems_of_JDBC_API>
	   
	   <Advantage_of_Spring_JdbcTemplate>
	   
           Spring JdbcTemplate eliminates all the above mentioned problems of JDBC API. 
		   It provides you methods to write the queries directly, so it saves a lot of work and time.
   
       </Advantage_of_Spring_JdbcTemplate>
	   
	   <Spring_dbc_Approaches>
	   
					Spring framework provides following approaches for JDBC database access:

					1. JdbcTemplate
					2. NamedParameterJdbcTemplate
					3. SimpleJdbcTemplate
					4. SimpleJdbcInsert and SimpleJdbcCall
					
		 </Spring_dbc_Approaches>			

   
   </Spring_JDBC_TEMPLATE>
   
   <spring_mybatis>
   
   
   </spring_mybatis>
   
   <spring_hibernate>
             
		  >> for connection pool use basicdatasource with spring 4 and hibernate 4	 
          
          <configuration_xml>
		  
						   context:component-scan base-package="com.javacodegeeks.snippets.enterprise.*" 

						   tx:annotation-driven
			   

						   bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">

										property name="driverClassName" value="com.mysql.jdbc.Driver" />

										property name="url" value="jdbc:mysql://localhost:3306/test" />

										property name="username" value="root" 

										property name="password" value="root" 

						  /bean>

			 

							  bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean">
								property name="dataSource" ref="dataSource"> /property>

								 property name="annotatedClasses">

										list>

											value>com.javacodegeeks.snippets.enterprise.model.Employee value>

										/list>

									/property>

								property name="hibernateProperties">

										  props>

												prop

												 key="hibernate.dialect">org.hibernate.dialect.MySQL5Dialect prop>

												prop key="hibernate.show_sql">true prop>

										  /props>

								/property>
							  /bean>

			   
							  bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager">

								property:sessionFactory-ref="sessionFactory"

							  /bean>
							  
							  
					  >> set hibernteTemplate/sessionFactory in any class where it required		  

             </configuration_xml>
			
          <configuration_Program>
		     
			    There are multiple ways to implement
			    
				1.  
							
							 a.  write class for HibernateConfig with annotation:
										@Configuration                              -- tells spring container to search @Bean and rogister
										@EnableTransactionManagement                -- for transaction management(progrmatically and declarative)
									public class HibernateConfig
									{
									
									}
										
							 b.  write method as @Bean like :
									 @Bean 
									 public LocalSessionFactoryBean localSessionFactory()
									{
										LocalSessionFactoryBean factoryBean = new LocalSessionFactoryBean();
										 sessionFactory.setHibernateProperties(hibernateProperties());
										  sessionFactory.setAnnotatedClasses(User1.class);
										return factoryBean;
									 }
									 
							 c. write method for connection pooling 	

										   @Bean
											public DataSource dataSource() {
												BasicDataSource dataSource = new BasicDataSource();
												dataSource.setDriverClassName("com.mysql.jdbc.Driver");
												dataSource.setUrl("jdbc:mysql://localhost:3306/test");
												dataSource.setUsername("root");
												dataSource.setPassword("root");
												return dataSource;
											}					 
							 d. write method for transaction mangement
							 
										  @Bean
											public HibernateTransactionManager getTransactionManager() {
												HibernateTransactionManager transactionManager = new HibernateTransactionManager();
												transactionManager.setSessionFactory(getSessionFactory().getObject());
												return transactionManager;
											}
				             e. write method for hibernate property
							             
										 public Properties hibernateProperties() 
												{
													        Properties prop=new Properties();			   
															prop.setProperty("hibernate.dialect", "org.hibernate.dialect.Oracle10gDialect");
														   // prop.setProperty("hibernate.connection.username", "system");
														   // prop.setProperty("hibernate.connection.password", "maqoracle");
															prop.setProperty("hibernate.connection.driver", "oracle.jdbc.driver.OracleDriver");
															prop.setProperty("hibernate.connection.url", "jdbc:oracle:thin:@localhost:1521:xe");
															prop.setProperty("show_sql", "true");
															prop.setProperty("hibernate.hbm2ddl.auto", "update");
															prop.setProperty("hibernate.cache.use_secon_level_cache", "true");
															prop.setProperty("cache.provider_class", "org.hibernate.cache.EhCacheProvider");
													  
															return prop;
												}



							 
				             f. now use sessionFactory in DAOImpl class As @Autowired
							 
							 g. list all annotaton based class in spring.xml 
							                  mvc:annotation-driven />
											  context:component-scan base-package="com.test.hibernate.config" /> 
											  context:component-scan base-package="com.test.config" />

                             h.  set username and password weather in datasource or hibernate property											  
   
							      
					     --------
						 
                 2.    follow same approach as in 1 but  instead of writting method for hibernate properties we can wirte seperate 
                                   Hibernate.cfg.xml and use with sessionFactory
								   sessionfactory.setConfigLocation(context.getResource("classpath:spring/Hibernate.cfg.xml"));
        
		  </configuration_Program>		  
			 
		  <Repository> 	
                   
				   use this when simple query on database is required like simple Crud operation.
				   but for complex query go through normal Hibernate template or session factory DAO.
				   
				   
          </Repository>		 
			 
   </spring_hibernate>
   
   <spring_rest>
       
	   REST ::: Representatonal state transfer
	   
	   >> it uses URI to expose business logic
	   >> JAX-RS is the java api for restfull webservices
	   >> REST permits different data format such as Plain text, HTML, XML, JSON etc.
	   
	   <rest_principle>
	   
	       Fundamental REST Principles
					Client-Server Communication

					              Client-server architectures have a very distinct separation of concerns. All applications built in the RESTful 
								  style must also be client-server in principle.

					Stateless

					               Each client request to the server requires that its state be fully represented. The server must be able 
								   to completely understand the client request without using any server context or server session state. 
								   It follows that all state must be kept on the client.

					Cacheable

					              Cache constraints may be used, thus enabling response data to be marked as cacheable or not-cacheable. 
								  Any data marked as cacheable may be reused as the response to the same subsequent request.

					Uniform Interface

					              All components must interact through a single uniform interface. Because all component interaction occurs via this interface,
								  interaction with different services is very simple. The interface is the same! This also means that implementation changes
								  can be made in isolation. Such changes, will not affect fundamental component interaction because the uniform interface is always unchanged. One disadvantage is that you are stuck with the interface. If an optimization could be provided to a specific service by changing the interface, you are out of luck as REST prohibits this. On the bright side, however, REST is optimized for the web, hence incredible popularity of REST over HTTP!

					The above concepts represent defining characteristics of REST and differentiate the REST architecture from other architectures like web services. It is useful to note that a REST service is a web service, but a web service is not necessarily a REST service.
						   
		</rest_principle>	
		
		<rest_guidelines>
		       
			   >> in clinet server architecure all data at server side in resource
			   >> client can read write resources at server side through URI.
			   >> client receives resource responce in "Representaton of resources + Additional Information".
			   >> every request by client is URI. and server should must handle all URI request.
		</rest_guidelines>
		
		<richardsan_maturity_model_for_rest>
		
		    fullly rest=   uri+htttp methods+hateos
				
		    LEVEL 0  :
			
			              message...everything in xml
			
			LEVEL 1  :
			              USE OF uri 
			
			LEVEL 2  :
			           
			              use of URI+http method
			
			LEVEL 3   :
			
			              use of URI_httm method+ HATEOAS
			           
		</richardsan_maturity_model_for_rest>
		
	   >> In Rest based design, resources are being manipulated using a common set of verbs.

				To Create a resource : HTTP POST should be used
				To Retrieve a resource : HTTP GET should be used
				To Update a resource : HTTP PUT should be used
				To Delete a resource : HTTP DELETE should be used
				
	   >> Often Rest based Web services return JSON or XML as response, although it is not limited to these types only.
 	       Clients can specify (using HTTP Accept header) the resource type they are interested in, and server may return the resource , 
		   specifying Content-Type of the resource it is serving. 	

       >> This is what our REST API does:

						GET request to /api/user/ returns a list of users
						GET request to /api/user/1 returns the user with ID 1
						POST request to /api/user/ with a user object as JSON creates a new user
						PUT request to /api/user/3 with a user object as JSON updates the user with ID 3
						DELETE request to /api/user/4 deletes the user with ID 4
						DELETE request to /api/user/ deletes all the users 		   
	   <example_1>
	   
	        >>@RestController
              public class HelloWorldRestController 
			  {
			        
					
					    >>   
							 @Autowired
                             UserService userService;  //Service which will do all data retrieval/manipulation work
 
     
								//-------------------Retrieve All Users--------------------------------------------------------
								
								
								
								@RequestMapping(value= {"/","/get","/list"},method=RequestMethod.GET,produces="application/json")
								@ResponseBody
								public List RestUser> getAllUser(Model model)
								{
									  System.out.println("in getUser");
									
									  List RestUser> listUser=userRestDAO.getAllUser();
									  model.addAttribute("userlist", listUser);
									 
									  System.out.println("out getUser");
									 
									 return listUser;
								}
								 
								@RequestMapping(value = "/user/", method = RequestMethod.GET)
								public ResponseEntity List User>> listAllUsers() 
								{
										List User> users = userService.findAllUsers();
										if(users.isEmpty()){
											return new ResponseEntity List User>>(HttpStatus.NO_CONTENT);//You many decide to return HttpStatus.NOT_FOUND
										}
										return new ResponseEntity List User>>(users, HttpStatus.OK);
								}
							 
							 
								//-------------------Retrieve Single User--------------------------------------------------------
								 
								@RequestMapping(value = "/user/{id}", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
								public ResponseEntity User> getUser(@PathVariable("id") long id) 
								{
										System.out.println("Fetching User with id " + id);
										User user = userService.findById(id);
										if (user == null) {
											System.out.println("User with id " + id + " not found");
											return new ResponseEntit  User>(HttpStatus.NOT_FOUND);
										}
										return new ResponseEntity User>(user, HttpStatus.OK);
								}
							 
     
     
								//-------------------Create a User--------------------------------------------------------
								 
								@RequestMapping(value = "/user/", method = RequestMethod.POST)
								public ResponseEntity Void> createUser(@RequestBody User user,    UriComponentsBuilder ucBuilder) 
								{
											System.out.println("Creating User " + user.getName());
									 
											if (userService.isUserExist(user)) {
												System.out.println("A User with name " + user.getName() + " already exist");
												return new ResponseEntity Void>(HttpStatus.CONFLICT);
											}
									 
											userService.saveUser(user);
									 
											HttpHeaders headers = new HttpHeaders();
											headers.setLocation(ucBuilder.path("/user/{id}").buildAndExpand(user.getId()).toUri());
											return new ResponseEntity Void>(headers, HttpStatus.CREATED);
								}
							 
								 
								//------------------- Update a User --------------------------------------------------------
								 
								@RequestMapping(value = "/user/{id}", method = RequestMethod.PUT)
								public ResponseEntity User> updateUser(@PathVariable("id") long id, @RequestBody User user) 
								{
											System.out.println("Updating User " + id);
											 
											User currentUser = userService.findById(id);
											 
											if (currentUser==null) {
												System.out.println("User with id " + id + " not found");
												return new ResponseEntity User>(HttpStatus.NOT_FOUND);
											}
									 
											currentUser.setName(user.getName());
											currentUser.setAge(user.getAge());
											currentUser.setSalary(user.getSalary());
											 
											userService.updateUser(currentUser);
											return new ResponseEntity User>(currentUser, HttpStatus.OK);
								}
							 
								//------------------- Delete a User --------------------------------------------------------
								 
								@RequestMapping(value = "/user/{id}", method = RequestMethod.DELETE)
								public ResponseEntity User> deleteUser(@PathVariable("id") long id) 
								{
												System.out.println("Fetching and Deleting User with id " + id);
										 
												User user = userService.findById(id);
												if (user == null) {
													System.out.println("Unable to delete. User with id " + id + " not found");
													return new ResponseEntity User>(HttpStatus.NOT_FOUND);
												}
										 
												userService.deleteUserById(id);
												return new ResponseEntity User>(HttpStatus.NO_CONTENT);
								}
							 
     
								//------------------- Delete All Users --------------------------------------------------------
								 
								@RequestMapping(value = "/user/", method = RequestMethod.DELETE)
								public ResponseEntity User> deleteAllUsers() 
								{
												System.out.println("Deleting All Users");
										 
												userService.deleteAllUsers();
												return new ResponseEntity User>(HttpStatus.NO_CONTENT);
								}

               }
          </example_1>
		  	  	  
	   <annotation_note>
	   
	   
	          5. @RequestMapping
                            This annotation is used both at class and method level. The @RequestMapping annotation is used to map web requests onto specific 
							handler 
							classes and handler methods. When @RequestMapping is used on class level it creates a base URI for which the controller will 
							be used. 
							When this annotation is used on methods it will give you the URI on which the handler methods will be executed. From this you 
							can infer 
							that the class level request mapping will remain the same whereas each handler method will have their own request mapping.
							
			  6. @CookieValue
                            This annotation is used at method parameter level. @CookieValue is used as argument of request mapping method. The HTTP cookie 
							is bound to 
							the @CookieValue parameter for a given cookie name. This annotation is used in the method annotated with @RequestMapping.
                            Let us consider that the following cookie value is received with a http request:

                            JSESSIONID=418AB76CD83EF94U85YD34W	

              7. @CrossOrigin
							This annotation is used both at class and method level to enable cross origin requests. In many cases the host 
							that serves JavaScript will be different from 
							the host that serves the data. In such a case Cross Origin Resource Sharing (CORS) enables cross-domain communication.
							To enable this communication you just need to add 
							the @CrossOrigin annotation.
							By default the @CrossOrigin annotation allows all origin, all headers, the HTTP methods specified in the @RequestMapping annotation
							and maxAge of 30 min. 
							You can customize the behavior by specifying the corresponding attribute values.

							An example to use @CrossOrigin at both controller and handler method levels is this.


							@CrossOrigin(maxAge = 3600)
							@RestController
							@RequestMapping("/account")
							public class AccountController {

							@CrossOrigin(origins = "http://example.com")
							@RequestMapping("/message")
							  public Message getMessage() {
								  // ...
								}
							 
							@RequestMapping("/note")
								public Note getNote() {
									// ...
								}
							}

							@CrossOrigin(maxAge = 3600)
							@RestController
							@RequestMapping("/account")
							public class AccountController {
							 
							@CrossOrigin(origins = "http://example.com")
							@RequestMapping("/message")
							  public Message getMessage() {
								  // ...
								}
							 
							@RequestMapping("/note")
								public Note getNote() {
									// ...
								}
							}
							In this example, both getExample() and getNote() methods will have a maxAge of 3600 seconds. Also, getExample() will only allow
							cross-origin requests
							from http://example.com, while getNote() will allow cross-origin requests from all hosts. 							
								   
	            8. @RestController : 
				            First of all, we are using Spring 4's new @RestController annotation. This annotation eliminates the need of annotating 
							each method with @ResponseBody. Under the hood, @RestController is itself annotated with @ResponseBody, and can be considered
							as combination of @Controller and @ResponseBody.

                9. @RequestBody : 
				             If a method parameter is annotated with @RequestBody, Spring will bind the incoming HTTP request 
							 body(for the URL mentioned in @RequestMapping for that method) to that parameter. While doing that, 
							 Spring will [behind the scenes] use HTTP Message converters to convert the HTTP request body into domain object 
							 [deserialize request body to domain object], based on ACCEPT or Content-Type header present in request.

                10. @ResponseBody : 
				              If a method is annotated with @ResponseBody, Spring will bind the return value to outgoing HTTP response body. 
							  While doing that, Spring will [behind the scenes] use HTTP Message converters to convert the return value to HTTP 
							  response body [serialize the object to response body], based on Content-Type present in request HTTP header.
							  As already mentioned, in Spring 4, you may stop using this annotation.

                11. ResponseEntity
                   				is a real deal. It represents the entire HTTP response. Good thing about it is that you can control anything that goes into it.
								You can specify status code, headers, and body. It comes with several constructors to carry the information you want
								to sent in HTTP Response.

                12. @PathVariable 
				                This annotation indicates that a method parameter should be bound to a URI template variable [the one in '{}'].
								
                13.@JsonProperty("student_name")
				                  to change property name on model/or any property.
								  
				14. @JsonPropertyOrder({"col5","col3","col9"})	
				                  >> add annotation above model class
								  >>to add on order
								  
				15. @JsonIgnoreProperties("col6")
                                >> add annotation above model class
								>> To remove property from response list
                 
                16. @RequestParam: 
				                 This annotation represents a specific request parameter, in our example, we map a request parameter called key 
				                 to an argument key of type String.
                                    @RequestMapping(value = "/pay", method = RequestMethod.POST)
                                    public BaseResponse pay(@RequestParam(value = "key") String key, @RequestBody PaymentRequest request) 
									{
											----
									}		
               	17. @JsonInclude(JsonInclude.NOT_NULL)			
                                    remove  key with null values.

                        Basically, @RestController , @RequestBody, ResponseEntity and @PathVariable are all you need to know to implement a REST API in Spring 4.
				        Additionally, spring provides several support classes to help you implement something customized.

                        MediaType : With @RequestMapping annotation, you can additionally, specify the MediaType to be produced or consumed 
			           (using produces or consumes attributes) by that particular controller method, to further narrow down the mapping.
				  
				  
				18. content-type: tells server that cleint sending what type of data .
				
				19. send response with status code.
				            return new ResponseEntity(HttpStatus.CREATED);
				
				20. send data as body alon with status code
				            return new ResponseEntity String>("Created",HttpStatus.CREATED);

				21. send customized headers
				             return new ResponseEntity String>("Created",headers,HttpStatus.CREATED);
				
				22. @RequestParam Map String,String> requestParams
				                tp get all param into map
				
				23. to upload file
                                    @ResponseBody
									public ResponseEntity ?> uploadFile(@RequestParam("file") MultipartFile uploadfile)
											{ 				
	                                                 ....
                                            } 

											
				24. to upload multiple file
				                         // 3.1.2 Multiple file upload
											@PostMapping("/api/upload/multi")
								             public ResponseEntity ?> uploadFileMulti(  @RequestParam("extraField") String extraField,
											                                            @RequestParam("files") MultipartFile[] uploadfiles
																					  ) 
													{
													  ....
													}
				
                25. to map html form to  model

										@PostMapping("/api/upload/multi/model")
										public ResponseEntity ?> multiUploadFileModel(@ModelAttribute UploadModel model) 
										{
                                              .....
                                         }											  
													
				
	   </annotation_note>
	   
	   <HATEOAS>
	   
	             >> hypertext/hypermedia as the engine of application state.
	             >> can not it be allways.
				 >> add hateoas jar
				 
				 <jar>
				 
							<dependency>
										<groupId>org.springframework.hateoas</groupId>
										<artifactId>spring-hateoas</artifactId>
										<version>0.24.0.RELEASE</version>
						   </dependency>
       
						   <dependency>
								<groupId>org.springframework.plugin</groupId>
								<artifactId>spring-plugin-core</artifactId>
								<version>1.2.0.RELEASE</version>
							</dependency>
		
				 </jar>
				 
				 >> 
				      In a Spring HATEOAS project, we don’t need to either look up the Servlet context nor concatenate the path variable to the base URI. 
					  Spring HATEOAS offers three abstractions for creating the URI –
					      1. ResourceSupport, ---extend into model
					      2. Link 
						  3. ControllerLinkBuilder. 
						          ---create
						            A. direct link
									    	
                                             Link link = new Link("http://localhost:8080/spring-security-rest/api/customers/10A");
									
						            B. customized link 
									
									            Link selfLink = linkTo(RestController.class).slash("/rest/hateoas/user/").
	    			                                       slash(restuser.getUser_no()).
	    			                                       withSelfRel();													   
									                    restuser.add(selfLink);	
                                    C. mothod link
														   
						                        final Link ordersLink = linkTo(methodOn(CustomerController.class).
												                                 getOrdersForCustomer(customerId))
																				 .withRel("allOrders");
                                                 customer.add(ordersLink);
						  
					      
					  These are used to create the metadata and associate it to the resource representation.
	   
	            <note>
                          create link with respect to method path
						  eg.  if method
						           @RequestMapping(value= {"/rest/user/{}"},method=RequestMethod.GET,produces="application/json")
								   then crete link that matches above mapping so that created link should work.  

								   
								   final Link ordersLink = linkTo(methodOn(CustomerController.class).
												                                 getOrdersForCustomer(customerId))
																				 .withRel("allOrders");
								   
                 </note>				
	   
	            <example>
			
				                        @RequestMapping(value= {"/rest/hateoas/user/all/"},method=RequestMethod.GET,produces="application/json")
										@ResponseBody
										public Resources RestUser>   getAllUserHateoas(UriComponentsBuilder ucBuilder)
										{
															System.out.println("inside getAllUserHateoas");
														
															//  get list of user											
															List RestUser> listuser=userRestDAO.getAllUser();											
															 listuser.forEach(restuser->
															  {
																  System.out.println("in foreach lambdat");
																  Link selfLink = linkTo(RestController.class).slash("/rest/user/").
																											   slash(restuser.getUser_no()).
																											   withSelfRel();
																  restuser.add(selfLink);
																  
															  });
															
															 Link link = linkTo(RestController.class).withSelfRel();
															 return new Resources RestUser> (listuser,link);										
										}
													
				</example>
	   
	   
	   </HATEOAS>
	   
	   <for_xml>
	      
		        >> To get reponse in json/xml from server then its client reponsibility to send request with header accept="application/json"
		           and do not add consume and produce type in method
		 
		        >> To restrict method to produce specific responce and consume specific request
		           add method with method ..    produces="application/json" consumes="application/json"//produces="application/xml" consumes="application/xml"
		  
		  
			  <input_xml_output_json>
			  
			  </input_xml_output_json>
			  
			  <input_json_output_xml>
			  
			  </input_json_output_xml>
		  
		  
	   </for_xml>
	   
	   <test>
	   
	      <1_create_record>
		   
		   
		        >> write method with methodtype=POST and produces="application/json" ,consumes="application/json"
				>> add method param @RequestBody RestUser restUser,-- map user entered value/body to model class
				>> perform operation and update record in database
				>> return string or ResponseEntity--with modified response
				
		   
							@RequestMapping(value= {"/user/add"},method=RequestMethod.POST,produces="application/json" ,consumes="application/json")
							@ResponseBody
							public ResponseEntity RestUser> createUser(@RequestBody RestUser restUser, UriComponentsBuilder ucBuilder)
							{
								 System.out.println("in createUser controller");
								 								 
								 if (userRestDAO.isUserExist(restUser.getUser_no())) 
								 {
										System.out.println("A User with user num " + restUser.getUser_no()+ " already exist");
										return new ResponseEntity(HttpStatus.CONFLICT);
								 }
								
									userRestDAO.createUser(restUser);

									HttpHeaders headers = new HttpHeaders();
									headers.setLocation(ucBuilder.path("/add/{userNO}").buildAndExpand(restUser.getUser_no()).toUri());
									
									System.out.println("out createUser ");
									 
									return new ResponseEntity(headers, HttpStatus.CREATED);
								 
							}
		   
		  
		  </1_create_record>
		  	      
		  <2_get_record_json_xml>
		  
		  
		  
		                      1. write method with methodtype=GET and produces="application/json" or xml
							  2. fetch pathVariable and maped to method param
							  3. perform operation and get record and return as list
		  
							    @RequestMapping(value= {"/","/get","/list"},method=RequestMethod.GET,produces="application/json")
								@ResponseBody
								public List RestUser> getAllUser(Model model)
								{
									  System.out.println("in getUser");
									
									  List RestUser> listUser=userRestDAO.getAllUser();
									  model.addAttribute("userlist", listUser);
									 
									  System.out.println("out getUser");
									 
									 return listUser;
								}
								
								@RequestMapping(value= {"/user/{user_num}"},method=RequestMethod.GET,produces="application/json")
								@ResponseBody
								public List RestUser> getUserByNum(@PathVariable("user_num") int user_num, Model model)
								{
									  System.out.println("in getUserByNum");
									  List RestUser> listUser=new ArrayList RestUser>();
											  
									  listUser.add(userRestDAO.getUserByNo(user_num));
									 
									  System.out.println("out getUserByNum");
									 
									 return listUser;
								}
		  
		  
		  </2_get_record_json_xml>
		  
		  <3_update_record>
		  
		                   1. write method with method PUT and produces="application/json",consumes="application/json"
						   2. map user request body to model using @RequestBody RestUser restUser
						   3. check/perform operation and update
						   4. send response string/updated list
		  
		  
								@RequestMapping(value= {"/user/update"},method=RequestMethod.PUT, produces="application/json",consumes="application/json")
								@ResponseBody
								public ResponseEntity String>  updateUser(@RequestBody RestUser restUser, UriComponentsBuilder ucBuilder)
								{
									
										 System.out.println("in updateUser controller");
										 
										 
										 //first check database data is available or not and get object
										 
										 if (!userRestDAO.isUserExist(restUser.getUser_no())) 
										 {
													   System.out.println("A User with user num " + restUser.getUser_no()+ " not exist");
													   return new ResponseEntity String>("user is not available ,please first add then update",HttpStatus.CONFLICT);
										 }
										 else
										 {
										 
													  System.out.println("A User with user num " + restUser.getUser_no()+ "  exist");
												   /*  RestUser user=new RestUser();
													 user.setUser_no(restUser.getUser_no());
													 user.setUser_name(userName);
													 user.setUser_address(userAdd);
													 user.setLast_data_updated_time("Y");*/
													 
													 userRestDAO.updateUser(restUser);
												
													 return new ResponseEntity String>("user data updated",HttpStatus.OK);

									  
										 }
								}
									  
		  
		  </3_update_record>
			  
		  <4_delete_record>
		  
		                1. write method with DELETE 
						2. fetch path variable 
						3. perorm operation and and delete record based on path variable
						4. send string message/updated record
		  
		  
		  
							@RequestMapping(value= {"/user/delete/{user_num}"}, method=RequestMethod.DELETE)
							@ResponseBody
							public String deleteUser(@PathVariable("user_num")int user_num,Model model)
							{
								
								System.out.println("in deleteUser controller");
								System.out.println("user_num"+user_num);
								
								userRestDAO.deleteByUserNo(user_num);
								
								
								  
								System.out.println("out deleteUser controller");
								
								return "user_num="+user_num+"==deleted";
							}
		  
		  </4_delete_record>
		 		 
		  <client_integeration>
		 
							  <create_webservice_and_used_in_seperate_mvc_project>
							  
									 <1_call_webservices_from_another_webservices>							  
									
										  >> call webservice A with value/action then call webservice B from A.. get responce from B and return same to client.									
										
									 </1_call_webservices_from_another_webservices>
							  
									<2_call_webservices_from_mvc_controller_and_get_response>
									
									    >> call_webservices_from_mvc_controller_and_get_response  and do some operation/changes to repsonce then add
 										   reflected chnages to jsp.
										 
												 <GET_note>
												    
													   >> to get raw data xm/json
													   
													   
															//1 create RestTemplate ref
															
															RestTemplate restTemplate=new RestTemplate();
															
															
															//1 get simple raw data
																   //	String result=restTemplate.getForObject(web_service_url+"list", String.class);
															
															
															//2 get using custom http headers
															
																			/*HttpHeaders headers = new HttpHeaders();
																			headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
																			HttpEntity String> entity = new HttpEntity String>("parameters", headers);
																			 
																			ResponseEntity String> result = restTemplate.exchange(web_service_url+"list", HttpMethod.GET, entity, String.class);
																			*/
															//3 get some specific data
																	
																			///rest/user/{user_num}
																		  /* Map String, Integer> param=new HashMap String,Integer>();
																		   param.put("user_num", 10);
																		   String result=restTemplate.getForObject(web_service_url+"user/{user_num}", String.class,param);
																			*/
																	
															//4 get wrt  model/entity/pojo
																
																	  //A. get response in as list
																				   Map String, Integer> param=new HashMap String,Integer>();
																				   param.put("user_num", 10);
																				   int p=11; 
																				   //  List RestUser> lstUser=Arrays.asList(restTemplate.getForObject(web_service_url+"user/{user_num}", RestUser[].class, p));
																					 
																		   
																	  // set http headers and pass and get response in ResponseEntity		   
																				  HttpHeaders headers = new HttpHeaders();
																				  headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
																				  HttpEntity String> entity = new HttpEntity String>("parameters", headers);			   
																				  ResponseEntity RestUser[]> result = restTemplate.exchange(web_service_url+"user/{user_num}", HttpMethod.GET, entity, RestUser[].class, p);									   
																				  List RestUser> lstUser=Arrays.asList(result.getBody());
															 
															 
																					for(RestUser restUser:lstUser)
																					{
																							System.out.println("User no=="+restUser.getUser_no());
																							System.out.println("User NAme=="+restUser.getUser_name());
																							System.out.println("User Add="+restUser.getUser_address());
																					}
																	
															
															
																										
																									 
																									 
																									 
												 
												 </GET_note>
										 
										         <PUT_note>
												     
													 //UPDATE record
													 
													               @RequestMapping(value= {"/update","update"},method=RequestMethod.POST, produces="application/json")
																	public String clientUpdateUser(@RequestParam("txtUserId")String userId,
																	                               @RequestParam("txtUserName")String userName,
																							       @RequestParam("txtUserAdd")String userAdd,Model model)
																	{
																		
																			 System.out.println("in clientUpdateUser");																																						 
																			 //first check database data is available or not and get object
																			 																			 
																			 System.out.println("user id="+userId);
																			 System.out.println("username="+userName);
																			 
																			 RestUser user=new RestUser();
																			 user.setUser_no(Integer.parseInt(userId.trim()));
																			 user.setUser_name(userName);
																			 user.setUser_address(userAdd);
																			 
																			 RestTemplate restTemplate=new RestTemplate();
																			 restTemplate.put(web_service_url+"user/update", user);   //postForObject(web_service_url+"user/add", user, RestUser.class);
																			 
																			 HttpHeaders headers = new HttpHeaders();
																			 headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
																			 HttpEntity String> entity = new HttpEntity String>("parameters", headers);
																			
																			 List RestUser> listUser=null;
																			 ResponseEntity RestUser[]> resultResp = restTemplate.exchange(web_service_url+"list", HttpMethod.GET, entity, RestUser[].class);									   
																			 listUser=Arrays.asList(resultResp.getBody());
																			
																		     model.addAttribute("userlist", listUser);
																		
																		return "welcome";
																	}
																	
												 </PUT_note>
												 
												 
												 <POST_NOTE>
												        
														//create new data/record/entry
														
														   @RequestMapping(value= {"/add","add"},method=RequestMethod.POST)
															public String clientCreateUser(  @RequestParam("txtUserId")String userId,
															                                 @RequestParam("txtUserName")String userName,
																					         @RequestParam("txtUserAdd")String userAdd
																					      )
															{
																 System.out.println("in clientCreateUser ");
																 																 
																 RestUser user=new RestUser();
																 user.setUser_no(Integer.parseInt(userId));
																 user.setUser_name(userName);
																 user.setUser_address(userAdd);
																 															 
																 RestTemplate restTemplate=new RestTemplate();
																 restTemplate.postForObject(web_service_url+"user/add", user, RestUser.class);
																 																 
																 System.out.println("out clientCreateUser ");
																 
																 return "redirect:list";
																	
															}
												 
												 </POST_NOTE>
												 
												 
												 <DELETE_NOTE>
												 
												        //DELETE record
														
														            @RequestMapping(value= {"/delete","delete"})
																	public String clientDeleteUser(@RequestParam("id")int id,Model model)
																	{
																		
																		 System.out.println("in clientDeleteUser");
																		 System.out.println("id="+id);
																		
																		  HttpHeaders headers = new HttpHeaders();
																		  headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
																		  HttpEntity String> entity = new HttpEntity String>("parameters", headers);
																		  
																		 Map String, Integer> param=new HashMap String,Integer>();
																		 param.put("user_num", id);
																		   
																		 RestTemplate restTemplate=new RestTemplate();
																		// String result= restTemplate.getForObject(web_service_url+"user/delete/{user_num}",String.class, param);
																		 
																		restTemplate.delete(web_service_url+"user/delete/{user_num}", param);
																		 
																		 List RestUser> listUser=null;
																	     
																		 System.out.println("data deleted");
																			
																			  ResponseEntity RestUser[]> resultResp = restTemplate.exchange(web_service_url+"list", HttpMethod.GET, entity, RestUser[].class);									   
																			  listUser=Arrays.asList(resultResp.getBody());
																			
																		  //"/rest/user/delete/{user_num}
																		  
																		  model.addAttribute("userlist", listUser);
																		  
																		  System.out.println("out clientDeleteUser");
																		
																		  return "welcome";
																}
	
														
												 
												 
												 </DELETE_NOTE>
												 
								   
								   
								   </2_call_webservices_from_mvc_controller_and_get_response>
							  
							  </create_webservice_and_used_in_seperate_mvc_project>
						   							 
							  <integrate_all_create_update_get_delete_in_single_page>
							  
							                  // completed
							   
							  </integrate_all_create_update_get_delete_in_single_page>
							  
							  <file_upload_download>
							                    
                                              <upload>												
													     consumes = {"multipart/mixed"}
													 
																	@RequestMapping(value= {"/upload","upload"},   method=RequestMethod.POST,consumes =MediaType.MULTIPART_FORM_DATA_VALUE )
																	@ResponseBody
																	public String fileUpload(@RequestParam("fileUPLOAD") MultipartFile file)
																	{															
																		System.out.println("in fileupload rest");														
																		String uploadResponse= saveFileToDisk(file);															
																		System.out.println("out fileupload rest");
																		
																		return uploadResponse;
																		
																	}
				
																		public String saveFileToDisk(MultipartFile file)
																		{
																			String origFileName=file.getOriginalFilename();
																			
																			 if (!file.isEmpty()) 
																			 {
																					try 
																					{
																						byte[] bytes = file.getBytes();
																						BufferedOutputStream stream = 
																								new BufferedOutputStream(new FileOutputStream(new File("D:\\rest_file_upload\\"+file.getOriginalFilename())));
																						stream.write(bytes);
																						stream.close();
																						return "You successfully uploaded " + origFileName + " into " + origFileName + "-uploaded !";
																						
																					} catch (Exception e) {
																						return "You failed to upload " + origFileName + " => " + e.getMessage();
																					}
																				} else {
																					return "You failed to upload " + origFileName + " because the file was empty.";
																				}
																		}
															
	                                          </upload>	
													 												 
											  <download>
											  
											         <Download_File_via_HttpServletResponse>
													 
													           @RequestMapping(value= {"/download/{fileName:.+}","download/{fileName:.+}"},method=RequestMethod.GET,produces="application/pdf")
																@ResponseBody
																public void fileHTTPservletRESPONSEDownload(@PathVariable("fileName") String fileName , HttpServletResponse response)  throws IOException
																{
																	  System.out.println("Called fileHTTPservletRESPONSEDownload:- " + fileName);
																	  
																	  /*HttpHeaders headers = new HttpHeaders();
																	  headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
																	  headers.add("Access-Control-Allow-Origin", "*");
																	  headers.add("Access-Control-Allow-Methods", "GET, POST, PUT");
																	  headers.add("Access-Control-Allow-Headers", "Content-Type");
																	  headers.add("Content-Disposition", "attachment; filename=" + fileName);
																	  headers.add("Cache-Control", "no-cache, no-store, must-revalidate");
																	  headers.add("Pragma", "no-cache");
																	  headers.add("Expires", "100");*/
																	 
																	  
																	  File file=new File("D:\\rest_file_upload\\"+fileName);
																	   
																	   // Path path=Paths.get("D:\\rest_file_upload\\"+fileName);
																	   // InputStream inputStream=new FileInputStream(file);
																	   // byte[] data =Files.readAllBytes(path);
																	  
																	   //InputStreamResource resource = new InputStreamResource(new FileInputStream(file));
																	  
																	  
																	    //Resource resource = new InputStreamResource(new FileInputStream(file));
																	 
																	    // headers.setContentLength(file.length());
																	  
																	    // ResponseEntity InputStreamResource> response = new ResponseEntity InputStreamResource>(resource, headers, HttpStatus.OK);
																	    // File file = getFile();
																	  
																		InputStream in = new FileInputStream(file);

																		response.setContentType("application/pdf");
																		response.setHeader("Content-Disposition", "attachment; filename=" + file.getName());
																		response.setHeader("Content-Length", String.valueOf(file.length()));
																		FileCopyUtils.copy(in, response.getOutputStream());
																			  
																	    //return new ResponseEntity >(resource, headers, HttpStatus.OK);
																	    //ResponseEntity InputStreamResource> response = new ResponseEntity InputStreamResource>(resource, HttpStatus.OK);
																	
																	    // return response;
																			
																}
																
													 </Download_File_via_HttpServletResponse>
											  
											         <Download_File_via_ResponseEntity_InputStreamResource>
													
													                @RequestMapping(value= {"/rest/download/{fileName:.+}","download/{fileName:.+}"},method=RequestMethod.GET)
																	@ResponseBody
																	public ResponseEntity InputStreamResource> fileResponseEntityDownload(@PathVariable("fileName") String fileName , HttpServletResponse response)  throws IOException
																	{
																		  System.out.println("Called fileResponseEntityDownload:- " + fileName);
																		  
																		  /*HttpHeaders headers = new HttpHeaders();
																		  headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
																		  headers.add("Access-Control-Allow-Origin", "*");
																		  headers.add("Access-Control-Allow-Methods", "GET, POST, PUT");
																		  headers.add("Access-Control-Allow-Headers", "Content-Type");
																		  headers.add("Content-Disposition", "attachment; filename=" + fileName);
																		  headers.add("Cache-Control", "no-cache, no-store, must-revalidate");
																		  headers.add("Pragma", "no-cache");
																		  headers.add("Expires", "100");*/
																		 
																		  
																		  File file=new File("D:\\rest_file_upload\\"+fileName);
																		 // Path path=Paths.get("D:\\rest_file_upload\\"+fileName);
																		 // InputStream inputStream=new FileInputStream(file);
																		 // byte[] data =Files.readAllBytes(path);
																		  
																		  //InputStreamResource resource = new InputStreamResource(new FileInputStream(file));
																		  
																		  
																		  //Resource resource = new InputStreamResource(new FileInputStream(file));
																		 
																		 // headers.setContentLength(file.length());
																		  
																		 // ResponseEntity InputStreamResource> response = new ResponseEntity InputStreamResource>(resource, headers, HttpStatus.OK);
																		 // File file = getFile();
																		  
																			InputStream in = new FileInputStream(file);

																		  /*  response.setContentType("application/pdf");
																			response.setHeader("Content-Disposition", "attachment; filename=" + file.getName());
																			response.setHeader("Content-Length", String.valueOf(file.length()));
																			FileCopyUtils.copy(in, response.getOutputStream());
																			*/
																			
																			HttpHeaders respHeaders = new HttpHeaders();
																			respHeaders.setContentType(MediaType.APPLICATION_PDF);;
																			respHeaders.setContentLength(file.length());
																			respHeaders.setContentDispositionFormData("attachment",fileName);
																				  
																			InputStreamResource isr = new InputStreamResource(new FileInputStream(file));
																			
																		   //return new ResponseEntity >(resource, headers, HttpStatus.OK);
																		  //ResponseEntity InputStreamResource> response = new ResponseEntity InputStreamResource>(resource, HttpStatus.OK);
																		
																		 // return response;
																			
																			return new ResponseEntity InputStreamResource>(isr, respHeaders, HttpStatus.OK);
																				
																	}
																	
											         </Download_File_via_ResponseEntity_InputStreamResource>

                                              </download>

											  
							  </file_upload_download>
							  			  
							  <create_jsp_that_generate_url_for_image_or_file>
								  
							  
							  </create_jsp_that_generate_url_for_image_or_file>
							  
		  </client_integeration>
		 
	   </test>
      
   </spring_rest>
   
   <spring_exception_handling>
	   
	   >>Spring MVC Framework provides following ways to help us achieving robust exception handling.

       <1_Controller_Based>
	   
	                 We can define exception handler methods in our controller classes. All we need is to annotate these methods with 
					 @ExceptionHandler annotation. This annotation takes Exception class as argument. So if we have defined one of these for Exception class,
					 then all the exceptions thrown by our request handler method will have handled.
                     
					 These exception handler methods are just like other request handler methods and we can build error response and respond with different 
					 error page. We can also send JSON error response, that we will look later on in our example.

                     If there are multiple exception handler methods defined, then handler method that is closest to the Exception class is used. For example,
					 if we have two handler methods defined for IOException and Exception and our request handler method throws IOException, then 
					 handler method for IOException will get executed.
					 
					 <1_example>
					 
											 @ResponseStatus(value=HttpStatus.NOT_FOUND, reason="Employee Not Found") //404
												public class EmployeeNotFoundException extends Exception {

													private static final long serialVersionUID = -3332292346834265371L;

													public EmployeeNotFoundException(int id){
														super("EmployeeNotFoundException with id="+id);
													}
												}
												
												
												<Notice>
												
														that we can use @ResponseStatus annotation with exception classes to define the HTTP code 
														that will be sent by our application
														when this type of exception is thrown by our application and handled by our exception handling 
														implementations.

														As you can see that I am setting HTTP status as 404 and we have an error-page defined for this,
														so our application should use 
														the error page for this type of exception if we are not returning any view.

														We can also override the status code in our exception handler method, think of it as default
														http status code when our exception handler method is not returning any view page as response.
														
												</Notice>
												
						
						                           @Controller
													public class EmployeeController {
														
														private static final Logger logger = LoggerFactory.getLogger(EmployeeController.class);
														
														@RequestMapping(value="/emp/{id}", method=RequestMethod.GET)
														public String getEmployee(@PathVariable("id") int id, Model model) throws Exception{
															//deliberately throwing different types of exception
															if(id==1){
																throw new EmployeeNotFoundException(id);
															}else if(id==2){
																throw new SQLException("SQLException, id="+id);
															}else if(id==3){
																throw new IOException("IOException, id="+id);
															}else if(id==10){
																Employee emp = new Employee();
																emp.setName("Pankaj");
																emp.setId(id);
																model.addAttribute("employee", emp);
																return "home";
															}else {
																throw new Exception("Generic Exception, id="+id);
															}
															
														}
														
														@ExceptionHandler(EmployeeNotFoundException.class)
														public ModelAndView handleEmployeeNotFoundException(HttpServletRequest request, Exception ex){
															logger.error("Requested URL="+request.getRequestURL());
															logger.error("Exception Raised="+ex);
															
															ModelAndView modelAndView = new ModelAndView();
															modelAndView.addObject("exception", ex);
															modelAndView.addObject("url", request.getRequestURL());
															
															modelAndView.setViewName("error");
															return modelAndView;
														}	
													}
																			
						
						</1_example>
						
					 <2_example>
					       
						   public class FooController
						   {
     
										//...
										@ExceptionHandler({ CustomException1.class, CustomException2.class })
										public void handleException() {
											//
										}
						   }
					 
                     </2_example>					 
						
       </1_Controller_Based>  
      
	   <2_Global_Exception_Handler>
	   
	                 Exception Handling is a cross-cutting concern, it should be done for all the pointcuts in our application. We have already looked 
					 into Spring AOP and that’s why Spring provides @ControllerAdvice annotation that we can use with any class to define our global exception
					 handler.
					 
                     The handler methods in Global Controller Advice is same as Controller based exception handler methods and used when controller class is 
					 not able to handle the exception.
					 
					 
					 
					 @ControllerAdvice
						public class GlobalExceptionHandler {

							private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
							
							@ExceptionHandler(SQLException.class)
							public String handleSQLException(HttpServletRequest request, Exception ex){
								logger.info("SQLException Occured:: URL="+request.getRequestURL());
								return "database_error";
							}
							
							@ResponseStatus(value=HttpStatus.NOT_FOUND, reason="IOException occured")
							@ExceptionHandler(IOException.class)
							public void handleIOException(){
								logger.error("IOException handler executed");
								//returning 404 error code
							}
						}
						
					@ControllerAdvice
						public class RestResponseEntityExceptionHandler 
						  extends ResponseEntityExceptionHandler {
						 
							@ExceptionHandler(value 
							  = { IllegalArgumentException.class, IllegalStateException.class })
							protected ResponseEntity Object> handleConflict(
							  RuntimeException ex, WebRequest request) {
								String bodyOfResponse = "This should be application specific";
								return handleExceptionInternal(ex, bodyOfResponse, 
								  new HttpHeaders(), HttpStatus.CONFLICT, request);
							}
						}	
											 
					 @Component
							public class CustomAccessDeniedHandler implements AccessDeniedHandler {
							 
								@Override
								public void handle
								  (HttpServletRequest request, HttpServletResponse response, AccessDeniedException ex) 
								  throws IOException, ServletException {
									response.sendRedirect("/my-error-page");
								}
							}
							
							
					  @ControllerAdvice
							public class RestResponseEntityExceptionHandler 
							  extends ResponseEntityExceptionHandler {
							 
								@ExceptionHandler({ AccessDeniedException.class })
								public ResponseEntity Object> handleAccessDeniedException(
								  Exception ex, WebRequest request) {
									return new ResponseEntity Object>(
									  "Access denied message here", new HttpHeaders(), HttpStatus.FORBIDDEN);
								}
								 
								...
							}
					 
       </2_Global_Exception_Handler>
		
       <3_HandlerExceptionResolver>
	   
	                  For generic exceptions, most of the times we serve static pages. Spring Framework provides HandlerExceptionResolver interface that 
					  we can implement to create global exception handler. The reason behind this additional way to define global exception handler 
					  is that Spring framework also provides default implementation classes that we can define in our spring bean configuration file 
					  to get spring framework exception handling benefits.
					  
                     >>SimpleMappingExceptionResolver 
					          is the default implementation class, it allows us to configure exceptionMappings where we can specify which resource to use
							  for a particular exception. We can also override it to create our own global handler with our application specific changes,
							  such as logging of exception messages.
	                 
					 
					 >>
					 
					   this will resolve any exception thrown by the application. It will also allow us to implement a uniform exception handling mechanism 
					   in our REST API.

							Before going for a custom resolver, let’s go over the existing implementations.

							3.1. ExceptionHandlerExceptionResolver
							           This resolver was introduced in Spring 3.1 and is enabled by default in the DispatcherServlet. This is actually 
									   the core component of how the @ExceptionHandler mechanism presented earlier works.

							3.2. DefaultHandlerExceptionResolver
							           This resolver was introduced in Spring 3.0 and is enabled by default in the DispatcherServlet. It is used 
									   to resolve standard Spring exceptions to their corresponding HTTP Status Codes, namely Client error – 4xx
									   and Server error – 5xx status codes. Here is the full list of the Spring Exceptions it handles, and how 
									   these are mapped to status codes.

									While it does set the Status Code of the Response properly, one limitation is that it doesn’t set anything to the body of 
									the Response. And for a REST API – the Status Code is really not enough information to present to the Client – the response 
									has to have a body as well, to allow the application to give additional information about the failure.

									This can be solved by configuring View resolution and rendering error content through ModelAndView, but the solution is 
									clearly not optimal – which is why a better option has been made available with Spring 3.2 – we’ll talk about that in the
									latter part of this article.

							3.3. ResponseStatusExceptionResolver
							          This resolver was also introduced in Spring 3.0 and is enabled by default in the DispatcherServlet. Its main 
									  responsibility is to use the @ResponseStatus annotation available on custom exceptions and to map these 
									  exceptions to HTTP status codes.
									  
									  
									  
							@ResponseStatus(value = HttpStatus.NOT_FOUND)
							public class ResourceNotFoundException extends RuntimeException {
								public ResourceNotFoundException() {
									super();
								}
								public ResourceNotFoundException(String message, Throwable cause) {
									super(message, cause);
								}
								public ResourceNotFoundException(String message) {
									super(message);
								}
								public ResourceNotFoundException(Throwable cause) {
									super(cause);
								}
							}
							
							Same as the DefaultHandlerExceptionResolver, this resolver is limited in the way it deals with the body of the response – 
							it does map the Status Code on the response, but the body is still null.

							3.4. SimpleMappingExceptionResolver and AnnotationMethodHandlerExceptionResolver
							                  The SimpleMappingExceptionResolver has been around for quite some time – it comes out of the older 
											  Spring MVC model and is not very relevant for a REST Service. It is used to map exception class names 
											  to view names.

							                  The AnnotationMethodHandlerExceptionResolver was introduced in Spring 3.0 to handle exceptions through 
											  the @ExceptionHandler annotation but has been deprecated by ExceptionHandlerExceptionResolver as of Spring 3.2.

							3.5. Custom HandlerExceptionResolver
							                 The combination of DefaultHandlerExceptionResolver and ResponseStatusExceptionResolver goes a long way 
											 towards providing a good error handling mechanism for a Spring RESTful Service. The downside is – as 
											 mentioned before – no control over the body of the response.

							Ideally, we’d like to be able to output either JSON or XML, depending on what format the client has asked
							for (via the Accept header).	

                            This alone justifies creating a new, custom exception resolver:
							
								@Component
								public class RestResponseStatusExceptionResolver extends AbstractHandlerExceptionResolver {
								 
									@Override
									protected ModelAndView doResolveException
									  (HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
										try {
											if (ex instanceof IllegalArgumentException) {
												return handleIllegalArgument((IllegalArgumentException) ex, response, handler);
											}
											...
										} catch (Exception handlerException) {
											logger.warn("Handling of [" + ex.getClass().getName() + "] 
											  resulted in Exception", handlerException);
										}
										return null;
									}
								 
									private ModelAndView handleIllegalArgument
									  (IllegalArgumentException ex, HttpServletResponse response) throws IOException {
										response.sendError(HttpServletResponse.SC_CONFLICT);
										String accept = request.getHeader(HttpHeaders.ACCEPT);
										...
										return new ModelAndView();
									}
								}							
															   
	   </3_HandlerExceptionResolver>
	   
	   
   </spring_exception_handling>
   
   <5_spring_services>
   
   </5_spring_services>
   
   <6_spring_boot>
        
		--version...2.0.3
		
	    -- SPRING BOOT= SPRING FRAMEWORK+ EMBEDED HTTP SERVER HTTT,JETTY + BEAN XML/@CONFIGURATION
	    >>> main dependency
		
		<Note>
		       
			   1.   At the same time, if you don’t want to use auto configuration for any project, it makes it very simple.
         			   Just use exclude = SecurityAutoConfiguration.class like below.

								@SpringBootApplication (exclude = SecurityAutoConfiguration.class)
								public class SpringBootDemoApplication {
									public static void main(String[] args) {
										SpringApplication.run(SpringBootDemoApplication.class, args);
									}
								}
			   
			   
		</Note>
		
		<view_resolver>
		
		
		
		Configure JSP View Resolver
							To resolve JSP files location, you can have two approaches.

							1) Add entries in application.properties
											spring.mvc.view.prefix=/WEB-INF/view/
											spring.mvc.view.suffix=.jsp
											 
											//For detailed logging during development
											 
											logging.level.org.springframework=TRACE
											logging.level.com=TRACE
											
                            2) Configure InternalResourceViewResolver

									@Configuration
									@EnableWebMvc
									@ComponentScan
									public class MvcConfiguration extends WebMvcConfigurerAdapter
									{
										@Override
										public void configureViewResolvers(ViewResolverRegistry registry) 
										{
											InternalResourceViewResolver resolver = new InternalResourceViewResolver();
											resolver.setPrefix("/WEB-INF/view/");
											resolver.setSuffix(".jsp");
											resolver.setViewClass(JstlView.class);
											registry.viewResolver(resolver);
										}
									}
		
		
		</view_resolver>
		
	   <Key_Components>	
	   
		     Key Components of Spring Boot Framework
			 Spring Boot Framework has mainly four major Components.

					1. Spring Boot Starters
					         >> Spring Boot Starter component combines all related jars into single jar file so that we can add only jar file
							    dependency to our build files. Instead of adding above 4 jars files to our build file, we need to add one
							    and only one jar file: “spring-boot-starter-web” jar file.

                             >> When we add “spring-boot-starter-web” jar file dependency to our build file, then Spring Boot Framework will 
							    automatically download all required jars and add to our project classpath.
					
					
					2. Spring Boot AutoConfigurator
					           >> The solution to this problem is Spring Boot AutoConfigurator. The main responsibility of Spring Boot AutoConfigurator
							      is to reduce the Spring Configuration. If we develop Spring applications in Spring Boot,then We dont need 
							      to define single XML configuration and almost no or minimal Annotation configuration. 
							      Spring Boot AutoConfigurator component will take care of providing those information.

                               >> For instance, if we want to declare a Spring MVC application using Spring IO Platform, then we need to define
 							      lot of XML Configuration like views, view resolvers etc. But if we use Spring Boot Framework, then we dont need 
								  to define those XML Configuration. Spring Boot AutoConfigurator will take of this.

                               >> If we use “spring-boot-starter-web” jar file in our project build file, then Spring Boot AutoConfigurator 
							      will resolve views, view resolvers etc. automatically.
								  
							   >> And also Spring Boot reduces defining of Annotation configuration. If we use @SpringBootApplication annotation 
							      at class level, then Spring Boot AutoConfigurator will automatically add all required annotations to Java Class ByteCode.	 

							   >>  @SpringBootApplication = @Configuration + @ComponentScan + @EnableAutoConfiration.	  
					 
					
					3. Spring Boot CLI
					
					          >> Spring Boot CLI(Command Line Interface) is a Spring Boot software to run and test Spring Boot applications 
							     from command prompt. When we run Spring Boot applications using CLI, then it internally uses Spring Boot Starter 
								 and Spring Boot AutoConfigurate components to resolve all dependencies and execute the application.

							  >> We can run even Spring Web Applications with simple Spring Boot CLI Commands.

							  >> Spring Boot CLI has introduced a new “spring” command to execute Groovy Scripts from command prompt.

								 spring command example:

								   spring run HelloWorld.groovy
								   Here HelloWorld.groovy is a Groovy script FileName.
										
					
					4. Spring Boot Actuator
				
							  >> Spring Boot Actuator components gives many features, but two major features are

							  >> Providing Management EndPoints to Spring Boot Applications.
								 Spring Boot Applications Metrics.
								
							  >> When we run our Spring Boot Web Application using CLI, Spring Boot Actuator automatically provides hostname as “localhost”
 							     and default port number as “8080”. We can access this application using “http://localhost:8080/” end point.

							  >> We actually use HTTP Request methods like GET and POST to represent Management EndPoints using Spring Boot Actuator.
		
		</Key_Components>
		
		<spring_boot_properties>
		        
				The following table contains common Spring Boot properties.

					Property	                         Default value	                                   Description
					banner.charset	                       UTF-8	                            It is used to set banner file encoding.
					banner.location	                       classpath:banner.txt	                It is used to set banner file location.
					logging.file		                                                        It is used to set log file name. For example data.log.
					spring.application.index												    It is used to set application index.
					spring.application.name		                                                It is used to set application name.
					spring.application.admin.enabled	   false	                            It is used to enable admin features for the application.
					spring.config.location		                                                It is used to config file locations.
					spring.config.name	                   application	                        It is used to set config file name.
					spring.mail.default-encoding	       UTF-8	                            It is used to set default MimeMessage encoding.
					spring.mail.host		                                                    It is used to set SMTP server host. For example
 					                                                                             smtp.example.com.
					spring.mail.password		                                                It is used to set login password of the SMTP server.
					spring.mail.port		                                                    It is used to set SMTP server port.
					spring.mail.test-connection	           false	                            It is used to test that the mail server is available on startup.
					spring.mail.username		                                                It is used to set login user of the SMTP server.
					spring.main.sources		                                                    It is used to set sources for the application.
					server.address		                                                        It is used to set network address to which the server 
					                                                                            should bind to.
					server.connection-timeout		                                            It is used to set time in milliseconds that connectors will
                                                                                					wait for another HTTP request before closing the connection.
					server.context-path		                                                    It is used to set context path of the application.
					server.port	8080	                                                        It is used to set HTTP port.
					server.server-header		                                                It is used for the Server response header (no header is sent 
					                                                                            if empty)
					server.servlet-path	                    /	                                It is used to set path of the main dispatcher servlet
					server.ssl.enabled		                                                    It is used to enable SSL support.
					spring.http.multipart.enabled	       True	                                It is used to enable support of multi-part uploads.
					spring.http.multipart.max-file-size	   1MB	                                It is used to set max file size.
					spring.mvc.async.request-timeout		                                    It is used to set time in milliseconds.
					spring.mvc.date-format		                                                It is used to set date format. For example dd/MM/yyyy.
					spring.mvc.locale		                                                    It is used to set locale for the application.
					spring.social.facebook.app-id		                                        It is used to set application's Facebook App ID.
					spring.social.linkedin.app-id		                                        It is used to set application's LinkedIn App ID.
					spring.social.twitter.app-id		                                        It is used to set application's Twitter App ID.
					security.basic.authorize-mode	        role	                            It is used to set security authorize mode to apply.
					security.basic.enabled	                true	                            It is used to enable basic authentication.
		
		</spring_boot_properties>
		
		<spring_boot_starter>
		        
				Starters are a set of convenient dependency descriptors which we can include in our application.

                Spring Boot provides built-in starters which makes development easier and rapid. For example, if we want to get started using Spring 
				and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project.

                Starter should follow a naming pattern like: spring-boot-starter-*, where * is a particular type of application. This naming structure 
				is intended to help when you need to find a starter.

               >> The following application starters are provided by Spring Boot under the org.springframework.boot group:
				
				
				Name	                                                      Description
				spring-boot-starter-thymeleaf	                          It is used to build MVC web applications using Thymeleaf views.
				spring-boot-starter-data-couchbase	                      This is used for Couchbase document-oriented database and Spring Data Couchbase.
				spring-boot-starter-artemis	                              It is used for JMS messaging using Apache Artemis.
				spring-boot-starter-web-services	                      It is used for Spring Web Services.
				spring-boot-starter-mail								  It is used to support Java Mail and Spring Framework's email sending.
				spring-boot-starter-data-redis	                          It is used for Redis key-value data store with Spring Data Redis and the Jedis client.
				spring-boot-starter-web	                                  It is used for building web, including RESTful, applications using Spring MVC.
                                                            				Uses Tomcat as the default embedded container.
				spring-boot-starter-data-gemfire	                      It is used to GemFire distributed data store and Spring Data GemFire.
				spring-boot-starter-activemq	                          It is used to JMS messaging using Apache ActiveMQ.
				spring-boot-starter-data-elasticsearch	                  It is used to Elasticsearch search and analytics engine and Spring Data Elasticsearch.
				spring-boot-starter-integration	                          It is used for Spring Integration.
				spring-boot-starter-test	                              It is used to test Spring Boot applications with libraries including JUnit,
                                                          				   Hamcrest and Mockito.
				spring-boot-starter-jdbc	                              It is used for JDBC with the Tomcat JDBC connection pool.
				spring-boot-starter-mobile	                              It is used for building web applications using Spring Mobile.
				spring-boot-starter-validation	                          It is used for Java Bean Validation with Hibernate Validator.
				spring-boot-starter-hateoas                               It is used to build hypermedia-based RESTful web application with Spring MVC
                                                            				and Spring HATEOAS.
				spring-boot-starter-jersey                                It is used to build RESTful web applications using JAX-RS and Jersey.
                                                              				An alternative to spring-boot-starter-web.
				spring-boot-starter-data-neo4j	                          It is used for Neo4j graph database and Spring Data Neo4j.
				spring-boot-starter-data-ldap	                          It is used for Spring Data LDAP.
				spring-boot-starter-websocket	                          It is used for building WebSocket. applications using Spring Framework?s 
				                                                              WebSocket support.
				spring-boot-starter-aop	                                  It is used for aspect-oriented programming with Spring AOP and AspectJ.
				spring-boot-starter-amqp	                              It is used for Spring AMQP and Rabbit MQ.
				spring-boot-starter-data-cassandra	                      It is used for Cassandra distributed database and Spring Data Cassandra.
				spring-boot-starter-social-facebook	                      It is used for Spring Social Facebook.
				spring-boot-starter-jta-atomikos	                      It is used for JTA transactions using Atomikos.
				spring-boot-starter-security	                          It is used for Spring Security.
				spring-boot-starter-mustache	                          It is used for building MVC web applications using Mustache views.
				spring-boot-starter-data-jpa	                          It is used for Spring Data JPA with Hibernate.
				spring-boot-starter	                                      It is used for core starter, including auto-configuration support, logging and YAML.
				spring-boot-starter-groovy-templates	                  It is used for building MVC web applications using Groovy Templates views.
				spring-boot-starter-freemarker	                          It is used for building MVC web applications using FreeMarker views.
				spring-boot-starter-batch	                              It is used for Spring Batch.
				spring-boot-starter-social-linkedin	                      It is used for Spring Social LinkedIn.
				spring-boot-starter-cache	                              It is used for Spring Framework?s caching support.
				spring-boot-starter-data-solr	                          It is used for the Apache Solr search platform with Spring Data Solr.
				spring-boot-starter-data-mongodb	                      It is used for MongoDB document-oriented database and Spring Data MongoDB.
				spring-boot-starter-jooq	                              It is used for jOOQ to access SQL databases. An alternative to
                                                           				  spring-boot-starter-data-jpa or spring-boot-starter-jdbc.
				spring-boot-starter-jta-narayana	                      It is used for Spring Boot Narayana JTA Starter.
				spring-boot-starter-cloud-connectors	                  It is used for Spring Cloud Connectors which simplifies connecting to services 
				                                                          in cloud platforms like Cloud Foundry and Heroku.
				spring-boot-starter-jta-bitronix	                      It is used for JTA transactions using Bitronix.
				spring-boot-starter-social-twitter	                      It is used for Spring Social Twitter.
				spring-boot-starter-data-rest	                          It is used for exposing Spring Data repositories over REST using Spring Data REST.
						
		
		    >> Spring Boot production starters
				Name	                                                 Description
				spring-boot-starter-actuator	    It is used for Spring Boot?s Actuator which provides production ready features to help you monitor 
				                                    and manage your application.
				spring-boot-starter-remote-shell	It is used for the CRaSH remote shell to monitor and manage your application over SSH. Deprecated since 1.5.
			
			>>Spring Boot technical starters
				Name	                              Description
				spring-boot-starter-undertow	It is used for Undertow as the embedded servlet container. An alternative to spring-boot-starter-tomcat.
				spring-boot-starter-jetty	    It is used for Jetty as the embedded servlet container. An alternative to spring-boot-starter-tomcat.
				spring-boot-starter-logging	    It is used for logging using Logback. Default logging starter.
				spring-boot-starter-tomcat	    It is used for Tomcat as the embedded servlet container. Default servlet container starter 
				                                used by spring-boot-starter-web.
				spring-boot-starter-log4j2	    It is used for Log4j2 for logging. An alternative to spring-boot-starter-logging.
						
		</spring_boot_starter>
		
		<Spring_Boot_Actuator>
		      
			           >>    Spring Boot provides actuator to monitor and manage our application. Actuator is a tool which has HTTP endpoints. 
						     when application is pushed to production, you can choose to manage and monitor your application using HTTP endpoints.

					   >>	 To get production-ready features, we should use spring-boot-actuator module. We can enable this feature by adding 
						     it to the pom.xml file.

						<dependencies>  
							<dependency>  
								<groupId>org.springframework.boot</groupId>  
								<artifactId>spring-boot-starter-actuator</artifactId>  
							</dependency>  
						</dependencies>


                     >>Endpoints
                            Actuator endpoints allow us to monitor and interact with our Spring Boot application. Spring Boot includes number
							of built-in endpoints and we can also add custom.

                            The following table contains the available endpoints.

								Id	                       Description	                                                   Sensitive default
								actuator	         It provides a hypermedia-based "discovery page" for 
								                     the other endpoints. It requires Spring HATEOAS to
 													 be on the classpath.	                                                        True
								auditevents        	It exposes audit events information for the current application.	            True
								autoconfig	        It is used to display an auto-configuration report showing 
								                    all auto-configuration candidates and the reason why they 'were'
													or 'were not' applied.                                                    	    True
								beans	            It is used to display a complete list of all the Spring beans 
								                    in your application.	                                                        True
								configprops      	It is used to display a  collated list of all @ConfigurationProperties.	        True
								dump	            It is used to perform a thread dump.										    True
								env	                It is used to expose properties from Spring's ConfigurableEnvironment.	        True
								flyway	            It is used to show any Flyway database migrations that have been applied.	    True
								health	            It is used to show application health information.							    False
								info	            It is used to display arbitrary application info.							    False
								loggers	            It is used to show and modify the configuration of loggers in the application.	True
								liquibase	        It is used to show any Liquibase database migrations that have been applied.	True
								Metrics	            It is used to show metrics information for the current application.				True
								mappings	        It is used to display a collated list of all @RequestMapping paths.				True
								shutdown	        It is used to allow the application to be gracefully shutdown.					True
								trace	            It is used to display trace information.										True
								
								
						>For Spring MVC, the following additional endpoints can also be used.

								Id	                  Description	                                                                       Sensitive default
								docs	              It is used to display documentation, including example requests and responses for 
								                      the Actuator's endpoints.	                                                                False
								heapdump	          It is used to return a GZip compressed hprof heap dump file.	                            True
								jolokia	              It is used to expose JMX beans over HTTP (when Jolokia is on the classpath).            	True
								logfile	              It is used to return the contents of the logfile.                                      	True						
										
								
		</Spring_Boot_Actuator>
		
		<spring_boot_get_all_loaded_beans>
		
		
		           >> Spring boot loads lots of beans internally to run your application with minimal configuration. In this example, we will learn
					  to find out all those spring boot loaded beans and their class type information.

				   >> Using ApplicationContext to get all loaded beans
					                To execute a method automatically, when application is fully loaded, I am using CommandLineRunner interface. 
									CommandLineRunner is used to indicate that a bean should run when it is contained within a Spring Application.

					    1) Use ApplicationContext.getBeanDefinitionNames() to find the name of all loaded beans
					    2) Use ApplicationContext.getBean(beanName) to get bean including its runtime type information.

						
									package com.howtodoinjava.app.controller;
									import java.util.Arrays;
									 
									import org.springframework.beans.factory.annotation.Autowired;
									import org.springframework.boot.CommandLineRunner;
									import org.springframework.boot.SpringApplication;
									import org.springframework.boot.autoconfigure.SpringBootApplication;
									import org.springframework.boot.builder.SpringApplicationBuilder;
									import org.springframework.boot.web.support.SpringBootServletInitializer;
									import org.springframework.context.ApplicationContext;
									 
									@SpringBootApplication
									public class SpringBootWebApplication extends SpringBootServletInitializer implements CommandLineRunner 
									{
									 
										@Override
										protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
											return application.sources(SpringBootWebApplication.class);
										}
									 
										public static void main(String[] args) throws Exception {
											SpringApplication.run(SpringBootWebApplication.class, args);
										}
										 
										@Autowired
										private ApplicationContext appContext;
										 
										@Override
										public void run(String... args) throws Exception
										{
											String[] beans = appContext.getBeanDefinitionNames();
											Arrays.sort(beans);
											for (String bean : beans)
											{
												System.out.println(bean + " of Type :: " + appContext.getBean(bean).getClass());
											}
										}
									}
						
						>> Running above application will print bean names and type information in console 


		        >>Spring boot’s CommandLineRunner interface is used to run a code block only once in application’s lifetime – after application is initialized.
		        >> Command line runners are a useful functionality to execute the various types of code that only have to be run once, right after application startup.
		        >> @Order(value=3) to set oreder if multiple commandlineinterface is used 
				
		</spring_boot_get_all_loaded_beans>
		
		<spring_boot_devtools>
		
		       >> When we develop our applications (web or RESTful API), we want to be able to test our changes quickly.

               >> Typically, in the Java world, we need to restart the server to pick up changes. Sure, there are plugins like JRebel that help, 
			      but you need shell out money for them.

               >> Restarting a server takes about 1-5 minutes based on the size of the application. A typical developer does 30-40 restarts in a day. I leave it as an exercise in basic math to determine how much time a developer can save if changes are automatically picked up as soon as they're made.

               >> That's where Spring Boot Developer Tools comes into the picture.

               >> Adding Spring Boot Developer Tools to your project is very simple. First, add this dependency to your Spring Boot Project pom.xml:

					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-devtools</artifactId>
						<scope>runtime</scope>
					</dependency>
		
		       >> Second, restart the application.

               >> You are all set.

               >> Don't believe me? Go ahead and make a simple change to your controller. You will see that these changes are automatically picked up.
               
               >> Now it is changed. By adding the spring-boot-devtools, the following template caches are disabled by default:

						spring.thymeleaf.cache=false
						spring.freemarker.cache=false
						spring.groovy.template.cache=false
						spring.velocity.cache=false
						spring.mustache.cache=false			   
						
						
               >>Note: By default, any entry on the classpath that points to a folder will be monitored for changes.

						Here are few important things to note:

						These folders will not trigger a reload by default

						/META-INF/maven
						/META-INF/resources
						/resources
						/static
						/public
						/templates

			   >> You can configure additional folders to scan below:

						application.properties:

						spring.devtools.restart.additional-paths = /path-to-folder

			  >>You can also configure folders to exclude:

						spring.devtools.restart.exclude=static/**,public/**
						
						
			>> Auto Refresh Your Browser With LiveReload
						>> Spring Boot Developer Tools auto-loads the changes to an application. But if you are developing a web application, 
						   you would need to refresh the browser to pick up the change.

						>> LiveReload aims to solve this problem, offering extensions for browsers.

						    Download them from http://livereload.com/extensions/
							
							spring.devtools.livereload.enabled=false
						>> Once you install the LiveReload plugin for your browser, you will see that the page auto-refreshes when you make a change
						   in your application code.			
								
		</spring_boot_devtools>
		
		<parent>
			   <groupId>org.springframework.boot</groupId>
			   <artifactId>spring-boot-starter-parent</artifactId>
			   <version>2.0.1.RELEASE</version>
			   <relativePath/> <!-- lookup parent from repository -->
		</parent>
			
	    <Annotation>
	   
					   1.@SpringBootApplication
									--A single @SpringBootApplication annotation can be used to enable those three features, that is:

									1>  @EnableAutoConfiguration: enable Spring Boot’s auto-configuration mechanism
									2>  @ComponentScan: enable @Component scan on the package where the application is located (see the best practices)
									3>  @Configuration: allow to register extra beans in the context or import additional configuration classes
					   
					   2. @SpringBootConfiguration
										 >>@SpringBootConfiguration is new annotation in Spring boot 2. Previously, we have been using @Configuration annotation.
												You can use @Configuration in place of this. Both are same thing.
										 
										 >> It indicates that a class provides Spring Boot application @Configuration. It simply means that annotated class is a 
											configuration class and shall be scanned for further configurations and bean definitions.

					   3. @EnableAutoConfiguration
										 >> This annotation is used to enable auto-configuration of the Spring Application Context, attempting to guess and 
											configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath 
											and what beans you have defined.

										 >>Auto-configuration tries to be as intelligent as possible and will back-away as you define more of your own configuration.
										 You can always manually exclude any configuration that you never want to apply using two methods –

											i) Use excludeName()
											ii) Using the spring.autoconfigure.exclude property in properties file. e.g.

											@EnableAutoConfiguration(excludeName = {"multipartResolver","mbeanServer"})
											Auto-configuration is always applied after user-defined beans have been registered.

					   4. @ComponentScan
										>>This annotation provides support parallel with Spring XML’s context:component-scan element.

										Either basePackageClasses() or basePackages() may be specified to define specific packages to scan. If specific packages 
										are not defined, scanning will occur from the package of the class that declares this annotation.
	
	    </Annotation>
	
	 <security>
	 
	     extend calss with  WebSecurityConfigurerAdapter and then in side override method
		       auth.inMemoryAuthentication().passwordEncoder
		       (org.springframework.security.crypto.password.NoOpPasswordEncoder.getInstance()).
		       withUser("user").password("user").roles("USER").
		       and().withUser("admin").password("admin").roles("USER", "ADMIN");
		
		2...
		
		http.httpBasic().and().authorizeRequests()
		.antMatchers("/").permitAll()//  hasRole("permitAll")
		.antMatchers("/**").permitAll()  //hasRole("permitAll")
		.and().csrf().disable().headers().frameOptions().disable();
		
		--
		example
		..........
		                        @Configuration
								@EnableWebSecurity
								public class SecSecurityConfig extends WebSecurityConfigurerAdapter {
									@Override
									protected void configure(AuthenticationManagerBuilder auth) throws Exception {
										auth.inMemoryAuthentication()
										  .withUser("user1").password(passwordEncoder().encoder("user1Pass")).roles("USER");
									}
								 
									@Override
									protected void configure(HttpSecurity http) throws Exception {
										http
										  .authorizeRequests()
										  .antMatchers("/login*").anonymous()
										  .anyRequest().authenticated()
										  .and()
										  .formLogin()
										  .loginPage("/login.html")
										  .defaultSuccessUrl("/homepage.html")
										  .failureUrl("/login.html?error=true")
										  .and()
										  .logout().logoutSuccessUrl("/login.html");
									}
								  
									@Bean
									public PasswordEncoder passwordEncoder() {
										return new BCryptPasswordEncoder();
									}
								}
										
	 </security>
   
   </6_spring_boot>
   
   <spring_boot_microservices>
   
   
       <note>
	   
         >> Microservices architecture allows to avoid monolith application for large system. It provide loose coupling between collaborating 
		    processes which running independently in different environments with tight cohesion. So lets discuss it by an example as below.

         >> For example imagine an online shop with separate microservices for user-accounts, product-catalog order-processing and shopping carts.
 		    So these components are inevitably important for such a large online shopping portal. For online shopping system we could 
			use following architectures.
			
			
			monolith : 
			           1. a large single upright block of stone, especially one shaped into or serving as a pillar or monument./
			           2. a large, impersonal political, corporate, or social structure regarded as indivisible and slow to change.
					      "independent voices have been crowded out by the media monoliths"
						  
						  
						  
			>> Difficulties with monolithic application, when it grow  
					1. Large monolithic code base makes complicated to understand, especially for new developer
					2. Scaling become challenging
					3. Continuously integration / deployment become complex and time consuming. You may require dedicated team for build and deploy
					4. Overloaded IDE, Large code base makes IDE slow, build time increase.
					5. Extremely difficult to change technology or language or framework because everything is tightly coupled and depend up on each other.
        
		
		    >> Privilege with Microservice architecture, when it grow  
					1. Each microservice is small and focused on a specific feature / business requirement.
					2. Microservice can be developed independently by small team of developers (normally 2 to 5 developers).
					3. Microservice is loosely coupled, means services are independent, in terms of development and deployment both.
					4. Microservice can be developed using different programming language (Personally I don't suggest to do it).
					5. Microservice allows easy and flexible way to integrate automatic deployment with Continuous Integration 
					     tools (for e.g: Jenkins, Hudson, bamboo etc..). The productivity of a new team member will be quick enough.
					6. Microservice allows you to take advantage of emerging and latest technologies (framework, programming language, 
					     programming practice, etc.).
					7. Microservice is easy to scale based on demand. In a nutshell, monolithic vs microservice architecture is like elephant vs ant approach.
					8. What you wants to build a giant system like elephant or army of ant, small, fast and effective.
			
			>> Microservices Challenges
					1. Difficult to achieve strong consistency across services
					2. ACID transactions do not span multiple processes.
					3. Distributed System so hard to debug and trace the issues
					4. Greater need for end to end testing
					5. Required cultural changes in across teams like Dev and Ops working together even in same team.					  
						  
			>> A. Shopping system without Microservices (Monolith architecture)
			      -------------------------------------------------------------
			
			           client                        web                mobile
													  |					  |	
					   -----------------------------------------------------------------------
					   server                         !     
												=============================================	 
												|	 shopping application                    |
												|		store/cart/config/order etc..	     |
												=============================================		
                                                         |
														 |
														 |
														( DB)
   
   
   
            >> B. Shopping system with Microservices 
			      ----------------------------------
                          
						  
			           client                        web                mobile
					   -----------------------------------------------------------------------
					                ================================================== 
					   server       |              API Gateways(s)                   |
                                    ==================================================

                                        !                   !                   !
									 -------             ---------            -----------
			        shoping sercice	|Store| <--------/> |Catelog|<---------/>| Cart    |
									 -------			 ---------		      -----------
                                        |                    |                    |
									  ( DB)                ( DB)                 ( DB)
				
             >> Loose Coupling– Effect of changes isolated
             >> Tight Cohesion– Code perform a single well defined task
				
				
			-----------------------------------------------------------------------------------


			>> 1. Using Spring for creating Microservices
			>> 2. Adding Spring Cloud and Discovery server
					What is Spring Cloud?
							1. It is building blocks for Cloud and Microservices
							2. It provides microservices infrastructure like provide use services such as Service Discovery, Configuration server and Monitoring.
							3. It provides several other open source projects like Netflix OSS.
							4. It provides PaaS like Cloud Foundry, AWS and Heroku.
							5. It uses Spring Boot style starters
							6. There are many use-cases supported by Spring Cloud like Cloud Integration, Dynamic Reconfiguration, Service Discovery, Security,Client side Load Balancing etc. But in this post we concentrate on following microservices support

								A. Service Discovery (How do services find each other?)
								B. Client-side Load Balancing (How do we decide which service instance to use?)
								
			>> Service Discovery
						>> Problem without discovery
						      A. How do services find each other?
						      B. What happens if we run multiple instances for a service		


							                                                                          which instnce to use
			        		                                                                                   !
									Need service discovery   ================                          ========================    (consider multiple instance)       
															|checkout service|-----------------------  |  cart service         |	 
															 ================                           ========================
																					
				
				
				
				
				
				
				
				        >> Resolution with service discovery
 
																	=====================
																	| Discovery Servers  |
																	=====================		
                                                                     
				                                     register checkout service
													 and find cart service in              
													 discovery servers
				                                                                                       register cart serives to 
																									   discoverys ervers
				                                 ================                          ========================    (consider multiple instance)       
												|checkout service|-----------------------  |  cart service         |	 
								                 ================                           ========================
         
		 
		 
		 >> Implementing Service Discovery
                      Spring Cloud support several ways to implement service discovery but for this I am going to use Eureka created by Netflix.
					  Spring Cloud provide several annotation to make it use easy and hiding lots of complexity.

		 >> Client-side Load Balancing
			      Each service typically deployed as multiple instances for fault tolerance and load sharing. But there is problem how 
				  to decide which instance to use?

         >> Implementing Client-Side Load Balancing
                   We will use Netflix Ribbon, it provide several algorithm for Client-Side Load Balancing. Spring provide smart 
				   RestTemplate for service discovery and load balancing by using 
				   @LoadBalanced annotation with RestTemplate instance.
				   
				   e.g.
				   
																	=====================
																	| Discovery Servers  |
																	=====================		
                                                                     
				                                     looks for cart-service
				                                                                                       register as cart-service
				                                 ================                          ========================         
												|checkout service|-----------------------  |  cart service         |	 
								                 ================                           ========================
		 
		 
		 
		 </note>
		 
		 <Developing_Simple_Microservices_Example>
		      
			       1.   Creating Discovery Service (Creating Eureka Discovery Service)
				   2. 	Creating MicroService (the Producer)
					          a. Register itself with Discovery Service with logical service.
				   3.   Create Microservice Consumers find Service registered with Discovery Service
					          a. Discovery client using a smart RestTemplate to find microservice.
							 
							 
		 
		 
		 </Developing_Simple_Microservices_Example>
		 
		 
		 
		 
		 
   </spring_boot_microservices>
     
   <7_spring_cloud>
   
         <netflix_cloud>
		     
			 >>  After officially using the Amazon's services, the Netflix started to become a software technology pioneer for cloud computing, 
			     doing the things that no one had done before. Most of their things ran on the Amazon Web Service (AWS), which was essentially a server 
			     infrastructure. At that time, the AWS did not really care about the software components. No one did; therefore, they had to invent
			     a necessary software technology so that their applications worked well in the cloud environment. 
             
			 >> Interestingly, cloud-based software technologies did not come from traditional IT companies that you are probably thinking 
			    of such as Oracle, Microsoft, IBM, or other companies, but they were invented by the companies actually working, including  
				Netflix, Amazone, and then Facebook.
               
			    Most the Netflix's resources are  implemented on the  Amazon Web Service (AWS). Below is their system architecture image.
			 
			 
			 
			 
			 spring cloud service ------------------spring cloud---------------------netflix OSS(netflix open source software)
			 
			                                                                        
																					GATEWAY
			                                   
			 NETFLIX        ........................ NETFLIX(DISCOVERY SERVICE)....................NETFLIX(CONFIG SERVICE)
			 
			 
		 
		 </netflix_cloud>
         
		 <SPRING_CLOUD_CONFIG>
		     		 
			 >> This is the first step for you to build a distributed application using Spring Cloud. 
			 
			 <Config_Server>
			 
						 1- Config Server - Why?
									OK, now we will discuss why you need to have a service that manages configurations for other services in a distributed application.
									Below is the illustration of a distributed application - " Taxi Management", including three sub-applications, 
									each of which is deployed on a server.

									>> TAXI MANAGEMENTS APPLICATION
								   
								   |  PASSENGER MANAGEMENT  |                    |   DRIVER MANAGEMENTS    |                |   TRIP  MANAGEMENT  |

								  
								  >>  Each service (application) is a project developed by a team of developers. In a project, apart from code, it contains configurations,
									  for example, information connected to database, information on location of data sources, etc. It will be a bad idea 
									  if You make hard code of this information in the project code. Therefore, this information is normally put in separate files,
									  which are referred to as configuration files. 					   
												
												E.G.         ===========================================
															 |                             PROJECT      | 
															 |   =======  								|
															 |	 |	   |           configuration files  |
															 |   |CODE |            .........           |
															 |    ======	         ...... |           |
															 |                             |            |
															 ============================================								

											   >> After being completed, the project will be packed and deployed onto the Server. Normally, configuration files 
												  will be packed together with the code and form a sole (file) product. Thus, if there are any changes in the 
												  configuration, you need to compile, and repack the project and re-deploy it onto the server. 
												  This is obviously a challenge in a distributed application environment.
															 
															 
						2. Config Server?
									 The idea to solve the above problem is that a service (application) is required to manage configurations for other services. 
									 It runs independently on a server.	

									
									>> TAXI MANAGEMENTS APPLICATION WITH config Server	


											   |  PASSENGER MANAGEMENT  |                    |   DRIVER MANAGEMENTS    |                |   TRIP  MANAGEMENT  |						
													 (client)		 								 (client)									 (client)	
														| 
														|
														|                                               !                                             !
														|                                               !                                             !
														|______________________________________> |   Config Server    | ..............................!
														
														
											   >> When you change a configuration file on the Config-Server, you will surely want to notify of such changes to Clients. 
												  The Spring Cloud Bus provides a mechanism for informing to Clients that "There is a change" and requires
												  the Clients to update new information.  		


													 ================                          ================
							  1.(update)-----------> |Git Repository | --------------------    |Config Server  |
													 |               |                         |               |
													 =================                          ===============
													 
													   
											  5.(get update from config server)				5.(get update from config server)			 5.(get update from config server)	
											  
								2. refresh		|  PASSENGER MANAGEMENT  |                    |   DRIVER MANAGEMENTS    |                |   TRIP  MANAGEMENT  |						
												 (client)		 								 (client)									 (client)
												 
												 
												 
																									!		
																								4. subscribe by diver managemnt
																							  ==================
																			3.update		 |  Cloud BUS     |     4. subscribe by diver managemnt  ----------!                              
																							  ================== 
						




						3. How does Config Server store data?
								  here are 2 main ways for the Config Server to store configuration files:
									1. Store them on the hard drive of the server as system files.
									2. Use GIT or SVN (Subversion).
						
						
						
						4. 
										   
					   <Create_Spring_Cloud_Config_Server>
					
										1. >> add spring-cloud-config-server dependency in pom
										2.  >> add @EnableConfigServer in starting of main class
										 
										 
														@EnableConfigServer  // ==> Important!!
														@SpringBootApplication
														public class SpringCloudConfigServerApplication {
														 
															public static void main(String[] args) {
																SpringApplication.run(SpringCloudConfigServerApplication.class, args);
															}
															 
														}
									
									
										 3. >> This service (application) will be deployed and run on port 8888 and store configuration 
											  files 
										   on the  GitHub, so you need some 
											configurations in the application.properties file.
											
											
														server.port=8888
						 
														spring.cloud.config.server.git.uri=https://github.com/o7planning/spring-cloud-config-git-repo-example.git
														 
														# For File System:
														# spring.profiles.active=native
														# spring.cloud.config.server.native.searchLocations=C:/Users/tran/Desktop/config
														
					  </Create_Spring_Cloud_Config_Server>
					
			</Config_Server>
			 
			 <Config_Client>
			 
			 
			   |  PASSENGER MANAGEMENT  |                    |   DRIVER MANAGEMENTS    |                |   TRIP  MANAGEMENT  |	         |About Company|  					
					 (client)		 								 (client)									 (client)	                 (client)
						| 
						|
						|                                               !                                             !
						|                                               !                                             !
						|______________________________________> |   Config Server    | ..............................!
				
			 
			 
			 
			 
			 >> In this lesson, we are going to create an "About Company" application. It is independent of " Passenger Management"  and " Diver Management" 
			    applications. For a big taxi company, for example, Uber, the number of users visiting their website is huge, it is a good idea 
				to have an application to introduce the company separate from other functions.
				
             >> The " About Company" application will use an independent database. Database configuration information will be managed on the Config-Server.
  			    In the Microservice architecture, this application is not simply a company introduction website; it can be a service 
				that provides information for other applications, for example, provision of information on hotline, feedback email, etc. In brief, 
				it is part of the Microservice system.

			 
												               -------------------------------------
                 |  PASSENGER MANAGEMENT  |                        pass---          call service  ---  about             |About Company| 
                                                               ------------------------------------ 													   


                                                                            --------------------------------
					                       |   DRIVER MANAGEMENTS    |      diver---    call service---    about     
			          
                                                     --------------------------------
													 
													 
				>>> The main objective of this Config_Client is to discuss and practise an example of 
				    " How an application can get its configuration information being managed on a Config-Server."									 
							

				  <Create_Spring_Cloud_Config_Client>	

                               1.  >> Config Client  dependency
							   2.  >> Web  dependency
								
							   3.  >> Configure Spring Cloud Config Client
								
								             This application needs to read its configurations stored on the Config-Server; therefore,  you need 
											 to tell it the information on the  Config-Server. This information is configured on the 
											 bootstrap.properties (or bootstrap.yml) file . This file is used very early by the application during 
											 the application startup.
											 
											 
								4. >> All sub/client applicaton configuration will be stored on Config Server.	


											  e.g.  app-about-company.....>

													>> bootstrap.properties

																# Read file on Config-Server:
																# app-about-company.properties or app-about-company.yml
																 spring.application.name=app-about-company
																 
																# This is the default:
																spring.cloud.config.uri=http://localhost:8888
																management.security.enabled=false		
																
													>> application.properties

															server.port=7777
															
													>> app-about.properties
																 all configuration releted to this app like database and other config on config cloud server										
																												
							    5. >> 

											@RefreshScope
											@RestController
											public class MainController 
											{
											 
												// https://github.com/o7planning/spring-cloud-config-git-repo-example
												// See: app-about-company.properties
												@Value("${text.copyright: Default Copyright}")
												private String copyright;
											 
												@Value("${spring.datasource.driver-class-name}")
												private String driverClassName;
											 
												@Value("${spring.datasource.url}")
												private String url;
											 
												@Value("${spring.datasource.username}")
												private String userName;
											 
												@Value("${spring.datasource.password}")
												private String password;
											 
												@Autowired
												private DataSource dataSource;
											 
												@RequestMapping("/showConfig")
												@ResponseBody
												public String showConfig() {
													String configInfo = "Copy Right: " + copyright //
															+ "br/>spring.datasource.driver-class-name=" + driverClassName //
															+ "br/>spring.datasource.url=" + url //
															+ "br/>spring.datasource.username=" + userName //
															+ "br/>spring.datasource.password=" + password;
											 
													return configInfo;
												}
											 
												@RequestMapping("/pingDataSource")
												@ResponseBody
												public String pingDataSource() {
													try {
														return this.dataSource.toString();
													} catch (Exception e) {
														e.printStackTrace();
														return "Error: " + e.getMessage();
													}
												}
											 
											}		

                             >> @RefreshScope:
                                          Any Spring Bean annotated by @RefreshScope will be refreshed at runtime. And any components that are using 
										  them will get a new instance on the next method call, fully initialized and injected with all dependencies.	
										  
				  </Create_Spring_Cloud_Config_Client>
  
			 </Config_Client>
			 
			 <sprin_cloud_eureka_server>
			 
			       >> OK, I'm sure that you've ever used a Chat application to talk to your friends on the Internet. When you log in the 
  				      Chat application on your computer, what will happen?
					  
				   >> You log in the Chat , which means that you inform with Chat Server that you are online.
					  The Chat Server will provide you with a list of other people. They are online or offline status.
					  And thus, you have discovered the list of online people and certainly, others also find out you.

                  >> In fact, when the number of  Chat users increases, the number of Chat Servers increases, and they have a way to share 
				     the status of the user.

                  >> You build a distributed system that consists of a lot of services (applications) running independently on different servers.
				     For these services are able to talk to each other, they need to "discover" each other. When discovering each other, 
					 they can call each other's services. Therefore, there needs to be something like the Chat Server to  help services (applications)
					 register its existence.
			 
			      >> It is  "Service Registration". All services (applications) of the distributed system have to be registered with 
				     the  "Service Registration". It is like the fact that all people in a country must register for birth certificate.
					 
			      >> There are many technologies for you to obtain a " Service Registration". The  Spring Cloud provides you with the following 
				     technology solutions:
						
						1. Eureka
						2. Zookeeper
						3. Cloud Foundry
						4. Consul
			     
				 
				 >>

				   Step 1:
								A >> Create one Service Registration using Spring Cloud Eureka Server.
								B >> Run this application directly on the Eclipse and view Eureka Monitor.
				   Step 2:
								A >> Create replicas for application to deploy on different servers. Each replica will run a different domain name. 
								   Herein, we assume that the system has a lot of users therefore, many replicas are required to run on different servers
								   to reduce overload 
								B >> Explain the status sharing mechanism between Eureka Servers.
											 
			                    e.g. 
								
								
								            1. SERVICE REGISTRATION--my-eureka-server-us.com:90001
											                          united states
																	  
																	  
																	  2. SERVICE REGISTRATION--my-eureka-server-fr.com:90001
											                                           france
																	  
																	  
																				  3. SERVICE REGISTRATION--my-eureka-server-ind.com:90001
																				         india
			 
			        <create_eureka_server>
					
			                   1. >> add eureka Server Dependency
							   2. >> add @EnableEurekaServer in main starting point class

							               For this application becomes a Service Registration, you need to use @EnableEurekaServer. This Annotation
										   informs to the Spring that you should run a registration service by Netflix technology (Netflix Eureka).
										   
											SpringCloudServiceRegistrationEurekaServerApplication.java

											package org.o7planning.eurekaserver;
											 
											import org.springframework.boot.SpringApplication;
											import org.springframework.boot.autoconfigure.SpringBootApplication;
											import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;
											 
											@EnableEurekaServer
											@SpringBootApplication
											public class SpringCloudServiceRegistrationEurekaServerApplication 
											{
											 
												   public static void main(String[] args) {
													    SpringApplication.run(SpringCloudServiceRegistrationEurekaServerApplication.class, args);
												   }
												 
											}
							   3. application.properties

                                        <application_properties>
										
																---
																# This default profile is used when running a single instance completely standalone:
																spring:
																  profiles: default
																server:
																  port: 9000  
																eureka:
																  instance:
																	hostname: my-eureka-server.com
																  client:
																	registerWithEureka: false
																	fetchRegistry: false
																	serviceUrl:
																	  defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/    
																 
																# united-states, france, and vietnam illustrate running 3 intercommunicating instances.  
																# This example has them running side-by-side on localhost
																# -- which is unrealistic in production
																# -- but does illustrate how multiple instances collaborate.
																#
																# Run by opening 3 separate command prompts:
																# java -jar -Dspring.profiles.active=united-states SpringCloudServiceRegistrationEurekaServer.jar
																# java -jar -Dspring.profiles.active=france SpringCloudServiceRegistrationEurekaServer.jar
																# java -jar -Dspring.profiles.active=vietnam SpringCloudServiceRegistrationEurekaServer.jar
																 
																---
																spring:
																  profiles: united-states
																  application:
																	name: eureka-server-clustered   # ==> This is Service-Id
																server:
																  port: 9001  
																eureka:
																  instance:
																	hostname: my-eureka-server-us.com    
																  client:
																	registerWithEureka: true
																	fetchRegistry: true       
																	serviceUrl:
																	  defaultZone: http://my-eureka-server-fr.com:9002/eureka/,http://my-eureka-server-vn.com:9003/eureka/
																 
																---
																spring:
																  profiles: france
																  application:
																	name: eureka-server-clustered   # ==> This is Service-Id   
																server:
																  port: 9002
																eureka:
																  instance:
																	hostname: my-eureka-server-fr.com      
																  client:
																	registerWithEureka: true
																	fetchRegistry: true       
																	serviceUrl:
																	  defaultZone: http://my-eureka-server-us.com:9001/eureka/,http://my-eureka-server-vn.com:9003/eureka/
																 
																---
																spring:
																  profiles: vietnam
																  application:
																	name: eureka-server-clustered    # ==> This is Service-Id  
																server:
																  port: 9003
																eureka:
																  instance:
																	hostname: my-eureka-server-vn.com    
																  client:
																	registerWithEureka: true
																	fetchRegistry: true   
																	serviceUrl:
																	  defaultZone: http://my-eureka-server-us.com:9001/eureka/,http://my-eureka-server-fr.com:9002/eureka/   
																			   
										</application_properties>								   
							   
							   
							   
							   4. When you run this application directly on Eclipse, the default profile will be used to configure this application.
							   5. Eureka Monitor allows you to see the list of active and registered services (applications) with this Eureka Server,
  							      and see the replicas of this application running on the distributed system. You can access the
							      Eureka Monitor by the URL below.
								  
								  
							   6. "Default" profile is configured to run on  my-eureka-server.com domain name. By configuring the domain name on 
							      the  "hosts" file, you can obtain such domain name.
								  
									>> On the  Windows, open the file:
									   C:\Windows\System32\drivers\etc\hosts
									
									>> Add the following configuration snippet:
									   C:\Windows\System32\drivers\etc\hosts

										127.0.0.1       my-eureka-server.com
										127.0.0.1       my-eureka-server-us.com
										127.0.0.1       my-eureka-server-fr.com
										127.0.0.1       my-eureka-server-vn.com  
										
									
								7. Run many replicas	
								    
									  1. First of all, you need to use the " Maven Install" function to create the jar file. Right click on the project and select:
									  2. After running "Maven Install" successfully, you get a jar file located in the target directory of the project. 
									  3. Copy the  jar file just created to a directory and create 3  CMD files:
												eureka-server-us.bat
												eureka-server-fr.bat
												eureka-server-vn.bat
												
												
												my-eureka-server-us.bat
												java -jar -Dspring.profiles.active=united-states SpringCloudServiceRegistrationEurekaServer-0.0.1-SNAPSHOT.jar
												
												my-eureka-server-fr.bat
												java -jar -Dspring.profiles.active=france SpringCloudServiceRegistrationEurekaServer-0.0.1-SNAPSHOT.jar
												
												my-eureka-server-vn.bat
												java -jar -Dspring.profiles.active=vietnam SpringCloudServiceRegistrationEurekaServer-0.0.1-SNAPSHOT.jar
												
                                       4. We are simulating the creation of three replicas and deployment of them on three different servers,
									      with three different domain names.   

										  
					</create_eureka_server>	

					
			 </sprin_cloud_eureka_server>
			 
			 <spring_cloud_eureka_client>
			 
			          |  PASSENGER MANAGEMENT  |                                |   TRIP  MANAGEMENT  |
			 
			 
			 
			                                    |   SERVICE REGISTRATION    |   
			 
			 
			 
			                                     |   DRIVER MANAGEMENTS    |   
												 
												 
                    >>  In this lesson, we will discuss how to configure a service (application) in a distributed system so that it becomes an Eureka Client.
  					    This means that it will be registered with " Registration Serivce" ( Eureka Server). 	
                    
					>>  Eureka Clients will have the list of other  Eureka Clients, we will manipulate these lists with the  Java code. 

                    <create_eureka_client>
                               
							   1. add web dependency
							   2. add Eureka Discovery dependency
							   3. add  @EnableEurekaClient
							   
							                    @EnableEurekaClient
												@SpringBootApplication
												public class SpringCloudDiscoveryEurekaClientApplication {
												 
													public static void main(String[] args) {
														SpringApplication.run(SpringCloudDiscoveryEurekaClientApplication.class, args);
													}
													 
												}
							   4. add application.properties/application.yml
							        
									     <application_properties>
							   
							                       spring:
														  application:
															name: ABC-SERVICE # ==> This is Service-Id
															 
														 
														---
														# Items that apply to ALL profiles:   
														eureka:
														  instance:
															appname: ABC-SERVICE  # ==> This is a instance of ABC-SERVICE
														  client:   
															fetchRegistry: true
															serviceUrl:
														#      defaultZone: http://my-eureka-server.com:9000/eureka
															  defaultZone: http://my-eureka-server-us.com:9001/eureka
														#      defaultZone: http://my-eureka-server-fr.com:9002/eureka
														#      defaultZone: http://my-eureka-server-vn.com:9003/eureka
														server:
														  port: 8000  
														  
														---
														spring:
														  profiles: abc-service-replica01
														eureka:
														  instance:
															appname: ABC-SERVICE  # ==> This is a instance of ABC-SERVICE
														  client:   
															fetchRegistry: true
															serviceUrl:
															  defaultZone: http://my-eureka-server-us.com:9001/eureka  
														server:
														  port: 8001   
															 
														---
														spring:
														  profiles: abc-service-replica02
														eureka:
														  instance:
															appname: ABC-SERVICE  # ==> This is a instance of ABC-SERVICE
														  client:   
															fetchRegistry: true
															serviceUrl:
															  defaultZone: http://my-eureka-server-us.com:9001/eureka    
														server:
														  port: 8002
														  
														---
														spring:
														  profiles: abc-service-replica03
														eureka:
														  instance:
															appname: ABC-SERVICE  # ==> This is a instance of ABC-SERVICE
														  client:   
															fetchRegistry: true
															serviceUrl:
															  defaultZone: http://my-eureka-server-us.com:9001/eureka    
														server:
														  port: 8003
														  
														---
														spring:
														  profiles: abc-service-replica04
														eureka:
														  instance:
															appname: ABC-SERVICE  # ==> This is a instance of ABC-SERVICE
														  client:   
															fetchRegistry: true
															serviceUrl:
															  defaultZone: http://my-eureka-server-us.com:9001/eureka    
														server:
														  port: 8004  
														  
														---
														spring:
														  profiles: abc-service-replica05
														eureka:
														  instance:
															appname: ABC-SERVICE  # ==> This is a instance of ABC-SERVICE
														  client:   
															fetchRegistry: true
															serviceUrl:
															  defaultZone: http://my-eureka-server-us.com:9001/eureka    
														server:
														  port: 8005
														  
							           </application_properties>
								
								5. @Controller
								
								   >> When  Eureka Clients register with  Eureka Server (Service Registration), they can get the list of other  
								      Eureka Clients registered with the  Eureka Server.
									  
									     >>                 @Autowired
															private DiscoveryClient discoveryClient;
															 
															...
															 
															// Get All Service Ids
															List String> serviceIds = this.discoveryClient.getServices();
															 
															 
															// (Need!!) eureka.client.fetchRegistry=true
															List ServiceInstance> instances = this.discoveryClient.getInstances(serviceId);
															 
															 
															for (ServiceInstance serviceInstance : instances) {
																System.out.println("URI: " + serviceInstance.getUri();
																System.out.println("Host: " + serviceInstance.getHost();
																System.out.println("Port: " + serviceInstance.getPort();
															}
															
														--------------------------

														@RestController
														public class MainController {
														 
															@Autowired
															private DiscoveryClient discoveryClient;
														 
															@ResponseBody
															@RequestMapping(value = "/", method = RequestMethod.GET)
															public String home() {
														 
																return " a href='showAllServiceIds'>Show All Service Ids /a>";
															}
														 
															@ResponseBody
															@RequestMapping(value = "/showAllServiceIds", method = RequestMethod.GET)
															public String showAllServiceIds() {
														 
																List String> serviceIds = this.discoveryClient.getServices();
														 
																if (serviceIds == null || serviceIds.isEmpty()) {
																	return "No services found!";
																}
																String html = " h3>Service Ids: /h3>";
																for (String serviceId : serviceIds) {
																	html += " br> a href='showService?serviceId=" + serviceId + "'>" + serviceId + " /a>";
																}
																return html;
															}
														 
															@ResponseBody
															@RequestMapping(value = "/showService", method = RequestMethod.GET)
															public String showFirstService(@RequestParam(defaultValue = "") String serviceId) {
														 
																// (Need!!) eureka.client.fetchRegistry=true
																List ServiceInstance> instances = this.discoveryClient.getInstances(serviceId);
														 
																if (instances == null || instances.isEmpty()) {
																	return "No instances for service: " + serviceId;
																}
																String html = " h2>Instances for Service Id: " + serviceId + " /h2>";
														 
																for (ServiceInstance serviceInstance : instances) {
																	html += " h3>Instance: " + serviceInstance.getUri() + " /h3>";
																	html += "Host: " + serviceInstance.getHost() + " br>";
																	html += "Port: " + serviceInstance.getPort() + " br>";
																}
														 
																return html;
															}
														 
															// A REST method, To call from another service.
															// See in Lesson "Load Balancing with Ribbon".
															@ResponseBody
															@RequestMapping(value = "/hello", method = RequestMethod.GET)
															public String hello() {
														 
																return " html>Hello from ABC-SERVICE /html>";
															}
														 
														}														
								


                                6.  Run Eureka Server
								7. create jar of client  and create bat w.r.t client profile
								
								            >> abc-service-replica01.bat
											   java -jar -Dspring.profiles.active=abc-service-replica01 SpringCloudDiscoveryEurekaClient-0.0.1-SNAPSHOT.jar
											
											>> abc-service-replica02.bat
											    java -jar -Dspring.profiles.active=abc-service-replica02 SpringCloudDiscoveryEurekaClient-0.0.1-SNAPSHOT.jar
											
											>> abc-service-replica03.bat
											     java -jar -Dspring.profiles.active=abc-service-replica03 SpringCloudDiscoveryEurekaClient-0.0.1-SNAPSHOT.jar
											
											>> abc-service-replica04.bat
											     java -jar -Dspring.profiles.active=abc-service-replica04 SpringCloudDiscoveryEurekaClient-0.0.1-SNAPSHOT.jar
											
											>> abc-service-replica05.bat
											     java -jar -Dspring.profiles.active=abc-service-replica05 SpringCloudDiscoveryEurekaClient-0.0.1-SNAPSHOT.jar
											
								8.   Run the 2  BAT files:
								9.   On the  Eureka Monitor, you can see the  Eureka Clients registered with the  Eureka Server.
								10.  Test Discovery
												OK, after running the  Eureka Client, you can view how it discovers other  Eureka Clients.
												Visit the  URL below (Note: wait for 30 seconds to ensure that the  Eureka Server and the 
 												Eureka Client have updated each other's statuses fully).
												
												http://localhost:8000         (If Eureka Client run from Eclipse)
												http://localhost:8001         (If Eureka Client run from BAT file)
                    </create_eureka_client>					
			 
			 </spring_cloud_eureka_client>
			 
			 <spring_cloud_load_balancer_ribbon>
			 
			         >> Let's imagine that you have a distributed system that consists of many services (applications) running on different computers. 
					    However, when the number of users is large, a service (application) is usually created multiple replicas. Each replica 
						runs on a different computer. At this time, " Load Balancer" appears. It helps to distribute incoming traffic equally among servers.
						
						
						                                                                   ABC Service
																						      replica 1
						
						
						
						
						(SOME SERVICE)--Client                                             ABC Service
																						      replica 2
			 
			                                                                                  ......
																							  
																							  
																						   ABC Service
																						      replica 3
			 
			 
			 
			 
			 
			         Server side Load Balancer
					 ---------------
			        >> Traditionally, Load Balancers are components placed at the Server Side. When the requests come from the Client,
   					   they will go to the load balancer, and the load balancer will designate a Server for the request. The simplest
					   algorithm used by the load balancer is random designation. Most load balancers in this case are hardware, 
					   integrated software to control load balancing.
					   
					   
					                                                            |-------->    [APPLICATION]
									(HTTP,TCP,UDP TRaffic)						|
					             --------> [ load balancer ]  ----------------> |-------->    [APPLICATION]
																				|	
																				|-------->	  [APPLICATION]
																				
																				
																				
					Client-Side Load Balancer:
					-----------------------
					>> When the load balancer is located at Client  side, it will actively decide which server it will send requests
					   to based on some criteria 
					   
					   
					   
					                                                            |-------->    [SERVER LOAD BALANCING]
									              ( HTTP,TCP,UDP TRaffic)	    |
					  [APPLICATION ]          --------> [ load balancer ]  ---> |-------->    [SERVER LOAD BALANCING]
																				|	
																				|-------->	  [SERVER LOAD BALANCING]
					
					>> Actually, servers are different. They differ from each other in the following criteria:
							1. Availability: No server also works at all times.
							2. Performance: The speed of servers is different.
							3. Geography: Servers are located in different locations, for instance, they are located in different countries. 
							   They may be close to this Client but far from other Client.
							
							>Client-side load balancers usually send requests to servers in the same zone, or with a fast response.
							
							
					<Netflix_Ribbon>	
					
					      >> Ribbon is part of  Netflix Open Source Software (Netflix OSS) family. It is a library that provides a Client-side load balancer. 
						     Because it is a member of the Netflix family, it can automatically interact with Netflix Service Discovery (Eureka).
						
						  >> Spring Cloud creates  APIs to help you to easily use  Ribbon libraries.
							    OK, We will discuss the main concepts related to the Ribbon :
										
										1. List of servers.
										       A list of servers that can respond to a particular service for 1 Client. For example, 1 Client needs 
											   information about the weather. There will be a list of servers being able to provide this information.
											   This list consists of servers configured directly in the Client application, and servers discovered 
											   by the Client.
										
										
										2. Filtered list of servers.
										       We continue the above example. One Client needs weather information, and a list of servers can 
											   provide such information. However, not all of those servers operate, or those servers are too far 
											   from the Client; therefore, they responds very slowly. The Client will remove these servers
											   from the list, and eventually it will have a more suitable list of servers  (a filtered list).
										
										3. Load Balancer
										      >> Ribbon is a load balancer. It is a Client -side component. It decides which server will be 
											     called (of the filtered list of servers).
												 
                                              >> There are some strategies to make a decision. But they usually rely on a " Rule Component" 
											     to make a true decision. By default, the Spring Cloud Ribbon uses the ZoneAwareLoadBalancer
												 strategy  (Servers in the same zone as Client).
												 
                                              >> Rule Component is a smart module. It creates a " Call or uncall" decision. By default, Spring Cloud
 											     uses the ZoneAvoidanceRule rule.
										     
										4. Ping
										      >> Ping is the way that the  Client uses to rapidly check whether a server is active at that time or not?
  											    The default behavior of Spring Cloud is to delegate  Eureka to automatically check this information.
												However, the Spring Cloud allows you to customize to check in your way. 

                            
							>> In this lesson, we are going to create a "XYZ Service" application. It is also a Discovery Client (Eureka Client) and 
							   it will call  "ABC Service". On the "XYZ Service" application, we will use a load balancer. 
                            >> To be able to test this application, we need to run all three applications, of which, "ABC Service"
							   application will be created 5 replicas (simulating that it is running on 5 different computers). When
							   the Client (XYZ Service) calls the "ABC Service", the load balancer will decide which replica of "ABC Service" is called.
							   
							   
																								EUREKA SERVER
																							 [ SERVICE REGISTRATION ]
											   
											   
																										EUREKA CLIENT
											   XYZ SERVICE    [LOAD BALANCER]                       ABC SERVICE1
																									ABC SERVICE2
																									ABC SERVICE3
																					
							<CREATE_PROJECT_LOAD_BALANCER_RIBBON>
							
							      1.  The application being used by us will call "ABC Service". It needs a Load Balancer ; therefore, we will declare 
								      the use of Ribbon library.
									 
                                  2.  This application should also discover other services (applications) running in the distributed system; therefore,
 								      it needs to use Discovery library. We will use Eureka Discovery (Eureka Client).
							      
								  3. ADD WEB/RIBBON/EUREKADISCOVERY
								  
								  4. Configure Ribbon
								      
									  <APPLICATION_YML>
									  
									              spring:
													  application:
														name: XYZ-SERVICE
													  
													server:
													  port: 5555
													 
													# -- Configure for Ribbon:
													  
													ping-server:
													  ribbon:
														eureka:
														  enabled: false # Disable Default Ping
														listOfServers: localhost:8000,localhost:8001,localhost:8002,,localhost:8003
														ServerListRefreshInterval: 15000
														 
													# -- Configure Discovery Client (Eureka Client).    
													# Configure this application to known "Service Registration".
													 
													eureka:
													  instance:
														appname: XYZ-SERVICE  # ==> This is an instance of XYZ-SERVICE
													  client:   
														fetchRegistry: true
														serviceUrl:
													#      defaultZone: http://my-eureka-server.com:9000/eureka
														  defaultZone: http://my-eureka-server-us.com:9001/eureka
													#      defaultZone: http://my-eureka-server-fr.com:9002/eureka
													#      defaultZone: http://my-eureka-server-vn.com:9003/eureka   

									  
									  </APPLICATION_YML>
								  
								  5.        @RibbonClient(name = "ping-a-server", configuration = RibbonConfiguration.class)
											@EnableEurekaClient
											@SpringBootApplication
											public class SpringCloudLoadBalancerRibbonApplication {
											 
												public static void main(String[] args) {
													SpringApplication.run(SpringCloudLoadBalancerRibbonApplication.class, args);
												}
											 
											}
								  
								  6.     public class RibbonConfiguration {
     
												@Autowired
												private IClientConfig ribbonClientConfig;
											  
												@Bean
												public IPing ribbonPing(IClientConfig config) {
													return new PingUrl();
												}
											  
												@Bean
												public IRule ribbonRule(IClientConfig config) {
													return new WeightedResponseTimeRule();
												}
												 
											} 			
																			  
								 7. CONTROLLER

																	@RestController
																	public class Example1Controller {
																	 
																		@Autowired
																		private DiscoveryClient discoveryClient;
																	 
																		@Autowired
																		private LoadBalancerClient loadBalancer;
																	 
																		@ResponseBody
																		@RequestMapping(value = "/", method = RequestMethod.GET)
																		public String home() {
																	 
																			return "a href='testCallAbcService'>/testCallAbcService /a>";
																		}
																	 
																		@ResponseBody
																		@RequestMapping(value = "/testCallAbcService", method = RequestMethod.GET)
																		public String showFirstService() {
																	 
																			String serviceId = "ABC-SERVICE".toLowerCase();
																	 
																			// (Need!!) eureka.client.fetchRegistry=true
																			List ServiceInstance> instances = this.discoveryClient.getInstances(serviceId);
																	 
																			if (instances == null || instances.isEmpty()) {
																				return "No instances for service: " + serviceId;
																			}
																			String html = " h2>Instances for Service Id: " + serviceId + " /h2>";
																	 
																			for (ServiceInstance serviceInstance : instances) {
																				html += " h3>Instance :" + serviceInstance.getUri() + " /h3>";
																			}
																	 
																			// Create a RestTemplate.
																			RestTemplate restTemplate = new RestTemplate();
																	 
																			html += "br>h4>Call /hello of service: " + serviceId + "/h4>";
																	 
																			try {
																				// May be throw IllegalStateException (No instances available)
																				ServiceInstance serviceInstance = this.loadBalancer.choose(serviceId);
																	 
																				html += "br>===> Load Balancer choose: " + serviceInstance.getUri();
																	 
																				String url = "http://" + serviceInstance.getHost() + ":" + serviceInstance.getPort() + "/hello";
																	 
																				html += "br>Make a Call: " + url;
																				html += "br>";
																	 
																				String result = restTemplate.getForObject(url, String.class);
																	 
																				html += "br>Result: " + result;
																			} catch (IllegalStateException e) {
																				html += "br>loadBalancer.choose ERROR: " + e.getMessage();
																				e.printStackTrace();
																			} catch (Exception e) {
																				html += "br>Other ERROR: " + e.getMessage();
																				e.printStackTrace();
																			}
																			return html;
																		}
																	 
																	}								 
							
							</CREATE_PROJECT_LOAD_BALANCER_RIBBON>



							
                    </Netflix_Ribbon>						
					
			 </spring_cloud_load_balancer_ribbon>
			 			 
		 </SPRING_CLOUD_CONFIG>
   
   
   
   </7_spring_cloud>   
  
   <spring_security>
         
		 <info>
      
					   Spring Security is a framework which provides various security features like: authentication, authorization to create secure Java Enterprise Applications.

					   It is a sub-project of Spring framework which was started in 2003 by Ben Alex. Later on, in 2004, It was released under the Apache License as Spring Security 2.0.0.

					   It overcomes all the problems that come during creating non spring security applications and manage new server environment for the application.

					   This framework targets two major areas of application are authentication and authorization. Authentication is the process of knowing and identifying the user that wants to access.

					   Authorization is the process to allow authority to perform actions in the application.

					   We can apply authorization to authorize web request, methods and access to individual domain.
					   
					   
					  >>>Spring Security Features
								LDAP (Lightweight Directory Access Protocol)
								Single sign-on
								JAAS (Java Authentication and Authorization Service) LoginModule
								Basic Access Authentication
								Digest Access Authentication
								Remember-me
								Web Form Authentication
								Authorization
								Software Localization
								HTTP Authorization
								
					  >>> Features added in Spring Security 5.0
									OAuth 2.0 Login
										This feature provides the facility to the user to login into the application by using their existing account at GitHub or Google. This feature is implemented by using the Authorization Code Grant that is specified in the OAuth 2.0 Authorization Framework.

									Reactive Support
										From version Spring Security 5.0, it provides reactive programming and reactive web runtime support and even, we can integrate with Spring WebFlux.

									Modernized Password Encoding
										Spring Security 5.0 introduced new Password encoder DelegatingPasswordEncoder which is more modernize and solve all the problems of previous encoder NoOpPasswordEncoder.			

					  >>> Core - spring-security-core.jar
									This is core jar file and required for every application that wants to use Spring Security. 
									This jar file includes core access-control and core authentication classes and interfaces. 
									We can use it in standalone applications or remote clients applications.

									It contains top level packages:

									org.springframework.security.core
									org.springframework.security.access
									org.springframework.security.authentication
									org.springframework.security.provisioning
									
					  >>>Remoting - spring-security-remoting.jar
									This jar is used to integrate security feature into the Spring remote application.
									We don't need it until or unless we are creating remote application. All the classes and interfaces are located 
									into org.springframework.security.remoting package.

					  >>>Web - spring-security-web.jar
									This jar is useful for Spring Security web authentication and URL-based access control. 
									It includes filters and web-security infrastructure.

									All the classes and interfaces are located into the org.springframework.security.web package.

					  >>>Config - spring-security-config.jar
								   This jar file is required for Spring Security configuration using XML and Java both. 
								   It includes Java configuration code and security namespace parsing code. All the classes and interfaces
								   are stored in org.springframework.security.config package.

					  >>>LDAP - spring-security-ldap.jar
								  This jar file is required only if we want to use LDAP (Lighweight Directory Access Protocol). 
								  It includes authentication and provisioning code. All the classes and interfaces are stored 
								  into org.springframework.security.ldap package.

					  >>>OAuth 2.0 Core - spring-security-oauth2-core.jar
								 This jar is required to integrate Oauth 2.0 Authorization Framework and OpenID Connect Core 1.0 
								 into the application. This jar file includes the core classes for OAuth 2.0 and classes are stored 
								 into the org.springframework.security.oauth2.core package.

					  >>>OAuth 2.0 Client - spring-security-oauth2-client.jar
								 This jar file is required to get client support for OAuth 2.0 Authorization Framework and OpenID Connect Core 1.0.
								 This module provides OAuth login and OpenID client support. All the classes and interfaces are available 
								 from org.springframework.security.oauth2.client package.

					  >>>OAuth 2.0 JOSE - spring-security-oauth2-jose.jar
								It provides Spring Security's support for the JOSE (Javascript Object Signing and Encryption) framework. 
								The JOSE framework provides methods to establish secure connection between clients. 
								It contains following collection of specifications:

									JWT (JSON Web Token)
									JWS (JSON Web Signature)
									JWE (JSON Web Encryption)
									JWK (JSON Web Key)
									All the classes and interfaces are available into these two packages:

									org.springframework.security.oauth2.jwt and org.springframework.security.oauth2.jose.

					  >>>ACL - spring-security-acl.jar
								This jar is used to apply security to domain object in the application. We can access classes and code from
								the org.springframework.security.acls package.

					  >>>CAS - spring-security-cas.jar
							   It is required for Spring Security?s CAS client integration. We can use it to integrate Spring Security web authentication 
							   with CAS single sign-on server. The source code is located into org.springframework.security.cas package.

					  >>>OpenID - spring-security-openid.jar
							  This jar is used for OpenID web authentication support. We can use it to authenticate users against an external OpenID server.
							  It requires OpenID4Java and top level package is org.springframework.security.openid.								  
								   
            
                      <jar_required>
					       1.  spring-security-core
						   2.  spring-security-web
					       3.  spring-security-config
						   4.  spring-security-taglibs
					  </jar_required>
					  
					  <in_web_xml>
					  
							<filter>
								<filter-name>springSecurityFilterChain</filter-name>
								<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
							</filter>
						 
							<filter-mapping>
								<filter-name>springSecurityFilterChain</filter-name>
								<url-pattern>/*</url-pattern>
							</filter-mapping>
							
							 <context-param>
									<param-name>contextConfigLocation</param-name>
									<param-value>/WEB-INF/application-security.xml</param-value>
								</context-param>
					  
					  </in_web_xml>
					  
					  <in_security_xml>
					  
											  <http auto-config="true" use-expressions="true" > 
													  <intercept-url pattern="/" access="permitAll"  /> 
													  <intercept-url pattern="/user**" access="hasRole('ROLE_USER')"  />
													  <intercept-url pattern="/admin**" access="hasRole('ROLE_ADMIN')"  /> 
													  <csrf disabled="true"/>
													<!-- <form-login login-page="/index.jsp" authentication-failure-url="/index.jsp"  />    -->
											  </http>
											  
											  <authentication-manager>
													  <authentication-provider>
															    <user-service>
																       <user name="maq" password="123" authorities="ROLE_ADMIN"  />
																       <user name="abc" password="987" authorities="ROLE_USER" />
																</user-service>
															    <jdbc-user-service data-source-ref="dataSource" 
																			   authorities-by-username-query="select username,authority from UserRole where username = ?" 
																			   users-by-username-query="select username,password,user_id from UserRole where username =?" >
																 </jdbc-user-service>			    
													  </authentication-provider>
											  </authentication-manager>
											  
											  
											  <Note>
											      
												    1. if you want to use default username/authorities databse schema then 
														 in authentication manager in spring security xml
														 -------
														         jdbc-user-service data-source-ref="dataSource" 
																 /jdbc-user-service>	
														 
														 
                                                         and in databse
														 -------
																	User Schema
																	The standard JDBC implementation of the UserDetailsService (JdbcDaoImpl) requires tables to load the password, 
																	account status (enabled or disabled) and a list of authorities (roles) for the user.

																	  create table users(
																		  username varchar_ignorecase(50) not null primary key,
																		  password varchar_ignorecase(50) not null,
																		  enabled boolean not null);

																	  create table authorities (
																		  username varchar_ignorecase(50) not null,
																		  authority varchar_ignorecase(50) not null,
																		  constraint fk_authorities_users foreign key(username) references users(username));
																		  create unique index ix_auth_username on authorities (username,authority);
														 
												  
												  
												  
											  </Note>
											  
											  // and dataSource configuration in security xml
											  
											  <for_custom_login>
											  
											                 <http auto-config="true" use-expressions="true" >
           
														              <intercept-url pattern="/" access="isAuthenticated()"  /> 
														              <intercept-url pattern="/user" access="hasRole('USER')"  />
															           <intercept-url pattern="/home" access="isAuthenticated()"  />


                                                                       <form-login login-page="/login" login-processing-url="/j_spring_security_check" default-target-url="/home" 
																	    always-use-default-target="true"  password-parameter="j_password" username-parameter="j_username" /> 

                                                                        <logout invalidate-session="true"  logout-url="/logout" logout-success-url="/index.jsp" />
        
        
                                                                      <csrf disabled="true"/>
         
																	   <session-management invalid-session-url="/"  >
																		   <concurrency-control error-if-maximum-exceeded="true" max-sessions="1" expired-url="/" />
																	   </session-management>
																	 
															  </http>
											  
											  </for_custom_login>
											  
											  
					  </in_security_xml>
					  
					  
					  <in_jsp>
					      
						           form name="form" action="c:url value='j_spring_security_check'/>" method="post">
						  
											 <!-- Print the logged in user name -->
										<security:authorize access="isAuthenticated()">
										      <security:authentication property="principal.username" />
										</security:authorize>
										
								   >> to check url in jsp for perticular user access 
								            <security:authorize url="/user/secure"  access="hasROle('USER')">
			                                        Guest
			                                </security:authorize>
								   >> to create model attribute in controller to return authentication object for perticualar case.
								        @modelAttribute("isUser")
										public booolean isUser(Authentication Auth)
										{
										    return auth!=null && ath.getAuthorities().contains(AuthorityUtils.createAuthorityList("Role_user").gte(0));
										}
										
										    <security:authorize url="/user/secure"  access="${isUser}">
			                                        Guest
			                                </security:authorize>
										
											
								   
					  
					  </in_jsp>
                     
					 
			<datasource_in_xml_config_and_security_spring_config_in_xml>
			
			         then specify all xml configuratiion in context_param
			
			</datasource_in_java_config_and_security_spring_config_in_xml>		 
					
					
			<datasource_in_java_config_and_security_spring_config_in_xml>
			
			          1. write seperate java config class
					        @Configuration
							@EnableTransactionManagement
							public class HibernateConfig 
							{
								
											@Bean(name="dataSource")
											public DataSource dataSource() 
											{
												BasicDataSource dataSource = new BasicDataSource();
												dataSource.setDriverClassName("com.mysql.jdbc.Driver");
												dataSource.setUrl("jdbc:mysql://localhost:3306/entbsshm_car_wash");
												dataSource.setUsername("entbsshm_root");
												dataSource.setPassword("admin");
												
												System.out.println("new datsource from java config returned");
												return dataSource;
											}
											
											public Properties hibernateProperties() 
											{
												return new Properties() {
													{
														setProperty("hibernate.hbm2ddl.auto", "update");
														setProperty("hibernate.dialect", "org.hibernate.dialect.MySQL5InnoDBDialect");
														setProperty("hibernate.show_sql", "true");
													}
												};
											}
										}
					
					2. now specify configuration class packages in spring xml
                                        context:component-scan base-package="com.mvc.controller"/> 
										context:component-scan base-package="com.test.hibernate.config"/> 									 
										mvc:annotation-driven />
										context:annotation-config> /context:annotation-config>
										
					3. All xml configuration file spring or security should be in contextConfigLocation.					
    
    				3. Use dataSource or any bean declared in java config into xml e.g. 

										jdbc-user-service data-source-ref="dataSource" 
													   authorities-by-username-query="select username,authority from UserRole where username = ?" 
													   users-by-username-query="select username,password,user_id from UserRole where username =?" />   					
	
					 
			
			
			
			
			
			</datasource_in_java_config_and_security_spring_config_in_xml>
			
			
			<Note1>
			    
				 1. To check authorites for page/url specific.. only username and authorites/roles is used.
                    here security is applied to check wheather specific page/url is authorized or not for this current user.
                    
					
					>> permission is something different like if user is successfully loged in with proper authorization then 
                         some content might be person/dept/subgroup specific.  					
				
				
				
			</Note1>
			
			<Note2>
			
			    1. Bydefault HasRole check "ROLE_" TO ROLES  and e.g. 
				    
					a. if database column authority contains 'USER' and hasRole('USER') will not work ---in authentication manger/provider will have
					to specify role-prefix to 'ROLE_'.
					b. if database column authority contains 'ROLE_USER' and hasRole('USER') and role_prefix="ROLE_" ----  will not work because multiple 'ROLE_' One in databse and 
					        another in role_prefix. 
			
					
			</Note2>
			
         </info>
		  
		 <JdbcDaoImpl>
		 
                 Spring Security also includes a UserDetailsService that can obtain authentication information from a JDBC
				 data source. Internally Spring JDBC is used, so it avoids the complexity of a fully-featured object 
				 relational mapper (ORM) just to store user details. If your application does use an ORM tool, 
				 you might prefer to write a custom UserDetailsService to reuse the mapping files you’ve probably 
				 already created. Returning to JdbcDaoImpl, an example configuration is shown below:

					<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
							<property name="driverClassName" value="org.hsqldb.jdbcDriver"/>
							<property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/>
							<property name="username" value="sa"/>
							<property name="password" value=""/>
					</bean>

					<bean id="userDetailsService" class="org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl">
					      <property name="dataSource" ref="dataSource"/>
					</bean>
					
		 
		 </JdbcDaoImpl>
		 
		 <Common_BuiltI_In_Expressions>
		 
					The base class for expression root objects is SecurityExpressionRoot. This provides some common expressions which are available in both web and method security.

					Table 27.1. Common built-in expressions

					Expression	            Description
					hasRole([role])--springsec-4

					                         Returns true if the current principal has the specified role. By default if the supplied role does not start
											 with 'ROLE_' it will be added. This can be customized by modifying the defaultRolePrefix on DefaultWebSecurityExpressionHandler.

					hasAnyRole([role1,role2])--springsec-4

					                         Returns true if the current principal has any of the supplied roles (given as a comma-separated list of strings). 
											 By default if the supplied role does not start with 'ROLE_' it will be added. This can be customized by modifying the 
											 defaultRolePrefix on DefaultWebSecurityExpressionHandler.

					hasAuthority([authority])--springsec-3

				                         	Returns true if the current principal has the specified authority.

					hasAnyAuthority([authority1,authority2])--springsec-3

					                       Returns true if the current principal has any of the supplied roles (given as a comma-separated list of strings)

					principal ---springsec-4

					                       Allows direct access to the principal object representing the current user

					authentication --springsec-4

					                       Allows direct access to the current Authentication object obtained from the SecurityContext

					permitAll --springsec-4

					                       Always evaluates to true

					denyAll

					                       Always evaluates to false

					isAnonymous() --springsec-4

					                       Returns true if the current principal is an anonymous user

					isRememberMe()

					                       Returns true if the current principal is a remember-me user

					isAuthenticated()   --springsec-4

					                       Returns true if the user is not anonymous

					isFullyAuthenticated() ---springsec-4

					                       Returns true if the user is not an anonymous or a remember-me user

					hasPermission(Object target, Object permission)

					                       Returns true if the user has access to the provided target for the given permission. For example, hasPermission(domainObject, 'read')

					hasPermission(Object targetId, String targetType, Object permission)

					                       Returns true if the user has access to the provided target for the given permission. For example, hasPermission(1, 'com.example.domain.Message', 'read')


					27.2 Web Security Expressions
					                    To use expressions to secure individual URLs, you would first need to set the use-expressions attribute in the >>/http> element to true. 
										Spring Security will then expect the access attributes of the >>intercept-url> elements to contain Spring EL expressions. 
										The expressions should evaluate to a Boolean, defining whether access should be allowed or not. For example:
										hasIpAddress('192.168.1.0/24')  --- is an additional built-in expression which is specific to web security. 

					<http use-expressions="true">
						<intercept-url pattern="/admin*"
							access="hasRole('admin') and hasIpAddress('192.168.1.0/24')"/>
						...
					</http>
					
					 Referring to Beans in Web Security Expressions
								If you wish to extend the expressions that are available, you can easily refer to any Spring Bean you expose.
								For example, assuming you have a Bean with the name of webSecurity that contains the following method signature:

								public class WebSecurity {
										public boolean check(Authentication authentication, HttpServletRequest request) {
												...
										}
								}
								You could refer to the method using:

								<http>
									<intercept-url pattern="/user/**"
										access="@webSecurity.check(authentication,request)"/>
									...
								</http>
								
				     Path Variables in Web Security Expressions		
								<http>
										<intercept-url pattern="/user/{userId}/**"
											access="@webSecurity.checkUserId(authentication,#userId)"/>
										...
								 </http>
							 /user/123/resource, 

					 
							 
         </Common_BuiltI_In_Expressions>
		 
		 <spring_security_3_vs_4>
		       
			   Features                                                      ---- 3 ---------------------------------------------------------4
			   
			   1. hasrole                                                            y                                                        y
			   2. hasAnyRole                                                         y                                                        y
			   3. principal
			   4. authentication
			   5. permitAll
			   6. denyAll
			   7. isAnonymous()
			   8.isRememberMe()
			   9. isAuthenticated()
			   10 isFullyAuthenticated()
			   
			   
			   ---
			   11. direct role use access="ROLE_ADMIN_OVERALL_DASHBOARD"                  y                                                    n..access="hasRole('') or hasAnyRole('')"  
                                                                         .............................              
			   12. http@access-denied-page                                                y--                                                  n              
			                                                                                 http ... access-denied-page="/denied">              
																						     /http>			                                   http ...>
																																					access-denied-handler error-page="/denied"/>
																																				/http>
										                                 .................................................
  				13. http@path-type                                                       y	                                                    n        
                                                                                             http ... path-type="regex">
																								...
																							/http>				                                  http ... request-matcher="regex">
																																						...
																																				 /http>
																		....................................................
                14. filter-chain-map@path-type                                            y                                                      n
                                                                                              filter-chain-map ... path-type="regex">      
																									...
																								/filter-chain-map>				                  filter-chain-map ... request-matcher="regex">
																																						...
																																					/filter-chain-map>
				                                                         ..................................................................................
				15.  filter-security-metadata-source@path-type                  		 y                                                        n
																						 filter-security-metadata-source ... path-type="regex">
																							...
																						 /filter-security-metadata-source>				
		                                                                                                                                               filter-security-metadata-source ... request-matcher="regex">
																																							...
																																						/filter-security-metadata-source>
		                                                                 ........................................................
			    16. ifAllGranted                             y.. ifAllGranted="ROLE_ADMIN,ROLE_USER"  			          n..access="hasRole('ROLE_ADMIN') and hasRole('ROLE_USER')"
		 
		        17. ifAnyGranted                             y.. fAnyGranted="ROLE_ADMIN,ROLE_USER"                       n..access="hasAnyRole('ROLE_ADMIN','ROLE_USER')"
				
				18.ifNotGranted                              y.. ifNotGranted="ROLE_ADMIN,ROLE_USER"                      n..access="!hasAnyRole('ROLE_ADMIN','ROLE_USER')"
		 
		 
		 </spring_security_3_vs_4> 
		 		 
		 <annotation>
		 
		         --@Pre and @Post 
			  
			      There are four annotations which support expression attributes to allow pre and post-invocation authorization checks and also 
			      to support filtering of submitted collection arguments or return values. They are @PreAuthorize, @PreFilter, @PostAuthorize 
			      and @PostFilter. Their use is enabled through the global-method-security namespace element:

                 <global-method-security pre-post-annotations="enabled"></global-method-security>	
				 
				 @PreAuthorize("hasRole('USER')")
                    public void create(Contact contact);
					
				@PreAuthorize("hasPermission(#contact, 'admin')")
                    public void deletePermission(Contact contact, Sid recipient, Permission permission);
					n
				@PreAuthorize("hasRole('USER')")
                     @PostFilter("hasPermission(filterObject, 'read') or hasPermission(filterObject, 'admin')")
                     public List<Contact/> getAll();
					 
			    To use hasPermission() expressions, you have to explicitly configure a PermissionEvaluator in your application context. 
				This would look something like this:

					<security:global-method-security pre-post-annotations="enabled">
					<security:expression-handler ref="expressionHandler"/>
					</security:global-method-security>

					<bean id="expressionHandler" class="org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler">
						<property name="permissionEvaluator" ref="myPermissionEvaluator"/>
					</bean>
					
					Where myPermissionEvaluator is the bean which implements PermissionEvaluator. Usually this will be the implementation from 
					the ACL module which is called AclPermissionEvaluator. See the "Contacts" sample application configuration for more details.

					Method Security Meta Annotations
						You can make use of meta annotations for method security to make your code more readable. This is especially convenient if you find
						that you are repeating the same complex expression throughout your code base. For example, consider the following:

					@PreAuthorize("#contact.name == authentication.name")
					    Instead of repeating this everywhere, we can create a meta annotation that can be used instead.

					@Retention(RetentionPolicy.RUNTIME)
					@PreAuthorize("#contact.name == authentication.name")
					public @interface ContactPermission {}
						Meta annotations can be used for any of the Spring Security method security annotations. In order to remain compliant with 
						the specification JSR-250 annotations do not support meta annotations.
										 
				 
		 </annotation>
		 		 
		 <custom_authentication_provider>
		 
		      it is required to do custom credentials check/custom error message /custom login attempt/account is enabled/disabled
		 
		       steps
			   ---->
			        1. write user model calss with field ,username/password/role.
					2. write dao for model and write operation like getUserByuserName(String username)/etc.
					3. configure dao bean either through xml/or annotate with @component("beanname").
					4. write CustomAuthprovider class which implments "AuthenticationProvider"
					      a.  @Autowird for dao...
					      b.  write below method.
						                           @Override
													public Authentication authenticate(Authentication auth) throws AuthenticationException {
														// TODO Auto-generated method stub
														
														//first fetch user is available or not
														System.out.println("inside authenticate ");
														String username=auth.getName();
														String password =(String) auth.getCredentials();
														
														User userFromDb=userdao.getUserByName(username);
														
														
														try {
															
														
														if(userFromDb==null || !userFromDb.getUsername().equalsIgnoreCase(username))
														{
															System.out.println("username not found");
															throw new BadCredentialsException("Usrname not found");
														}
														System.out.println("2 ");
														
														if(userFromDb==null || !userFromDb.getPassword().equalsIgnoreCase(password))
														{
															   System.out.println("password not found");
															   throw new BadCredentialsException("wron password");
															
														}
														}
														catch(NullPointerException n)
														{
															System.out.println("username or pasword is null");
														
														}
														finally
														{
															System.out.println("username or password is null");
														}
														
														System.out.println("3 ");
														List GrantedAuthority> grantedAuthorities = new ArrayList GrantedAuthority>();
														
														grantedAuthorities.add( new SimpleGrantedAuthority(userFromDb.getRole()) );
														 
														System.out.println("4 authenticate ");	
														return new UsernamePasswordAuthenticationToken(userFromDb, password, grantedAuthorities);
													}

														@Override
														public boolean supports(Class ?> authentication) {
															// TODO Auto-generated method stub
															
															return authentication.equals(UsernamePasswordAuthenticationToken.class);
														}
														 
		             5. configre customAuthProvider bean either in xml or @Component("customAuthProvider")
					 6. now set customAuthProvider to  authentication-provider ref="customAuthProvider" >   
					 
					 
					 
			
		 </custom_authentication_provider>
		 		 				 
		  <spring_security_exception_error>
		  
		          >>   To show exception message in jsp after unsucessfull attempt / invalid username / password.
				       spring security provided expression  
               				  1.  >c:if test="${not empty error}">
		                      2.  c:if test="${not empty SPRING_SECURITY_LAST_EXCEPTION}">
							           ${SPRING_SECURITY_LAST_EXCEPTION.message}
		                      3. c:if test="${param.error ne null}">
		  
		          >> to handle success/failure/access denied-----we can write seperate handler to do custom check...    
		 </spring_security_exception_error>
		 		 		
		   <remember_me>
		   
		            >  Spring Security uses an implementation of 
					    "RememberMeServices" to provide the remember-me functionality.
                       There are two implementations of this interface: 
					    1. TokenBasedRememberMeServices
                						( uses Base-64 encoded cookie, simple to use but not very secure) and
										
							   >> can only work with USerdetailsService
                                        >> bydefault spring security creates "JSESSIONID" this expires till browser session	.
                                           Tokenbased remeber me service creates another session with new name withnew vaidity.										
										
										
						2. PersistentTokenBasedRememberMeServices 
						                ( persistent Token approach, uses a database table). 
										
										create table persistent_logins (
													username varchar(64) not null, 
													series varchar(64) primary key, 	
													token varchar(64) not null,
													last_used timestamp not null
												)
												
									  >>>			
									  >>>			
									  >>>			
		            
					> Remember-me will only work with UserDetailsService auth provider.
                    > if used custom auth provider then remember-me will not work. 					
		 
		   </remember_me>
		   
		   <login_failed>
		   
		        implement AuthenticationFailureHandler or write logic in Authentication Provider.
				
		   </login_failed>
		   		   
		   <csrf>
		          >> when we loged into wesite and then open new site that mey contain malicious code and that code can send request on behalf of your session.
				  >> only POST request will be handled in csrf
				  
				  >>> here all page will have csrf token given by spring security and while submitting action spring security will check csrf token 
				     if it is valid then only will allow action to be completed.
					 
					 	
                     input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}"/>
					 
				  
		   </csrf>
	
		 <password_encoder_decoder>
		 
		     >>   write one class for encodeing password and that class will be used while creating user
			 >>      password-encoder ref="" base64="true"  hash="bcrypt"> 
                       salt-source /> 
    
                     /password-encoder>
					 
					 @Bean
						public PasswordEncoder passwordEncoder() {
							return new BCryptPasswordEncoder();
						}
		    <salting_hashes>
			   
			   StandardPasswordEncoder
			
			
			
			
			</salting_hashes>
		 
		 </password_encoder_decoder>
		 		 
		  <ldap_security>
		  
		     
		  
		 
		  </ldap_security>
		 		 
		 <programming_level_security>
		 
		       >> we can place security annotation/ prevent from  perticular user
			      on method level.
			   >>  
		 
				  <method_level_security>
				  
				       >> TO enable method level annotation 
					      add to mvc.congig
						  
						   security:global-method-security  pre-post-annotations="enabled">  /security:global-method-security>
                        >> @PermitAll
				       >> then add  
					            @PreAuthorize("hasRole('USER')")        -- check before executing
							
					    >> @PreAuthorize("#username == authentication.principal.username")
								public String getMyRoles(String username) {
									//...
								}
                               Here, a user can invoke the getMyRoles method only if the value of the argument username is the same as 
							   current principal’s username.								
				        >> @PostAuthorize
								   ("returnObject.username == authentication.principal.nickName")
								  public CustomUser loadUserDetail(String username) 
								  {
									  return userRoleRepository.loadUserByUserName(username);
								  }
								In this example, the loadUserDetail method would only execute successfully if the username of the returned CustomUser is
								equal to the current authentication principal’s nickname.
					    
						>>The @RoleAllowed annotation is the JSR-250’s equivalent annotation of the @Secured annotation.

								Basically, we can use the @RoleAllowed annotation in a similar way as @Secured. Thus, we could re-define getUsername and isValidUsername methods:

								@RolesAllowed("ROLE_VIEWER")
								public String getUsername2() 
								{
									//...
								}
									 
								@RolesAllowed({ "ROLE_VIEWER", "ROLE_EDITOR" })
								public boolean isValidUsername2(String username) 
								{
									//...
								}	
					    
						>> @PreFilter and @PostFilter Annotations
								Spring Security provides the @PreFilter annotation to filter a collection argument before executing the method:

								@PreFilter("filterObject != authentication.principal.username")
								public String joinUsernames(List String> usernames) {
									return usernames.stream().collect(Collectors.joining(";"));
								}
								In this example, we’re joining all usernames except for the one who is authenticated.

								Here, our expression uses the name "filterObject" to represent the current object in the collection.

								However, if the method has more than one argument which is a collection type, we need to use the "filterTarget" property 
								to specify which argument we want to filter:


								@PreFilter
								  (value = "filterObject != authentication.principal.username",filterTarget = "usernames")
								public String joinUsernamesAndRoles(List String> usernames, List String> roles) 
								{
								  
									return usernames.stream().collect(Collectors.joining(";")) 
									  + ":" + roles.stream().collect(Collectors.joining(";"));
								}
								Additionally, we can also filter the returned collection of a method by using @PostFilter annotation:


								@PostFilter("filterObject != authentication.principal.username")
								public List String> getAllUsernamesExceptCurrent() {
									return userRoleRepository.getAllUsernames();
								}
								In this case, the name filterObject refers to the current object in the returned collection.

								With that configuration, Spring Security will iterate through the returned list and remove any value which matches with the principal’s username.
                             ------------------------------------
							 
			           >> add annotaion into group
					   
					            @Target(ElementType.METHOD)
								@Retention(RetentionPolicy.RUNTIME)
								@PreAuthorize("hasRole('VIEWER')")
								public @interface IsViewer 
								{
								}
								  ----Next, we can directly use the @IsViewer annotation to secure our method:
								  
								@IsViewer
									public String getUsername4() 
									{
										//...
									}
                               ------------									
					   
					   >> Multiple Security Annotations on a Method
									We can also use multiple security annotations on one method:

									@PreAuthorize("#username == authentication.principal.username")
									@PostAuthorize("returnObject.username == authentication.principal.nickName")
									public CustomUser securedLoadUserDetail(String username) 
									{
										  return userRoleRepository.loadUserByUserName(username);
									}
									
									Hence, Spring will verify authorization both before and after the execution of the securedLoadUserDetail method.
                                ---------
					 >>There are two points we’d like to remind regarding method security:

								By default, Spring AOP proxying is used to apply method security – if a secured method A is called by another method within 
								the same class, security in A is ignored altogether. This means method A will execute without any security checking. 
								The same applies to private methods
								
								Spring SecurityContext is thread-bound – by default, the security context isn’t propagated to child-threads.
							 
							----------
					>> protect pointcut
					
							   global-method-security >
								       protect-pointcut expression="execution(* com.concretepage.service.*Service.*(..))"
									 access="ROLE_USER"/>
							   /global-method-security>
							   
							   The configuration says that the classes whose name ended with Service and lying within 
							   the package com.concretepage.service can be access only with ROLE_USER. 
 
					
							
					 
				 </method_level_security>
		 
		 
		 </programming_level_security>
		 
		 <permission_based_security>
		    ACL
		 
		 
		 
		 </permission_based_security>
		 		 
		 <channel_level_security>
		 
		 </channel_level_security>
		 		 
		 <oauth>
		 
		 </oauth>
				  
		 DeleGettingFilterProxy   ---> FilterChainProxy-------ExceptionTranslationFilter-----SecurityFilterIntercepter
		 
		 
		 spring scurity uses Ant pattern for intercept url
		 
		 
		  DeleGettingFilterProxy   ---> FilterChainProxy-----UserNamePassword AuthenticationFilter-----Authentication Manager---
		  +
		  ---SecurityContextHolder
		 
		 
		<session>
		 
					  HttpSession ses=req.getSession();
					  SecurityContextHolder.clearContext();
					  ses.invalidate();
					  
					  <logout invalidate-session="true"  logout-url="logout" logout-success-url="/index.jsp" />
                    				 
					 <session-management invalid-session-url="/" >
						   <concurrency-control error-if-maximum-exceeded="true" max-sessions="1" expired-url="/" />
					 </session-management>
					 
					 for concurrent session control
					 <listener>
					       <listener-class>
	                                         org.springframework.security.web.session.HttpSessionEventPublisher
					       </listener-class>
					</listener>
							
		</session>
		 	
   </spring_security>
    
   <test>
     
				 <simpleSpringHibernateTemplate>
					  
					  >> find in spring workspace sts
					  
					  >>  1--DAO
							>>  Employee               .....      pojo class/model/Entity class to map table
															   desing with annotation Entity/Id/Column
											  
							>>  EmployeeDAO            .....    interface for all operation that we require to perform on Entity Employee	
															   like update/save/delete etc..
							>>  EmployeeDAOImpl		  .....    here use hibernate template and implement EmployeeDao and with hibernate template perform operaton in implemented class							
							  
							now create
							
					  >> 2 --Spring XMl
							   
							  >>    create bean of LocalSessionFacory and set configlocation to hibernate.cfg.xml
							  >>    create bean of HibernateTemplate and set sessionfactory.   
							  
							  >>    now set hibermnate template to EmployeeDAOImpl   as dependency injection 	 			  
							  
					
					 >>  -- Create Test class 
							  >> load Application Context IOC container with spring.xml
							  
							  >> now get EmployeeDAO reference from   EmployeeDAOImpl with contianer getbeans
							  >> now call appropriate method of EmployeeDAOImpl using EmployeeDAO reference.
					
					
				 </simpleSpringHibernateTemplate>
				 
				 <spring_mongo>
					
					Steps
					----
					 1. add spring-data-mongo lib(1.10.10.RELEASE) in pom.xml and mongo jar files
					 2. add mongo client-dbfactory-template in spring .xml 
					 3. set mongoTemplate to class where mongoTemplate used for opeation
					 PLEASE REFER 4_MONGO PROJECT 
					 
				 </spring_mongo>
				 
	</test>   
			   
   
</SPRING>

<database>
  
  <oracle>
  
            <SQL_PLSQL>

				 please visit internet site and learn sql queries on daily basis

			</SQL_PLSQL>

			<FUNCTION>
				
				create or replace function findConsmmer(consumer_id number, conusumer_name varchar2) RETURN VARCHAR AS
				
				  PL_consumerid number;
				  pl_consumer_profile varchar2(10);

				 begin
				 
				 
				 
				 WHEN NO_DATA_FOUND THEN
					DBMS_OUTPUT.PUT_LINE('NO DATA FOUND');
				 WHEN OTHERS THEN
					DBMS_OUTPUT.PUT_LINE('OTHERS ERROR');	 
				 

				 end findConsmmer;
				 
				 
				 <function_return_xml>
				 
				 
				 
				 </function_return_xml>
				 
				 
				 <function_return_clob>
				 
					 declare 

								out clob;


								begin

								dbms_output.put_line('1');
								GENERATE_service_programs.GET_SERVICE_PROGRAM_HTML('BPC0010000WAAAAC','BTOB','DISTRIBUTION-CAD','FCI','CAD',out);


								dbms_output.put_line('2');
								dbms_output.put_line('CLOB DATA...>'||dbms_lob.substr(out,32000,1)); 

					end;
				 
				 
				 
				 </function_return_clob>
				 
				 <function_read_xml_return_xml>
				 
				 
						function GET_UPDATED_SP_XML(in_model IN varchar2) RETURN XMLTYPE AS

						  xmldoc                CLOB;
						  l_ret_xml             XMLTYPE;
						  l_xml_data            CLOB;
						  n_node_list           XMLDOM.DOMNODELIST;
						  i                     NUMBER;
						  n_node                XMLDOM.DOMNODE;
						  n_elem                XMLDOM.DOMELEMENT;
						  nn_node_list          XMLDOM.DOMNODELIST;
						  nn_node               XMLDOM.DOMNODE;
						  nnn_node_list         XMLDOM.DOMNODELIST;
						  nnn_node              XMLDOM.DOMNODE;
						  myParser              XMLPARSER.PARSER;
						  indomdoc              XMLDOM.DOMDOCUMENT;
			  
			  
						  select CONTROL_VALUE into XMLDOC from REF_XML_WEB_CONTENT where CONTROL_KEY ='SERVICE_PROGRAM_XML1';
						  
						  
						  myParser := XMLPARSER.newParser;
						  XMLPARSER.parseClob(myParser, xmldoc);
						  indomdoc := xmlparser.getDocument(myParser);
						  XMLPARSER.freeParser(myParser);
						  
						  
						   n_node_list := XMLDOM.getElementsByTagName(indomdoc, 'BATTERY_WAR');
						  FOR i IN 0..xmldom.getlength(n_node_list)-1
						  LOOP
									 n_node := XMLDOM.item(n_node_list, i);
									 n_elem := XMLDOM.makeElement(n_node);
							 
									 nn_node_list := XMLDOM.getElementsByTagName(n_elem, 'PART_NUM');
									 nn_node := XMLDOM.item(nn_node_list,0);
									 nnn_node_list := XMLDOM.getChildNodes(nn_node);
									 nnn_node := XMLDOM.item(nnn_node_list,0);
									 l_part_number := XMLDOM.getNodeValue(nnn_node);
									 
									 
									 nn_node_list := XMLDOM.getElementsByTagName(n_elem, 'PRICE');
									 nn_node := XMLDOM.item(nn_node_list,0);
									 nnn_node_list := XMLDOM.getChildNodes(nn_node);
									 nnn_node := XMLDOM.item(nnn_node_list,0);
									 j_price := XMLDOM.getNodeValue(nnn_node);
							
									 LS_PRICE := GET_NEW_PRICE(L_PART_NUMBER, L_CUSTOMER_PROFILE, l_temp_calling_module, L_ORG_CODE, L_CURRENCY, j_price , l_high_level_part);
									 XMLDOM.setNodeValue(nnn_node,LS_PRICE);
							 
						  
						  
						  END LOOP;
					  
					  DBMS_LOB.createTemporary(l_xml_data, TRUE);
					  XMLDOM.writeToClob(indomdoc, l_xml_data);
					  XMLDOM.freeDocument(indomdoc);
					  l_ret_xml := XMLTYPE.createXML(l_xml_data);
				 
				  RETURN l_ret_xml;
				 
				 
				 </function_read_xml_return_xml>
				 
			</FUNCTION>

			<PROCEDURE>

			</PROCEDURE>

			<TRIGGER>

			</TRIGGER>

			<CURSOR>

					<one>
										   1. declare cursor
										   
												CURSOR c_toplist_part_detail IS
													 SELECT component_item_number,
															component_item_type,
															component_item_num,
															btb_item_type
													   FROM (SELECT component_item_number,
															 component_item_type,
															 component_item_num,
															 btb_item_type
														FROM FPC_BTB_ITEM_DETAILS_V
													   WHERE btb_item_number = pl_part_num
													   )
												  
											2. open cursor
												OPEN c_toplist_part_detail;
													LOOP
															 FETCH c_toplist_part_detail INTO pl_comp_part_num, pl_comp_part_type, pl_comp_item_num, pl_btb_item_type;
															 EXIT WHEN c_toplist_part_detail%NOTFOUND;
															 ----some logic
												END LOOP;
												CLOSE c_toplist_part_detail;					 
												  

					</one>
			  
					<two>
					
					   <function_return_refCURSOR>
					   
					   FUNCTION Get_Maintenance_Parts_Info(p_model IN VARCHAR2, p_siteid IN VARCHAR2, p_serialNo IN VARCHAR2)
					   RETURN sys_refcursor IS
					   
					   
						pl_sql_idstmt :='SELECT '''||pl_pdt||''' PR,'
														||' LPAD(UPPER('''||p_model||'''), 4,''0'')MODEL,'
														||' COALESCE(P.CLFY_PRODUCT_NUMBER, U.CLFY_PRODUCT_NUMBER, E.CLFY_PRODUCT_NUMBER,W.CLFY_PRODUCT_NUMBER)PART_NUMBER,'
														||' COALESCE(P.CLFY_SERIAL_NUMBER,U.CLFY_SERIAL_NUMBER,E.CLFY_SERIAL_NUMBER,W.CLFY_SERIAL_NUMBER)SERIAL_NUMBER,'
														||' COALESCE(P.CLFY_INSTALL_SITE_ID,U.CLFY_INSTALL_SITE_ID,E.CLFY_INSTALL_SITE_ID,W.CLFY_INSTALL_SITE_ID)SITE_ID,'
														||' COALESCE(P.DES,U.DES,E.DES,W.DES)DESCRIPTION,'
														||' FROM ('
														||' SELECT A.CLFY_SERIAL_NUMBER , A.CLFY_SERVICE_PART_TYPE TYPE, A.SERVICE_START_DATE, A.SERVICE_END_DATE,'
														||' A.CLFY_INSTALL_SITE_ID, A.CLFY_PART_MODEL, A.CLFY_SERVICE_PART_NUMBER, A.CLFY_PRODUCT_NUMBER,A.CLFY_PART_DESC DES'
														||' FROM FCS_CLARIFY_INSTALL_PRODUCT A ,('
																||' SELECT CLFY_SERIAL_NUMBER SERIAL, MAX( SERVICE_END_DATE) PWMAX'
																||' FROM FCS_CLARIFY_INSTALL_PRODUCT'
																||' WHERE CLFY_INSTALL_SITE_ID='''||pl_siteid||''''
																||' AND CLFY_PART_MODEL in ('||pl_model||')'
																||pl_where
																||' AND (TRIM(SUBSTR(CLFY_SERVICE_PART_NUMBER, INSTR(CLFY_SERVICE_PART_NUMBER,''-'') +1, 1))) IN (''P'')'
																||' GROUP BY CLFY_SERIAL_NUMBER'
																||' ) PMAX WHERE'
														||' A.CLFY_INSTALL_SITE_ID='''||pl_siteid||''''
														||' AND A.CLFY_PART_MODEL in ('||pl_model||')'
														||pl_where
														||' AND (TRIM(SUBSTR(A.CLFY_SERVICE_PART_NUMBER, INSTR(A.CLFY_SERVICE_PART_NUMBER,''-'') +1, 1))) IN (''P'')'
														||' AND TRUNC(A.service_end_date) >= TRUNC(A.service_start_date)'
														||' AND TRUNC(A.service_end_date) >= TRUNC(SYSDATE)'
														||' AND A.CLFY_SERIAL_NUMBER = PMAX.SERIAL'
														||' AND A.SERVICE_END_DATE = PMAX.PWMAX'
														
														||' ) P FULL OUTER JOIN ('
														||' SELECT A.CLFY_SERIAL_NUMBER , A.CLFY_SERVICE_PART_TYPE TYPE, A.SERVICE_START_DATE, A.SERVICE_END_DATE,'
														||' A.CLFY_INSTALL_SITE_ID, A.CLFY_PART_MODEL, A.CLFY_SERVICE_PART_NUMBER, A.CLFY_PRODUCT_NUMBER,A.CLFY_PART_DESC DES'
														||' FROM FCS_CLARIFY_INSTALL_PRODUCT A ,('
																 ||' SELECT CLFY_SERIAL_NUMBER SERIAL, MAX( SERVICE_END_DATE) UPMAX'
																 ||' FROM FCS_CLARIFY_INSTALL_PRODUCT'
																 ||' WHERE'
																 ||' CLFY_INSTALL_SITE_ID='''||pl_siteid||''''
																 ||' AND CLFY_PART_MODEL in ('||pl_model||')'
																 ||pl_where
																 ||' AND (TRIM(SUBSTR(CLFY_SERVICE_PART_NUMBER, INSTR(CLFY_SERVICE_PART_NUMBER,''-'') +1, 1))) IN (''U'')'
																 ||' GROUP BY CLFY_SERIAL_NUMBER'
																 ||' ) UMAX'
														||' WHERE'
														||' A.CLFY_INSTALL_SITE_ID='''||pl_siteid||''''
														||' AND A.CLFY_PART_MODEL in ('||pl_model||')'
														||pl_where
														||' AND (TRIM(SUBSTR(A.CLFY_SERVICE_PART_NUMBER, INSTR(A.CLFY_SERVICE_PART_NUMBER,''-'') +1, 1))) IN (''U'')'
														||' AND TRUNC(A.service_end_date) >= TRUNC(A.service_start_date)'
														||' AND TRUNC(A.service_end_date) >= TRUNC(SYSDATE)'
														||' AND A.CLFY_SERIAL_NUMBER = UMAX.SERIAL'
														||' AND A.SERVICE_END_DATE = UMAX.UPMAX'
														||' ) U ON P.CLFY_SERIAL_NUMBER =U.CLFY_SERIAL_NUMBER'
					   
					   
							 OPEN pl_reti FOR pl_sql_idstmt;
							 RETURN pl_reti;
							 
							 result will be like ----: name=maqoosd,surname=Ansari
				 
					   </function_return_refCURSOR>
					   
					   <cursor_in_forloop>
					   
								   FOR i IN c_mod
										   LOOP
											  IF c_mod%FOUND THEN
												 IF c_mod%ROWCOUNT = 1 THEN
													pl_model := '''' || i.clfy_part ;
													pl_product := i.product;
												 ELSE
													pl_model :=  pl_model || ''',''' || i.clfy_part ;
												 END IF;
											  END IF;
								 end loop;				  
						</cursor_in_forloop>
				
					</two>

			</CURSOR>
				   
			<LOOP>

			</LOOP>	   
			  
			<XML_XSL>
				 
				 <function_generate_xml_and_return_xml_as_clob>
				 
					function get_ent_new_po_xml(poNum in varchar2) RETURN CLOB AS
			   
			   
							ret CLOB:=' ';
				--xml node 
					doc xmldom.DOMDocument;
					main_node xmldom.DOMNode;
					root_elmt xmldom.DOMElement;
					root_node xmldom.DOMNode;
					item_text xmldom.DOMText;
					
					level_1_elmt xmldom.DOMElement;
					level_1_node xmldom.DOMNode;
					
					level_2_elmt xmldom.DOMElement;
					level_2_node xmldom.DOMNode;
					
					level_3_elmt xmldom.DOMElement;
					level_3_node xmldom.DOMNode;
					
					
					
					 --now create node one by one from root   
					doc := xmldom.newDOMDocument;
					main_node := xmldom.makeNode(doc);
					root_elmt := xmldom.createElement(doc, 'Pip3A4PurchaseOrderRequest');
					root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));
					
					
					
					--1-fromRole     
					  level_1_elmt:=xmldom.createElement(doc,'fromRole');
					  level_1_node:=xmldom.appendchild(root_node,xmldom.makeNode(level_1_elmt));
					
							level_2_elmt:=xmldom.createElement(doc,'PartnerRoleDescription');
							level_2_node:=xmldom.appendchild(level_1_node,xmldom.makenode(level_2_elmt));
					  
								  level_3_elmt:=xmldom.createElement(doc,'ContactInformation');
								  level_3_node:=xmldom.appendchild(level_2_node,xmldom.makenode(level_3_elmt));
						   
										level_4_elmt:=xmldom.createElement(doc,'contactName');
										level_4_node:=xmldom.appendchild(level_3_node,xmldom.makenode(level_4_elmt));
												
												  level_elmt:=xmldom.createElement(doc,'FreeFormText');
												  level_node:=xmldom.appendchild(level_4_node,xmldom.makenode(level_elmt));
												  item_text :=xmldom.createTextNode(doc,'No Sales Representative');
												  level_node:=xmldom.appendchild(level_node,xmldom.makenode(item_text));
												  
											
										level_4_elmt:=xmldom.createElement(doc,'EmailAddress');
										level_4_node:=xmldom.appendchild(level_3_node,xmldom.makenode(level_4_elmt));
										
										  
											  
											
										level_4_elmt:=xmldom.createElement(doc,'telephoneNumber');
									   level_4_node:=xmldom.appendchild(level_3_node,xmldom.makenode(level_4_elmt));
												
												  
												  level_elmt:=xmldom.createElement(doc,'CommunicationsNumber');
												  level_node:=xmldom.appendchild(level_4_node,xmldom.makenode(level_elmt));
												  
							xmldom.writeToClob(doc, ret);
							xmldom.freeDocument(doc);
							ret := 'xml verision line'||CHR(13)||'<!DOCTYPE Pip3A4PurchaseOrderRequest SYSTEM "Pip3A4PurchaseOrderRequest.dtd">'||CHR(13)||ret;  
							EXCEPTION WHEN NO_DATA_FOUND THEN
							 ret := 'EXCEPTION>/EXCEPTION>';
							WHEN OTHERS THEN
							 ret := 'EXCEPTION>/EXCEPTION>';					  
									 
										  
				 
				 </function_generate_xml_and_return_xml_as_clob>

			</XML_XSL>

  </oracle>
  
  <mongo>
  
							<note>
								   watch Levan j youtube channel
								    
								<MONGO_JAVA_CONNECT>

								</MONGO_JAVA_CONNECT>	
								
								<MONGO_SPRING_CONNECT>
								
								</MONGO_SPRING_CONNECT>
								  
								  
							</note>

							<install_mongo>

											Recommended Platforms
											While MongoDB supports a variety of platforms, the following operating systems are recommended for production use:

											Amazon Linux
											Debian 7.1
											RHEL / CentOS 6.2+
											SLES 11+
											Ubuntu LTS 14.04
											Ubuntu LTS 16.04
											Windows Server 2012 & 2012 R2
											Windows Server 2012 & 2012 R2



							</install_mongo>

							<security_mongo>

							   MongoDB provides various features, such as authentication, access control, encryption, to secure your MongoDB deployments. 
							   Some key security features include:
							   
							   
										1.Authentication
										------
													
												Authentication

												SCRAM-SHA-1

												x.509


										2.Authorization	                   
										---------
										
												Role-Based Access Control

												Enable Auth

												Manage Users and Roles


										3.TLS/SSL	
										--------
										
												Transport Encryption

												Configure mongod and mongos for TLS/SSL

												TLS/SSL Configuration for Clients


										4.Enterprise Only
										-----------
										
												Kerberos Authentication

												LDAP Proxy Authentication

												Encryption at Rest

												Auditing



							 <Authentication>
							 
											<Authentication_Methods>
							   
												  >> To authenticate a user, MongoDB provides the db.auth() method.
								   
											</Authentication_Methods>
							   
							   
											<USERS>
												
												>> To add a user, MongoDB provides the db.createUser() method. 
												   When adding a user, you can assign roles to the user in order to grant privileges.
												   
												>>  To authenticate a user, either Use the command line authentication 
													options (e.g. -u, -p, --authenticationDatabase) when connecting to the
													mongod or mongos instance, or.
										  
												>>  Connect first to the mongod or mongos instance, and then run the authenticate 
													command or the db.auth() method against the authentication database.	
							 
												>>  MongoDB stores all user information, including name, password, 
													and the user's authentication database, in the system.users collection in the admin database. 
													
												>>** For routine user creation, you must possess the following permissions:
													 To create a new user in a database, you must have the createUser action on that database resource.
													 To grant roles to a user, you must have the grantRole action on the role’s database.		
													 
												>>   The userAdmin and userAdminAnyDatabase built-in roles provide createUser and grantRole actions on their respective resources.

												>>   To create a user in a MongoDB deployment, you connect to the deployment, 
												   and then use the db.createUser() method or createUser command to add the user.	
												   
												>>  The following operation creates a user in the reporting database with the specified name, password, and roles.

														use reporting
														db.createUser(
														  {
															user: "reportsUser",
															pwd: "12345678",
															roles: [
															   { role: "read", db: "reporting" },
															   { role: "read", db: "products" },
															   { role: "read", db: "sales" },
															   { role: "readWrite", db: "accounts" }
															]
														  }
														)					   
														

													  Kerberos Authentication:
													  --------------------
													  
													  LDAP Authentication:
													  -------------------
															
															>> Users that will authenticate to MongoDB using an external authentication mechanism, such as LDAP, must be created in the $external database, which allows mongos or mongod to consult an external source for authentication.

																		For LDAP authentication, you must specify a username. You do not need to specify the password, as that is handled by the LDAP service.

																		The following operation adds the reporting user with read-only access to the records database.

																		use $external
																		db.createUser(
																			{
																			  user: "reporting",
																			  roles: [
																				 { role: "read", db: "records" }
																			  ]
																			}
																		)
																									

											</USERS>				
											   
							   
							   
							   
							   <Authentication_Mechanisms>
								   
											>>1.  SCRAM-SHA-1(default)
												   
												   >>  SCRAM-SHA-1 verifies the supplied user credentials against the user’s name, password and authentication database. 
													   The authentication database is the database where the user was created, and together with the user’s name, serves to identify the user.
												   >> driver support Java	2.13
											

											>>2.  MongoDB Challenge and Response (MONGODB-CR)

														Changed in version 3.0: New challenge-response users created in 3.0 will use SCRAM-SHA-1. 
													   If using 2.6 user data, MongoDB 3.0 will continue to use MONGODB-CR.

											>>3.  X.509 Certificate Authentication.

											>> In addition to supporting the aforementioned mechanisms, MongoDB Enterprise also supports the following mechanisms:

												LDAP proxy authentication, and
												Kerberos authentication.
											
											>>  Internal Authentication
												   In addition to verifying the identity of a client, MongoDB can require members of replica sets and sharded clusters
												   to authenticate their membership to their respective replica set or sharded cluster.
											
											>>   Authentication on Sharded Clusters
												  In sharded clusters, clients generally authenticate directly to the mongos instances. 
												  However, some maintenance operations may require authenticating directly to a specific shard. 

											>>   To specify the authentication mechanism to use, set the authenticationMechanisms parameter for mongod and mongos.

											>>   Clients specify the authentication mechanism in the db.auth() method. For the mongo shell and the MongoDB tools, 
											   you can also specify the authentication mechanism from the command line.				


							   
							   </Authentication_Mechanisms>
							   
							   <Enable_AUTH>
							   
							   </Enable_AUTH>
							 

							  </Authentication> 
							 
							 
							 

							</security_mongo>

							<Note>

								>> mongochef is a visual tool for mongo db.
								
								
							</Note>

							<DATA_MODELING>

							   Some considerations while designing Schema in MongoDB
										1. Design your schema according to user requirements.

										2. Combine objects into one document if you will use them together. Otherwise separate them (but make sure there should not be need of joins).

										3. Duplicate the data (but limited) because disk space is cheap as compare to compute time.

										4. Do joins while write, not on read.

										5. Optimize your schema for most frequent use cases.

										6. Do complex aggregation in the schema.
										
								Example

								   Suppose a client needs a database design for his blog/website and see the differences between RDBMS and MongoDB schema design. Website has the following requirements.

											Every post has the unique title, description and url.
											Every post can have one or more tags.
											Every post has the name of its publisher and total number of likes.
											Every post has comments given by users along with their name, message, data-time and likes.
											On each post, there can be zero or more comments.
											
									In RDBMS schema, design for above requirements will have minimum three tables.		
									 Comments/Post/Tag_List
									 
									>> While in MongoDB schema, design will have one collection post and the following structure -

												{
												   _id: POST_ID
												   title: TITLE_OF_POST, 
												   description: POST_DESCRIPTION,
												   by: POST_BY,
												   url: URL_OF_POST,
												   tags: [TAG1, TAG2, TAG3],
												   likes: TOTAL_LIKES, 
												   comments: [	
													  {
														 user:'COMMENT_BY',
														 message: TEXT,
														 dateCreated: DATE_TIME,
														 like: LIKES 
													  },
													  {
														 user:'COMMENT_BY',
														 message: TEXT,
														 dateCreated: DATE_TIME,
														 like: LIKES
													  }
												   ]
												}
												
									>> So while showing the data, in RDBMS you need to join three tables and in MongoDB, data will be shown from one collection only.

										



							</DATA_MODELING>

							<CREATE_DATABASE>

							1. USE
							----
								MongoDB use DATABASE_NAME is used to create database. 
								The command will create a new database if it doesn't exist, otherwise it will return the existing database.

							2. db
							----
							   To check your currently selected database, use the command db.

							3. show dbs
							----
							   If you want to check your databases list, use the command show dbs.

							<NOTE>
								
								Your created database (mydb) is not present in list. To display database, you need 
								to insert at least one document into it.
								
								>db.movie.insert({"name":"tutorials point"})
								>show dbs
								  local      0.78125GB
								  mydb       0.23012GB
								  test       0.23012GB

							</NOTE>   




							</CREATE_DATABASE>

							<DROP_DATABASE>

							1. dropDatabase()
							----
							   MongoDB db.dropDatabase() command is used to drop a existing database.
							   
							   db.dropDatabase()
								This will delete the selected database. If you have not selected any database, then it will delete default 'test' database.


							</DROP_DATABASE>

							<COLLECTION>

									<CREATE>

									1. createCollection()
									-----
										MongoDB db.createCollection(name, options) is used to create collection.
										
										db.createCollection(name, options)
										   name    >>> name of collection
										   options >>> configuration memory size indexing
										   
										   capped	       Boolean	    (Optional) If true, enables a capped collection. Capped collection is a fixed size collection that automatically overwrites its oldest entries when it reaches its maximum size. If you specify true, you need to specify size parameter also.
										   autoIndexId	   Boolean	    (Optional) If true, automatically create index on _id field.s Default value is false.
										   size	number	  (Optional)    Specifies a maximum size in bytes for a capped collection. If capped is true, then you need to specify this field also.
										   max	number	  (Optional)    Specifies the maximum number of documents allowed in the capped collection.

										   db.createCollection("mycol", { capped : true, autoIndexId : true, size : 6142800, max : 10000 } )
										   
										<note>
										   
											  In MongoDB, you don't need to create collection. MongoDB creates collection automatically, when you insert some document.

											  >db.tutorialspoint.insert({"name" : "tutorialspoint"})
										
										
										</note>
										
									</CREATE>	
								
									<DROP>
									   
										 drop()
										 -----
											>> USED TO DROP COLECTION FROM DATABASE
										   
											db.COLLECTION_NAME.drop()
									

									</DROP>	
								
							</COLLECTION>

							<DATA_TYPES>

									String - This is the most commonly used datatype to store the data. String in MongoDB must be UTF-8 valid.

									Integer - This type is used to store a numerical value. Integer can be 32 bit or 64 bit depending upon your server.

									Boolean - This type is used to store a boolean (true/ false) value.

									Double - This type is used to store floating point values.

									Min/ Max keys - This type is used to compare a value against the lowest and highest BSON elements.

									Arrays - This type is used to store arrays or list or multiple values into one key.

									Timestamp - ctimestamp. This can be handy for recording when a document has been modified or added.

									Object - This datatype is used for embedded documents.

									Null - This type is used to store a Null value.

									Symbol - This datatype is used identically to a string; however, it's generally reserved for languages that use a specific symbol type.

									Date - This datatype is used to store the current date or time in UNIX time format. You can specify your own date 
										   time by creating object of Date and passing day, month, year into it.

									Object ID - This datatype is used to store the document’s ID.

									Binary data - This datatype is used to store binary data.

									Code - This datatype is used to store JavaScript code into the document.

									Regular expression - This datatype is used to store regular expression.





							</DATA_TYPES>

							<INSERT_DOCUMENT>

								insert() / save()
								----
								 >>   To insert data into MongoDB collection, you need to use MongoDB's insert() or save() method.
									  db.COLLECTION_NAME.insert(document)
								 
								 db.mycol.insert
								 ({
									   _id: ObjectId(7df78ad8902c),
									   title: 'MongoDB Overview', 
									   description: 'MongoDB is no sql database',
									   by: 'tutorials point',
									   url: 'http://www.tutorialspoint.com',
									   tags: ['mongodb', 'database', 'NoSQL'],
									   likes: 100
								   })

								   
							<NOTE>

									_id is 12 bytes hexadecimal number unique for every document in a collection. 12 bytes are divided as follows -

									   _id: ObjectId(4 bytes timestamp, 3 bytes machine id, 2 bytes process id, 3 bytes incrementer)
									   
									   To insert multiple documents in a single query, you can pass an array of documents in insert() command.
									   
									   db.post.insert([
										   {
											  title: 'MongoDB Overview', 
											  description: 'MongoDB is no sql database',
											  by: 'tutorials point',
											  url: 'http://www.tutorialspoint.com',
											  tags: ['mongodb', 'database', 'NoSQL'],
											  likes: 100
										   },
											
										   {
											  title: 'NoSQL Database', 
											  description: "NoSQL database doesn't have tables",
											  by: 'tutorials point',
											  url: 'http://www.tutorialspoint.com',
											  tags: ['mongodb', 'database', 'NoSQL'],
											  likes: 20, 
											  comments: [	
												 {
													user:'user1',
													message: 'My first comment',
													dateCreated: new Date(2013,11,10,2,35),
													like: 0 
												 }
											  ]
										   }
										])
										
										
										To insert the document you can use db.post.save(document) also. If you don't specify _id in the document then save() method 
										will work same as insert() method. If you specify _id then it will replace whole data of document containing _id as specified in save() method.


							</NOTE>	   



							</INSERT_DOCUMENT>

							<QUERY_DOCUMENT>

								  db.collection.find(query, projection)
								  ------
										Expression using a Projection Operators.

										find() operations on views do not support the following projection operators:

												$
												$elemMatch
												$slice
												$meta
										
								find()
								-----
									 db.COLLECTION_NAME.find()
									 find() method will display all the documents in a non-structured way.

								pretty()
								-----  
								   To display the results in a formatted way, you can use pretty() method. 
								
									 db.mycol.find().pretty()
									{
										 "_id"   : ObjectId(7df78ad8902c),
										 "title" : "MongoDB Overview", 
										 "description": "MongoDB is no sql database",
										 "by": "tutorials point",
										 "url": "http://www.tutorialspoint.com",
										 "tags": ["mongodb", "database", "NoSQL"],
										 "likes": "100"
									}

													 MONGO                                 RDBMS
									WHERE
									----
									
									db.mycol.find({"by":"tutorials point"}).pretty()	where by = 'tutorials point'
									db.mycol.find({"likes":{$lt:50}}).pretty()	        where likes  50
									 
									AND 
									---
											db.mycol.find(
												   {
														 $and: 
														[
														 {key1: value1}, {key2:value2}
														]
													 }
												  ).pretty()
									
									OR 
									----
											db.mycol.find
											(
											   {
												  $or: 
												  [
													 {key1: value1}, {key2:value2}
												  ]
											   }
											).pretty()
											
									 AND OR
									 ---
											db.mycol.find({"likes": {$gt:10}, $or: [{"by": "tutorials point"},
														 {"title": "MongoDB Overview"}]}).pretty()	


								 <select_column_in_custom_sequence>
												> db.employee.aggregate([{$project:{url:"$url",title:"$title"}}]).pretty();
															{
																	"_id" : ObjectId("5b32150820a10f93e8f098ee"),
																	"url" : "http://www.tutorialspoint.com",
																	"title" : "MongoDB Overview"
															}
												>
								 </select_column_in_custom_sequence>	 

							</QUERY_DOCUMENT>

							<UPDATE_DOCUMENT>

									MongoDB's update() and save() methods are used to update document into a collection. 
									The update() method updates the values in the existing document while the save() method replaces the existing document with 
									the document passed in save() method.
									
									>> db.COLLECTION_NAME.update(SELECTION_CRITERIA, UPDATED_DATA)
									
									db.mycol.update({'title':'MongoDB Overview'},{$set:{'title':'New MongoDB Tutorial'}})
									
									By default, MongoDB will update only a single document. To update multiple documents, you need to set a parameter 'multi' to true.

									  db.mycol.update({'title':'MongoDB Overview'},
											  {$set:{'title':'New MongoDB Tutorial'}},{multi:true})
											  
											  
								   >> 
									  db.COLLECTION_NAME.save({_id:ObjectId(),NEW_DATA})
									  
									  db.mycol.save(
													   {
														  "_id" : ObjectId(5983548781331adf45ec7), "title":"Tutorials Point New Topic",
															 "by":"Tutorials Point"
													   }
													)


							</UPDATE_DOCUMENT>

							<DELETE_DOCUMENT>

								  remove()
								  ------
									MongoDB's remove() method is used to remove a document from the collection. remove() method accepts two parameters. 
									One is deletion criteria and second is justOne flag.
									
									deletion criteria - (Optional) deletion criteria according to documents will be removed.

									justOne - (Optional) if set to true or 1, then remove only one document.
									
									db.mycol.remove({'title':'MongoDB Overview'})
									db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)



							</DELETE_DOCUMENT>

							<PROJECTION_SELECTION>

								>> select only necessary data
								  db.COLLECTION_NAME.find({},{KEY:1})
								  
									 >> to limit this, you need to set a list of fields with value 1 or 0. 
										1 is used to show the field while 0 is used to hide the fields.
								  db.mycol.find({},{"title":1,_id:0})


							</PROJECTION_SELECTION>

							<LIMIT_RECORD>

								>> number of documents that you want to be displayed.
								>>db.COLLECTION_NAME.find().limit(NUMBER)
								>db.mycol.find({},{"title":1,_id:0}).limit(2)

								
								Skip() 
								------
								  >>  accepts number type argument and is used to skip the number of documents.
								  >>  db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)
									  
									  db.mycol.find({},{"title":1,_id:0}).limit(1).skip(1)



							</LIMIT_RECORD>

							<SORT_RECORD>

							   SORT()
							   ----
								   >>  The method accepts a document containing a list of fields along with their sorting order. 
									   To specify sorting order 1 and -1 are used. 1 is used for ascending order while -1 is used for descending order.
								   
								   >>  db.COLLECTION_NAME.find().sort({KEY:1})
									   db.mycol.find({},{"title":1,_id:0}).sort({"title":-1})
									   
									   
							</SORT_RECORD>

							<INDEXING>


								>>  Indexes support the efficient resolution of queries. Without indexes, MongoDB must scan every document of
									a collection to select those documents that match the query statement. This scan is highly inefficient and require MongoDB 
									to process a large volume of data.

								>>  Indexes are special data structures, that store a small portion of the data set in an easy-to-traverse form. 
									The index stores the value of a specific field or set of fields, ordered by the value of the field as specified in the index.
									
								ensureIndex()
								 -----	
									To create an index you need to use ensureIndex() method of MongoDB.
								   db.COLLECTION_NAME.ensureIndex({KEY:1})
								   
								   db.mycol.ensureIndex({"title":1})
								   
								   db.mycol.ensureIndex({"title":1,"description":-1})
								   
								   ensureIndex() method also accepts list of options (which are optional). Following is the list -

									Parameter	            Type                           	Description
									background	            Boolean	            Builds the index in the background so that building an index does not block other database activities. Specify true to build in the background. The default value is false.
									unique	                Boolean	            Creates a unique index so that the collection will not accept insertion of documents where the index key or keys match an existing value in the index. Specify true to create a unique index. The default value is false.
									name	                string				The name of the index. If unspecified, MongoDB generates an index name by concatenating the names of the indexed fields and the sort order.
									dropDups	            Boolean				Creates a unique index on a field that may have duplicates. MongoDB indexes only the first occurrence of a key and removes all documents from the collection that contain subsequent occurrences of that key. Specify true to create unique index. The default value is false.
									sparse	                Boolean				If true, the index only references documents with the specified field. These indexes use less space but behave differently in some situations (particularly sorts). The default value is false.
									expireAfterSeconds	    integer				Specifies a value, in seconds, as a TTL to control how long MongoDB retains documents in this collection.
									v	                    index version		The index version number. The default index version depends on the version of MongoDB running when creating the index.
									weights	                document			The weight is a number ranging from 1 to 99,999 and denotes the significance of the field relative to the other indexed fields in terms of the score.
									default_language	    string				For a text index, the language that determines the list of stop words and the rules for the stemmer and tokenizer. The default value is english.
									language_override	    string				For a text index, specify the name of the field in the document that contains, the language to override the default language. The default value is language.
										 




							</INDEXING>

							<AGGREGATION>

								>> Aggregations operations process data records and return computed results. Aggregation operations group values from multiple documents together, 
								  and can perform a variety of operations on the grouped data to return a single result. In SQL count(*) and with group by is an 
								  equivalent of mongodb aggregation.
								  
								aggregate()
								---	
								>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)
								
								In the collection you have the following data -

									{
									   _id: ObjectId(7df78ad8902c)
									   title: 'MongoDB Overview', 
									   description: 'MongoDB is no sql database',
									   by_user: 'tutorials point',
									   url: 'http://www.tutorialspoint.com',
									   tags: ['mongodb', 'database', 'NoSQL'],
									   likes: 100
									},
									{
									   _id: ObjectId(7df78ad8902d)
									   title: 'NoSQL Overview', 
									   description: 'No sql database is very fast',
									   by_user: 'tutorials point',
									   url: 'http://www.tutorialspoint.com',
									   tags: ['mongodb', 'database', 'NoSQL'],
									   likes: 10
									},
									{
									   _id: ObjectId(7df78ad8902e)
									   title: 'Neo4j Overview', 
									   description: 'Neo4j is no sql database',
									   by_user: 'Neo4j',
									   url: 'http://www.neo4j.com',
									   tags: ['neo4j', 'database', 'NoSQL'],
									   likes: 750
									},
								   >>
									 Now from the above collection, if you want to display a list stating how many tutorials are written by each user, then you will use the following aggregate() method -

										> db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : 1}}}])
										{
										   "result" : [
											  {
												 "_id" : "tutorials point",
												 "num_tutorial" : 2
											  },
											  {
												 "_id" : "Neo4j",
												 "num_tutorial" : 1
											  }
										   ],
										   "ok" : 1
										}
										
									 >>
										$sum	      	Sums up the defined value from all documents in the collection.	db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : "$likes"}}}])
										$avg			Calculates the average of all given values from all documents in the collection.	db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$avg : "$likes"}}}])
										$min			Gets the minimum of the corresponding values from all documents in the collection.	db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$min : "$likes"}}}])
										$max			Gets the maximum of the corresponding values from all documents in the collection.	db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$max : "$likes"}}}])
										$push			Inserts the value to an array in the resulting document.	db.mycol.aggregate([{$group : {_id : "$by_user", url : {$push: "$url"}}}])
										$addToSet		Inserts the value to an array in the resulting document but does not create duplicates.	db.mycol.aggregate([{$group : {_id : "$by_user", url : {$addToSet : "$url"}}}])
										$first			Gets the first document from the source documents according to the grouping. Typically this makes only sense together with some previously applied “$sort”-stage.	db.mycol.aggregate([{$group : {_id : "$by_user", first_url : {$first : "$url"}}}])
										$last			Gets the last document from the source documents according to the grouping. Typically this makes only sense together with some previously applied “$sort”-stage.		 





							</AGGREGATION>

							<MONGO_REPLICATION>

									>>>
										To keep your data safe
										High (24*7) availability of data
										Disaster recovery
										No downtime for maintenance (like backups, index rebuilds, compaction)
										Read scaling (extra copies to read from)
										Replica set is transparent to the application

									>>> Replica Set Features
											A cluster of N nodes
											Any one node can be primary
											All write operations go to primary
											Automatic failover
											Automatic recovery
											Consensus election of primary

							</MONGO_REPLICATION>

							<Sharding>

									Why Sharding?
											In replication, all writes go to master node
											Latency sensitive queries still go to master
											Single replica set has limitation of 12 nodes
											Memory can't be large enough when active dataset is big
											Local disk is not big enough
											Vertical scaling is too expensive



							</Sharding>

							<BACKUP>

								>> mongodump
								>> mongorestore



							</BACKUP>

  </mongo>

</database>

<docker>

        <Docker_Engine>
		
				It is a client server application that contains the following major components.

				A server which is a type of long-running program called a daemon process.
				The REST API is used to specify interfaces that programs can use to talk to the daemon and instruct it what to do.
				A command line interface client.
				
				        CLI --------------------------> manages image/network/data volums/container
						Rest ApI
                        deamon server						
						 
				   
	    </Docker_Engine>			
				
		<Docker_Architecture>
		
						Docker follows client-server architecture. Its architecture consists mainly three parts.

						1) Client: Docker provides Command Line Interface (CLI) tools to client to interact with Docker daemon. Client can build, run and stop application. Client can also interact to Docker_Host remotely.

						2) Docker_Host: It contains Containers, Images, and Docker daemon. It provides complete environment to execute and run your application.

						3) Registry: It is global repository of images. You can access and use these images to run your application in Docker environment.
						
						
						Client                       Docker Host                      Repository
						  
						  build                      Docker deamon                       tomcat/any
						  pull                       container
						  run                        images
						
						
		
		</Docker_Architecture>
		
		<docker_setup>
		   
		   it natively run on linux environments
		   to run on windows --windows 10 is required
		   to run on windows 7 or  minor of windows 10 "Docker Toolbox " should install.
		   
		   <Docker_Toolbox>
		         here docker engine(only on linux or win10) doesn't works it uses docker machine
		            
					1. DownLoad Docker ToolBox and install follow instruction 
					2. it installs below three componenets 
					         1. Docker QuickStart
							        here all pre configured / default setup is configured.
									like it setup virtualbox and linux os on virtual box
									
							 2. Docekr kitematick
							 3. Virtual Box
		   
		   
		   </Docker_Toolbox>
		   
		   
		   
		</docker_setup>
				


</docker>

<CLOUD>

  <AWS>
  
  </AWS>
  
  <GCC>
  
  </GCC>
  
  <IOT>
  
  </IOT>

</CLOUD>

<Front_END>

   <HTML>
   
   </HTML>
   
   <JAVASCRIPT>
       
	  
   </JAVASCRIPT>
   
   <JQUERY>
   
   </JQUERY>
    
   <CSS>

   </CSS>   
   
   <BOOTSTRAP>
   
   </BOOTSTRAP>
   
   <REACT_JS>
   
   </REACT_JS>
   

</Front_END>


<path>
 
 <java_full_stack_developer>
   
   backend.....
	   <maven_svn_logger_docreport_mail/>
	   <corejava/>
	   <j2ee/>
	   <hibernate/>
	   <spring_core_mvc_dataordao_hibernate_rest_security_aop_transaction_exception/>
	   <spring_BOOT_microservices/>
	   <spring_cloud/>
   
   cloud....
       <AWS/>
   
   
   UI......
	   <angularJS/>
	   <ReactJS/>
	   <html_css_js_jq_json_xml/>  
   
   database....
       <oracle_mysql_mongodb/>   
   
 </java_full_stack_developer>
 
 <Big_DATA_Devloper>
 
 </Big_DATA_Devloper>
 
 <Artificial_Intelligence>
 
     To summarise, here’s what you need to master before being able to learn and understand artificial intelligence:

      1. Advanced Math (e.g. correlation algorithms) and Stats
      2. Programming language
      3. Machine Learning
      4. PATIENCE – yes, on top of everything you need lots of patience.
	  
	  Probability, Statistics, Linear Algebra, 
	  Python programming, 
	  20+ most used techniques in classification, regression,
	  clustering, matrix-factorization and deep-learning.
 
 
 
 </Artificial_Intelligence>
 
 <BLOCKCHAIN>
 
 </BLOCKCHAIN>
 
 


</path>

<interview_question>

   <java>
   
       <synchronous_asynchronus>
	   
	   </synchronous_asynchronus>
	   
	   <MARKERinterface>
	      
		  
	   </MARKERinterface>
       
	   <SOLId_DESIGN_PRINCIPLE>
	   
	   
	   
	   </SOLId_DESIGN_PRINCIPLE>
	   
	   <sort_list_using_lambda>
	   
	   </sort_list_using_lambda>
	   
	   <LinkedHashMAP>
	   
	   </LinkedHashMAP>
	   
	   <ConcurrentHashMAP>
	   
	   </ConcurrentHashMAP>
	   
	   <SORTEDhashmap>
	   
	   </SORTEDhashmap>
	   
	   <comparableVSComparator>
	   
	   </comparableVSComparator>
	   
	   <concurrentPACKAGES>
	   
	   </concurrentPACKAGES>
	   
	   <LINKEDlistimplementation>
	   
	   </LINKEDlistimplementation>
       
	   <FINDmaximumoccuranceOF_NUMBER>
	     
		 >>1  USING EQUALS
		     loop nad check every element
			 
		 >>2  NOT USING EQUALS
		       a. loop and put value in map value as key and count as value
                     map.put(key, (j==null?1:j))	
   
               b. convert array to List   toObject()
                       iterate and use Collections.frequency(list,'');			   
	   
	   </FINDmaximumoccuranceOF_NUMBER>
	   
	   <ALL_SORTING_ALGO>
	   
	   </ALL_SORTING_ALGO>
	   
	   <why_tostring_hascode_is_required>
	   
	   </why_tostring_hascode_is_required>
   
   </java>
   
   <monog_db>
      
	  <return_type_of_collection>
	  
	  
	  </return_type_of_collection>
	  
   </mongo_db>
   
   <oracle_db>
      
	    <remove_coloumn_foreignKEY>
		
		
		</remove_coloumn_foreignKEY>
		
		<INNERjoin_LEFTOUTERJOIN>
		
		
		</INNERjoin_LEFTOUTERJOIN>
	  
	  
   </oracle_db>
   
   
   <spring>
   
           <diff_beanfactory_applicationContext>
			
			    1. Bean Factory

						a. Bean instantiation/wiring
						b. Application Context
						c. Annotation support                        --NO
						d. BeanPostProcessor Registration            --Manual
						e. implementation 							 --XMLBeanFactory
						f. internationalization                      --No
						g. Enterprise services 						 --No
						h. ApplicationEvent publication              --No
						i. Beanfactory is lazy initializer [why I am telling lazy means , it can’t create the bean objects at the 
						   time of creating IOC container using Beanfactory . it creates the bean objects on demand ,
						   when we call the factory.getBean()]

				2. Application Context:
				
					   a. Bean instantiation/wiring
					   b. Automatic BeanPostProcessor registration
					   c. Automatic BeanFactoryPostProcessor registration
					   d. Convenient MessageSource access (for i18n)
					   e. ApplicationEvent publication
					   f. Annotation support                           -- Yes
					   g. BeanPostProcessor Registration               -- Automatic
				   	   h. implementation 							   -- ClassPath/FileSystem/WebXmlApplicationContext
					   i. internationalization                         -- Yes
					   j. Enterprise services 						   -- Yes
					   k. ApplicationEvent publication                 -- Yes
					   l. ApplicationContext is eager initializer ,at the time of creating the IOC container itself 
					      it instantiate all the beans which scope is singleton.
					  
					  So if you need any of the points presented on the Application Context side, you should use ApplicationContext.
								
			
			</diff_beanfactory_applicationContext>
	        
			<diff_componentscan_annotationconfig>
			
			      in simple words: 
                     >> annotation-config: Annotation config main job is to activate all the annotations that are present in java beans 
					    and those are already registered either by defining in your application context file or being registered 
					    while component scanning. Important point is they need to be registered. 
						
						>> it is required when bean is not explicitly registered and activates bean which are defalut loaded at the time of spring context.
                        >> activates all annotations in beans which are already registered in the application context. Those beans could be defined
						   with XML or by package scanning.
						   
						   
                     >> component-scan: Component scan can do everything that annotation config does,in addition to it,it also registers 
					    the java classes as spring bean those are annotated with @Component , @Service ,@Repository, @Controller etc.
						
			</diff_componentscan_annotationconfig>
             
			 
		    <callback_method>
			
			</callback_method>
			
			<circular_dependency>
			   
			   >>throws BeanCurrentlyInCreationException
			   
			   1. setter
			   2. @lazy
			   
			</circular_dependency>
			
			<constructor_vs_setter_DI>
			 
			 
			</constructor_vs_setter_DI>
   </spring>
   
   <spring_webservices_and_microservice>
     
	 <synchronous_asynchronus_inwebservice>
	 
	 </synchronous_asynchronus_inwebservice>
	 
	 
   </spring_webservices_and_microservice>


</interview_question>

